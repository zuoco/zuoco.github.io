[{"content":" 1. 认识 VTK 渲染管线 1.1. 使用 C++ API 渲染圆锥体 1.2. 使用 Python API 渲染圆锥体 2. 资料链接 1. 认识 VTK 渲染管线 先了解几个VTK中的常用模板类型：\n模板类型 功能 vtkNew VTK封装的智能指针。 vtkNamedColors 封装了VTK内置的命名颜色集合，提供RGB颜色定义，常用于可视化场景中的颜色配置。 vtkConeSource VTK可视化管线中的一个节点，它负责产生数据（输出类型为 vtkPolyData），供后续过滤器处理。 vtkPolyDataMapper 该类将 vtkPolyData 数据转换为几何图元，方便使用底层接口渲染，如 OpenGL。\n需要将 vtkPolyData 的 output 连接到 vtkPolyDataMapper 的 input vtkActor “演员” 是场景中所有可渲染对象的基类。\n负责：绑定几何数据（通过 SetMapper）、管理外观属性（颜色、光照、纹理等）、应用变换矩阵（平移、旋转、缩放） vtkRenderer VTK 渲染器，管理舞台（渲染场景）中的渲染操作，一个渲染器可以管理多个 Actor。 vtkRenderWindow 渲染窗口是最终的输出载体，负责： 管理一个或多个渲染器（通过 AddRenderer()）、 控制窗口大小和位置、 处理操作系统级的窗口事件、 触发实际的渲染操作。 vtkCamera 可以理解为观察着的眼睛 1.1. 使用 C++ API 渲染圆锥体 我们看一个简单的Demo ： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;vtkActor.h\u0026gt; #include \u0026lt;vtkCamera.h\u0026gt; #include \u0026lt;vtkConeSource.h\u0026gt; #include \u0026lt;vtkNamedColors.h\u0026gt; #include \u0026lt;vtkNew.h\u0026gt; #include \u0026lt;vtkPolyDataMapper.h\u0026gt; #include \u0026lt;vtkProperty.h\u0026gt; #include \u0026lt;vtkRenderWindow.h\u0026gt; #include \u0026lt;vtkRenderer.h\u0026gt; int main(int, char*[]) { // 颜色对象。 vtkNew\u0026lt;vtkNamedColors\u0026gt; colors; // 创建了一个圆锥体数据源并设置其参数。 vtkNew\u0026lt;vtkConeSource\u0026gt; cone; cone-\u0026gt;SetHeight(3.0); // 设置圆锥高度为3.0单位 cone-\u0026gt;SetRadius(1.0); // 设置底面半径为1.0单位 cone-\u0026gt;SetResolution(10); // 设置圆锥侧面由10个分段构成，应该叫做棱锥 // 将 vtkPolyData 的 output 连接到 vtkPolyDataMapper 的 input。 vtkNew\u0026lt;vtkPolyDataMapper\u0026gt; coneMapper; coneMapper-\u0026gt;SetInputConnection(cone-\u0026gt;GetOutputPort()); // 创建并配置一个VTK演员（vtkActor）对象。 vtkNew\u0026lt;vtkActor\u0026gt; coneActor; coneActor-\u0026gt;SetMapper(coneMapper); // 绑定几何数据 coneActor-\u0026gt;GetProperty()-\u0026gt;SetColor(colors-\u0026gt;GetColor3d(\u0026#34;MistyRose\u0026#34;).GetData()); // 管理外观属性 // 创建并配置一个VTK渲染器。 vtkNew\u0026lt;vtkRenderer\u0026gt; ren1; // vtkRenderer 实例，用于管理场景中的渲染操作 ren1-\u0026gt;AddActor(coneActor); // 将之前创建的演员（coneActor）添加到渲染器中，一个渲染器可以管理多个演员 ren1-\u0026gt;SetBackground(colors-\u0026gt;GetColor3d(\u0026#34;MidnightBlue\u0026#34;).GetData()); // 设置渲染器的背景颜色， // 创建并配置VTK渲染窗口 vtkNew\u0026lt;vtkRenderWindow\u0026gt; renWin; // 最终显示渲染结果的窗口 renWin-\u0026gt;AddRenderer(ren1); // 将之前创建的渲染器添加到窗口，一个窗口可包含多个渲染器 renWin-\u0026gt;SetSize(300, 300); renWin-\u0026gt;SetWindowName(\u0026#34;Tutorial_Step1\u0026#34;); // 锥体的连续旋转动画 for (int i = 0; i \u0026lt; 360; ++i) { // 触发渲染窗口的渲染操作 renWin-\u0026gt;Render(); // GetActiveCamera() 获取当前渲染器的主相机 // Azimuth(1) 表示绕观察点水平旋转 1 度 ren1-\u0026gt;GetActiveCamera()-\u0026gt;Azimuth(1); } return EXIT_SUCCESS; } 这里就讲一下，相机视角的旋转问题： vtkCamera* GetActiveCamera();获取当前渲染器的活动相机。\nvoid Azimuth(viskores::Float32 angleDegrees);旋转相机水平时视角。\n既然有水平视角，那么就有垂直视角和旋转，他们的关系如图： 1.2. 使用 Python API 渲染圆锥体 和C++过程一样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import vtkmodules.vtkInteractionStyle # 提供交互样式支持（如鼠标/键盘控制） import vtkmodules.vtkRenderingOpenGL2 # 基于OpenGL 2.0的渲染引擎模块，必须导入的 from vtkmodules.vtkCommonColor import vtkNamedColors from vtkmodules.vtkFiltersSources import vtkConeSource from vtkmodules.vtkRenderingCore import ( vtkActor, vtkPolyDataMapper, vtkRenderWindow, vtkRenderer ) def main(argv): colors = vtkNamedColors() cone = vtkConeSource() cone.SetHeight(3.0) cone.SetRadius(1.0) cone.SetResolution(10) coneMapper = vtkPolyDataMapper() coneMapper.SetInputConnection(cone.GetOutputPort()) coneActor = vtkActor() coneActor.SetMapper(coneMapper) coneActor.GetProperty().SetColor(colors.GetColor3d(\u0026#39;MistyRose\u0026#39;)) ren1 = vtkRenderer() ren1.AddActor(coneActor) ren1.SetBackground(colors.GetColor3d(\u0026#39;MidnightBlue\u0026#39;)) renWin = vtkRenderWindow() renWin.AddRenderer(ren1) renWin.SetSize(300, 300) renWin.SetWindowName(\u0026#39;Tutorial_Step1\u0026#39;) for i in range(0, 360): renWin.Render() ren1.GetActiveCamera().Azimuth(1) if __name__ == \u0026#39;__main__\u0026#39;: import sys main(sys.argv) 2. 资料链接 VTK官方Demo，循序渐进的示例程序。 Python Demo，Python 示例程序。 VTK接口文档，类型以及函数接口文档。 类文档，带有示例的类文档。\n官方网站的下载页面有 6 下载文件：\n1 2 3 4 5 6 7 8 9 10 11 12 VTK-9.5.1.tar.gz # 核心源码包 # 测试数据包，解压后就是 `VTK-x.x.x/.ExternalData/` VTKData-9.5.1.tar.gz # 测试数据索引包， 告诉 CMake ExternalData 模块去哪里下载真正的测试输入 \u0026amp; 基准图像。 VTKDataFiles-9.5.1.tar.gz # 和上面一样，但是包含了完整测试数据集，不用在线下载了。 # 离线 HTML 文档包 vtkDocHtml-9.5.1.tar.gz # 这两个好像是旧版的测试数据包，不需要了 VTKLargeData-9.5.1.tar.gz VTKLargeDataFiles-9.5.1.tar.gz 当然官网也提供了Python扩展包。\n","date":"2025-08-29T00:00:00Z","permalink":"https://zuoco.github.io/p/%E7%AC%AC%E4%B8%80%E4%B8%AA-vtk-demo/","title":"第一个 VTK Demo"},{"content":" 今天介绍一个开源项目——FreeCAD-MCP，这是一个集成了MCP的FreeCAD控制方案，将AI助手与3D建模软件结合起来，用户可以通过描述需求控制FreeCAD生成3D模型，还支持从2D图纸生成3D模型，支持迭代设计细化，也就是可以请求对现有设计进行修改并实时查看更改。\n该项目的整体架构如下：\n该系统由两个主要部分组成： FreeCAD RPC Server 和 FreeCAD MCP Server。\n1. FreeCAD RPC Server 2. FreeCAD MCP Server 3. 核心功能 1. FreeCAD RPC Server 这是一个基于XML-RPC协议的服务器，作为插件安装在 FreeCAD 中，它的功能是通过 XML-RPC 接口公开 FreeCAD 控制功能，零件库的访问功能给MCP服务器，并且处理处理来自MCP服务器的请求。\n1 2 3 4 5 6 7 8 9 # InitGui.py FreeCAD插件初始化文件 class FreeCADMCPAddonWorkbench(Workbench): MenuText = \u0026#34;MCP Addon\u0026#34; ToolTip = \u0026#34;Addon for MCP Communication\u0026#34; # ... # ... Gui.addWorkbench(FreeCADMCPAddonWorkbench()) 2. FreeCAD MCP Server 这是一个Python包，实现模型上下文协议，为模型提供访问FreeCAD功能的通道。FreeCAD-MCP Server 通过XML-RPC连接到FreeCAD RPC服务器，将Claude的请求翻译成FreeCAD可以理解的命令 ，最后将结果作为文本和可选图像返回给模型。\nFreeCAD MCP Server 向AI助手暴露的核心 FreeCAD 工具如下：\n工具 功能 = 文档管理 = \u0026mdash;\u0026mdash; create_document 在FreeCAD中创建新文档 get_objects 获取文档中的所有对象 = 对象管理 = \u0026mdash;\u0026mdash; create_object 在FreeCAD中创建一个新对象 edit_object 在FreeCAD中编辑对象 delete_object 在FreeCAD中删除对象 get_object 在文档中获取对象 = 零件库 = \u0026mdash;\u0026mdash; insert_part_from_library 从零件库中插入零件 get_parts_list 获取零件库中的零件列表 = 可视化 = \u0026mdash;\u0026mdash; get_view 获取活动视图的屏幕截图 = 脚本 = \u0026mdash;\u0026mdash; execute_code 在FreeCAD中执行Python代码 3. 核心功能 这个控制系统提供了 4 项核心功能：\n通过对话设计组件， 用户可以描述他们想要创建的零件，Claude会生成必要的FreeCAD操作。 从2D图纸创建3D模型， Claude可以解释2D图纸并创建相应的3D模型。 迭代设计细化， 用户可以请求对现有设计进行修改并实时查看更改。 访问零件库， 用户可以要求Claude从FreeCAD零件库中插入标准件。 ","date":"2025-08-20T00:00:00Z","permalink":"https://zuoco.github.io/p/freecad-mcp%E9%80%9A%E8%BF%87ai%E5%8A%A9%E6%89%8B%E6%9D%A5%E6%93%8D%E4%BD%9Cfreecad/","title":"FreeCAD-MCP，通过AI助手来操作FreeCAD"},{"content":"使用C++编写一个Python模块要做 4 件事情：\n1. C++类型定义，将这个类型封装为 Python 类对象。 2. 定义一个模块，一个模块对应一个C++的类型。 3. 实现模块初始化函数，当import 模块时，Python会调用这个初始化函数。 4. 构建模块，使用 setup.py 构建模块。 下面我们一 一讲解这 4 件事情:\n1. 使用C++封装一个 Python 对象 2. 定义模块 3. 模块初始化 4. 构建模块 1. 使用C++封装一个 Python 对象 这一步涉及一些宏函数， 封装Python对象的C++类中需要实现一个静态成员函数static void init_type(void)，在这个函数中使用这些宏来注册那些要暴露给Python的成员函数，并且模块初始化中需要调用这个静态函数。\n这些宏分为两部分： 注册、实现，先来了解一下：\n1. 用于注册方法的宏： 1 2 3 4 5 6 7 8 9 /* * 这些宏需要3个参数： * 1. Python中的方法名称。 * 2. C++中的方法名称。 * 3. 函数描述信息。 */ PYCXX_ADD_NOARGS_METHOD // 注册一个无参数方法 PYCXX_ADD_VARARGS_METHOD // 注册一个接受可变参数的方法 PYCXX_ADD_KEYWORDS_METHOD // 注册一个支持关键字参数的方法 2. 用于实现方法的宏 1 2 3 4 5 6 7 8 /* * 这些宏需要2个参数： * 1. C++类名称。 * 2. C++函数名称。 */ PYCXX_NOARGS_METHOD_DECL // 定义一个无参数方法 PYCXX_VARARGS_METHOD_DECL // 定义一个接受可变参数的方法 PYCXX_KEYWORDS_METHOD_DECL // 定义一个支持关键字参数的方法 3. 示例 类定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class CppClass: public Py::PythonClass\u0026lt; CppClass \u0026gt; { public: // self: 指向 Python 实例的指针，用于将 C++ 对象与 Python 实例关联。在基类构造函数中，self 会绑定 C++ 对象到 Python 实例。 CppClass( Py::PythonClassInstance *self, Py::Tuple \u0026amp;args, Py::Dict \u0026amp;kwds ); // virtual ~CppClass(); // 注册成要暴露给Python的成员函数 static void init_type(); Py::String m_value; }; 成员函数实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* 构造函数 */ CppClass::CppClass(Py::PythonClassInstance* self, Py::Tuple\u0026amp; args, Py::Dict\u0026amp; kwds): Py::PythonClass\u0026lt;CppClass\u0026gt;::PythonClass(self, args, kwds)，m_value(\u0026#34;_default_value\u0026#34;) { // ... }; /* 注册成员函数 */ static void CppClass::init_type() { behaviors().name( \u0026#34;simple.CppClass\u0026#34; ); // 设置 Python 中该类的全限定名。simple 是模块名，new_style_class 是类名。 behaviors().doc( \u0026#34;documentation for CppClass class\u0026#34; ); // 设置类的文档字符串（__doc__）， 在 Python 中，用户可以通过 help(simple.new_style_class) 查看此文档。 behaviors().supportGetattro(); // 启用对 __getattr__ 的支持，允许 Python 通过属性名访问类的成员（如 obj.value）。 behaviors().supportSetattro(); // 启用对 __setattr__ 的支持，允许 Python 修改属性值（如 obj.value = \u0026#34;new value\u0026#34;）。 // 启用对 Python 数字运算的支持，允许 C++ 类对象参与数学运算, 需在类型中实现 number_add 和 number_inplace_add 方法。 behaviors().supportNumberType( Py::PythonType::support_number_add, Py::PythonType::support_number_inplace_add ); /* 注册C++成员函数到Pythonn对象 */ /* * python名称： func * C++名称： cppclass_func * 描述文档： docs for cppfunc */ PYCXX_ADD_NOARGS_METHOD( func, cppclass_func, \u0026#34;docs for cppfunc\u0026#34; ); /* * Python 调用格式为 obj.call_member(\u0026#34;func_name\u0026#34;, arg1, arg2, ...)，其中 \u0026#34;func_name\u0026#34; 是目标成员函数名。 */ PYCXX_ADD_VARARGS_METHOD( func_call_member, cppclass_call_member, \u0026#34;docs for func_call_member\u0026#34; ); // 完成类型注册，通知 PyCXX 类型定义完成，准备就绪。必须调用这个方法，否则类无法在 Python 中正常使用。 behaviors().readyType(); }; 被注册的函数定义时，要符合注册时函数签名要求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 不带参数的成员函数 Py::Object cppclass_func_noargs( void ) { // ...... } PYCXX_NOARGS_METHOD_DECL( CppClass, cppclass_func_noargs ) // 带有可变参数的函数，带有Py::Tuple \u0026amp;参数 Py::Object Py::PythonClass::cppclass_call_member( const Py::Tuple \u0026amp;args ) { // ...... } PYCXX_VARARGS_METHOD_DECL( CppClass, cppclass_call_member ) // CppClass: 类名， cppclass_call_member：成员函数名。 // 带有字参数的函数，带有Py::Dict \u0026amp;参数 Py::Object cppclass_func_keyword( const Py::Tuple \u0026amp;args, const Py::Dict \u0026amp;kwds ) { // ...... } PYCXX_KEYWORDS_METHOD_DECL( CppClass, cppclass_func_keyword ) 2. 定义模块 使用Py::ExtensionModule\u0026lt;T\u0026gt;类来定义模块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class MyModule : public Py::ExtensionModule\u0026lt;MyModule\u0026gt; { public: MyModule(): Py::ExtensionModule\u0026lt;MyModule\u0026gt;( \u0026#34;mymodule\u0026#34; ) // 模块名称 \u0026#34;mymodule\u0026#34; 必须与生成的动态库文件名一致（如 simple.so 或 simple.pyd）。 { /* 1. 初始化 CppClass 的 Python 类定义 */ CppcClass::init_type(); /* 2. 注册模块级别的函数 */ add_varargs_method(\u0026#34;CppClass\u0026#34;, \u0026amp;MyModule::factory_cppclass, \u0026#34;***\u0026#34;); // 向 Python 扩展模块注册接受可变参数的方法 add_keyword_method(\u0026#34;func\u0026#34;, \u0026amp;MyModule::func, \u0026#34;***\u0026#34;); // 向 Python 扩展模块添加一个支持字典类型参数的方法 // ... ... /* 3. 模块初始化 */ initialize( \u0026#34;documentation for the mymodule\u0026#34; ); /* 4. 模块的字典对象，字典包含了模块的所有属性（变量、函数、类等），这个字典对象是在initialize()中创建的 */ Py::Dict d( moduleDictionary() ); // 获取模块的字典对象。 d[\u0026#34;var\u0026#34;] = Py::String( \u0026#34;var value\u0026#34; ); // 在模块字典中创建一个名为 \u0026#34;var\u0026#34; 的字符串变量赋值为 \u0026#34;var value\u0026#34;。 Py::Object x( CppClass::type() ); // 获取 CppClass 类的类型对象（PyTypeObject），将其包装为 PyCXX 的 Object 类型 d[\u0026#34;CppClass\u0026#34;] = x; // 将 CppClass 类型对象添加到模块字典中，这样在 Python 中就可以通过 mymodule.CppClass 访问这个类并创建其实例 /* 5. 初始化异常 */ SimpleError::init( *this ); // 创建一个名为 \u0026#34;ModuleError\u0026#34; 的扩展异常类型，将这个异常类型添加到模块的字典中，使其在 Python 中可以通过 mymodule.ModuleError 访问。 } virtual ~MyModule(){} }; add_varargs_method和add_keyword_method是 Py::ExtensionModule 的两个静态方法，分别用于注册带可变参数的成员函数和带字典参数的成员函数。 两种函数在定义时，也要符合注册时的规范：\n1 2 3 4 5 6 7 8 9 10 11 // 使用add_varargs_method注册的函数，函数参数列表必须有Py::Tuple类型的参数，可以不用但是不能没有。 Py::Object MyModule::factory_cppclass( const Py::Tuple \u0026amp;/*args*/ ) { // ... } // 使用add_keyword_method注册的函数，函数参数列表必须有Py::Dict 类型的参数，可以不用但是不能没有。 Py::Object MyModule::func( const Py::Tuple \u0026amp;args, const Py::Dict \u0026amp;kwds ) { // .... }; 3. 模块初始化 现在需要定义一个模块初始化函数，该函数的形式为PyObject *PyInit_xxx()， “xxx”就是模块名称。 当执行 import xxx 时，Python 解释器会加载 xxx 的动态库（如 xxx.so 或 xxx.pyd），并调用 PyInit_xxx 初始化模块。\n1 2 3 4 5 6 7 // EXPORT_SYMBOL是平台的动态库导出标记 extern \u0026#34;C\u0026#34; EXPORT_SYMBOL PyObject *PyInit_simple() { // ... // ... // 返回模块之指针（一个 PyObject 对象） } 4. 构建模块 使用Python的setuptools编写构建脚本，一般命名为setup.py，该脚本文件包含三部分：\n系统路径配置。 配置必要的链接库。 模块配置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # 导入模块 import os, sys import setuptools from setup, Extension # 1. 系统路径配置： /usr/share/pythonx.xx/CXX/ support_dir = os.path.normpath( os.path.join( sys.prefix, # sys.prefix在Linux系统上就是 /usr \u0026#39;share\u0026#39;, \u0026#39;python%d.%d\u0026#39; % (sys.version_info[0],sys.version_info[1]), \u0026#39;CXX\u0026#39; ) ) # 2. 需要链接的库 if os.name == \u0026#39;posix\u0026#39;: CXX_libraries = [\u0026#39;stdc++\u0026#39;,\u0026#39;m\u0026#39;] else: CXX_libraries = [] # 3. 模块配置 setup( name = \u0026#34;xxx\u0026#34;, # 模块名称 version = \u0026#34;%s.%s.%s\u0026#34; % (v_maj, v_min, v_pat), # 模块版本 maintainer = \u0026#34;xxx\u0026#34;, # 模块维护者 maintainer_email = \u0026#34;xxx@xxx.com\u0026#34;, # 模块维护者邮箱 description = \u0026#34;xxxxxx\u0026#34;, # 模块描述，简要说明项目用途 url = \u0026#34;http://xxxx.com/\u0026#34;, # 模块地址 packages = [\u0026#39;mxxx\u0026#39;], # 要打包的Python包列表，也可以使用find_packages()查找 package_dir = {\u0026#39;mxxx\u0026#39;: \u0026#39;.\u0026#39;}, # 将mxxx包的源码目录（.表示setup.py所在目录） # 模块配置 ext_modules = [ Extension( \u0026#39;xxx.xxx\u0026#39;, # 模块全限定名 # 源文件列表 sources = [ \u0026#39;src_0.cxx\u0026#39;, \u0026#39;src_1.cxx\u0026#39;, \u0026#39;src_n.cxx\u0026#39;, os.path.join(support_dir,\u0026#39;cxxsupport.cxx\u0026#39;), os.path.join(support_dir,\u0026#39;cxx_extensions.cxx\u0026#39;), os.path.join(support_dir,\u0026#39;cxx_exceptions.cxx\u0026#39;), os.path.join(support_dir,\u0026#39;IndirectPythonInterface.cxx\u0026#39;), os.path.join(support_dir,\u0026#39;cxxextensions.c\u0026#39;) ] ) ] ) ","date":"2025-08-12T00:00:00Z","permalink":"https://zuoco.github.io/p/python%E7%9A%84c-%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%9102-%E4%BD%BF%E7%94%A8pycxx%E5%BC%80%E5%8F%91python%E6%A8%A1%E5%9D%97/","title":"Python的C++扩展开发（02） — 使用PyCxx开发Python模块"},{"content":"Workbench是FreeCAD模块提供的工作台实现，工作台就是一组功能的集合，例如“零件建模工作台”、“CAM工作台”、“装配体工作台”。它定义了哪些GUI元素（如工具栏、菜单）会被添加到主窗口中，以及哪些会被移除或隐藏。当一个workbench对象首次被激活时，它所代表的模块会被加载到RAM中。\n1. 工作台基类 — Gui::Workbench 2. 工作台类 3. 零件设计工作台 — PartDesignWorkbench 1. 工作台基类 — Gui::Workbench 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 namespace Gui { // GUI元素体系，支持4类界面元素，实际上还有一个命令栏（CommandBars） class MenuItem; // 菜单栏 class ToolBarItem; // 工具栏 class DockWindowItems; // 停靠窗口 class WorkbenchManager; class GuiExport Workbench : public Base::BaseClass { // ... // 核心生命周期管理 /** * Activates the workbench and adds/removes GUI elements. */ bool activate(); /** Run some actions when the workbench gets activated. */ virtual void activated(); /** Run some actions when the workbench gets deactivated. */ virtual void deactivated(); // Python绑定支持 PyObject* getPyObject() override; // ... protected: // 设置各种小窗口 /** Returns a MenuItem tree structure of menus for this workbench. */ virtual MenuItem* setupMenuBar() const=0; // 设置菜单栏 /** Returns a ToolBarItem tree structure of toolbars for this workbench. */ virtual ToolBarItem* setupToolBars() const=0; // 设置工具栏 /** Returns a ToolBarItem tree structure of command bars for this workbench. */ virtual ToolBarItem* setupCommandBars() const=0; // 设置命令栏 /** Returns a DockWindowItems structure of dock windows this workbench. */ virtual DockWindowItems* setupDockWindows() const=0; // 设置停靠窗口 // ... }; } 管理不同模块的GUI元素展示与激活逻辑。\n2. 工作台类 FreeCAD提供了几种不同类型的workbench基类，最终的工作台继承自这些基类：\n基类型 功能 派生类型 StdWorkbench 标准工作台类，定义了标准的菜单、工具栏等元素 BlankWorkbench 完全空白的工作台 PythonBaseWorkbench 支持Python操作的工作台 其他 \u0026hellip; 以StdWorkbench为例，看看都重写了什么：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class GuiExport StdWorkbench : public Workbench { TYPESYSTEM_HEADER_WITH_OVERRIDE(); public: StdWorkbench(); ~StdWorkbench() override; public: // 上下文菜单，可能是右键菜单 /** Defines the standard context menu. */ void setupContextMenu(const char* recipient, MenuItem*) const override; void createMainWindowPopupMenu(MenuItem*) const override; protected: // 设置工作台的各个组件 /** Defines the standard menus. */ MenuItem* setupMenuBar() const override; /** Defines the standard toolbars. */ ToolBarItem* setupToolBars() const override; /** Defines the standard command bars. */ ToolBarItem* setupCommandBars() const override; /** Returns a DockWindowItems structure of dock windows this workbench. */ DockWindowItems* setupDockWindows() const override; friend class PythonWorkbench; }; 3. 零件设计工作台 — PartDesignWorkbench 零件设计工作台提供参数化零件设计功能，分为App(核心逻辑)和Gui(界面)两个部分。 源码目录如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ./Mod/PartDesign/ ├── __init__.py ├── CMakeLists.txt ├── App/ # 核心逻辑实现，包含特征类（Extrude/Revolution/Pipe等） ├── Gui/ # 用户界面组件，包含参数面板（TaskXXXParameters）和视图提供者（ViewProvider） ├ ├── fcgear/ # 用于生成渐开线齿轮的FreeCAD插件（通过贝塞尔曲线近似渐开线齿廓，并支持生成外部齿轮 和 内部齿轮）。 ├── fcsprocket/ # 用于生成链齿轮的FreeCAD插件。 ├── WizardShaft/ # 轴类零件，包括参数化建模（ShaftFeature）、力学计算（Shaft类）和可视化分析（Diagram类） ├── Resources/ # 提供符合国标的孔特征参数数据库，包含多个JSON文件，每一个代表一个标准，包含沉头孔、埋头孔、标准螺纹孔等类型。 ├ ├── Scripts/ # 建模功能扩展，每个文件实现特定的机械设计功能 ├ ├── Init.py ├── InitGui.py # 零件设计工作台 ├ ├── InvoluteGearFeature.py # 渐开线齿轮的参数化建模功能，基于fcgear中的Python模块 ├── InvoluteGearFeature.ui # 渐开线齿轮参数设计界面 ├ ├── SprocketFeature.py # 链轮齿的参数化建模功能，基于fcsprocket中的Python模块 ├── SprocketFeature.ui # 链轮齿参数设计界面 ├ ├── PartDesign_Model.xml # 这是Python扩展代码生成机制的配置文件 └── PartDesignGlobal.h # 全局头文件 工作台当然是基于FreeCAD、FreeCADGui模块，这两个模块是通过C++实现的Python扩展，是FreeCAD的公共基础，而对于每一个模块，模块本身的功能是使用Python实现的。\n在PartDesignGui命名空间下，定义的零件工作台类PartDesignGui::Workbench，实现核心功能，\n1 2 3 4 5 6 7 8 9 // Mod/PartDesign/Gui/Workbench.h namespace PartDesignGui { class PartDesignGuiExport Workbench : public Gui::StdWorkbench { // ... }; } Mod/PartDesign/InitGui.py中定义了PartDesignWorkbench类型，该类继承了 PartDesignGui::Workbench。当GUI运行起来时，会运行这个InitGui.py，从而加载零件工作台，包括PartDesignGui和PartDesign。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # Mod/PartDesign/InitGui.py class PartDesignWorkbench ( Workbench ): # 继承 PartDesignGui::Workbench \u0026#34;PartDesign workbench object\u0026#34; def __init__(self): self.__class__.Icon = FreeCAD.getResourceDir() + \u0026#34;Mod/PartDesign/Resources/icons/PartDesignWorkbench.svg\u0026#34; self.__class__.MenuText = \u0026#34;Part Design\u0026#34; self.__class__.ToolTip = \u0026#34;Part Design workbench\u0026#34; def Initialize(self): # load the module try: import traceback from PartDesign.WizardShaft import WizardShaft # 加载 shaftwizard 模块 except RuntimeError: print (\u0026#34;{}\u0026#34;.format(traceback.format_exc())) except ImportError: print(\u0026#34;Wizard shaft module cannot be loaded\u0026#34;) try: from FeatureHole import HoleGui except Exception: pass import PartDesignGui import PartDesign try: from PartDesign import InvoluteGearFeature # 加载 InvoluteGearFeature 模块 from PartDesign import SprocketFeature # 加载 SprocketFeature 模块 except ImportError: print(\u0026#34;Involute gear module cannot be loaded\u0026#34;) #try: # from FeatureHole import HoleGui #except: # pass def GetClassName(self): return \u0026#34;PartDesignGui::Workbench\u0026#34; Gui.addWorkbench(PartDesignWorkbench()) ","date":"2025-08-11T00:00:00Z","permalink":"https://zuoco.github.io/p/freecad07-%E5%B7%A5%E4%BD%9C%E5%8F%B0/","title":"FreeCAD（07）— 工作台"},{"content":"为了简化 C++ 与 Python 的互操作，PyCXX设计了 Object 类，使用 C++ 封装了 Python 对象（PyObject*）。\n整个库最核心的就是Object类，它的核心是封装了一个 PyObject* 指针，并管理其生命周期（引用计数）。\n通过 C++ 的 RAII 机制，确保 Python 对象在 C++ 作用域内安全地创建和销毁。\nPyCXX中的所有类型位于 Py 命名空间下：\nPy命名空间中的类型 功能 Py::Object PyCXX框架中的基类，它封装了一个 PyObject* 指针（p），并管理其生命周期（引用计数）。\n通过 C++ 的 RAII（资源获取即初始化）机制，确保 Python 对象在 C++ 作用域内安全地创建和销毁。 Py::PythonClass\u0026lt;T\u0026gt; 用于将一个 C++ 类型 （T） 封装为 Python 可识别的类对象，暴露 C++ 成员函数和属性给 Python Py::ExtensionModule\u0026lt;T\u0026gt; 用来定义Python模块，在构造时将模块注册到 Python 解释器中。 Py::List C++实现的Python序列类，存储序列对象（如列表/元组） Py::Tuple C++实现的Python元组 Py::Dict C++实现的Python字典 Py::Callable 使用C++封装的Python可调用对象 Py 命名空间下的函数：\nPy命名空间下的函数 void Py::_XINCREF( PyObject *op ); 增加PyObject的引用计数。 void Py::_XDECREF( PyObject *op ); 减少PyObject的引用计数，当引用计数减至0时，对象会被自动释放。这是CPython内部用于内存管理的核心机制。 bool operator==( const Object \u0026amp;o1, const Object \u0026amp;o2 );\nPy::Object对象比较, 同时也实现了 !=, \u0026gt;=, \u0026lt;=, \u0026lt;, \u0026gt; 1. Py::Object基类 在PyCXX中，所有类型的基类都是Py::Object派生类型，直接派生或者间接派生。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 namespace Py { class Object { private: PyObject *p; // 通过组合 PyObject* 实现对 Python 对象的封装 protected: void set( PyObject *pyob, bool owned = false ) // 设置 p { release(); // 先释放原先持有的 p p = pyob; if( !owned ) { Py::_XINCREF( p ); } validate(); } void release() // 释放 p { Py::_XDECREF( p ); p = NULL; } void validate(); // 于验证当前对象的类型是否与预期匹配 public: // 构造函数: 根据 owned 决定是否增加 pyob 的引用计数。 // owned: Object对象是否拥有 pyob。 explicit Object( PyObject *pyob=Py::_None(), bool owned = false ); Object( const Object \u0026amp;ob ); Object \u0026amp;operator=( const Object \u0026amp;rhs ); // 调用 set( rhs.p ); Object \u0026amp;operator=( PyObject *rhsp ) // 防止自赋值 // 析构函数: pyob 引用计数减1，并 p = NULL。 virtual ~Object() { release(); } PyObject *operator*() const; // 重载解引用，也就是返回 p void increment_reference_count(); // 调用Py_INCREF宏增加对象引用计数 void decrement_reference_count(); // 特殊处理引用计数减少，当引用计数为1时抛出异常（防止对象自我销毁），正常情况调用Py_DECREF宏减少引用计数 PyObject *ptr() const; // 直接返回 PyObject 对象指针 /* * 判断给定的Python对象是否可用于当前类, * 例如派生类型Py::Tuple重写了该函数，当Python对象为Py::Tuple时返回true */ virtual bool accepts( PyObject * ) const; Py_ssize_t reference_count() const; // 返回当前对象的引用计数 Type type() const; // 返回当前Python对象对应的类型对象，用于获取Python对象的类型信息等 String str() const; // 获取Python对象的字符串表示(Py::string)，例如： 字典 {\u0026#39;a\u0026#39;:1} -\u0026gt; \u0026#34;{\u0026#39;a\u0026#39;: 1}\u0026#34; std::string as_string() const; // 调用了str()，但是强制转换为std::string List dir() const; // 获取Python对象的属性名称列表并封装为C++的List对象返回 bool hasAttr( const std::string \u0026amp;s ) const; // 检查Python对象是否包含指定属性 Object getAttr( const std::string \u0026amp;s ) const; // 获取属性的值 void setAttr( const std::string \u0026amp;s, const Object \u0026amp;value ); void delAttr( const std::string \u0026amp;s ); // 函数调用，function_name就是函数名 Object callMemberFunction( const std::string \u0026amp;function_name ) const; // 调用无参函数 Object callMemberFunction( const std::string \u0026amp;function_name, const Tuple \u0026amp;args ) const; // 调用带有可变参的函数 Object callMemberFunction( const std::string \u0026amp;function_name, const Tuple \u0026amp;args, const Dict \u0026amp;kw ) const; // 调用带有可变参和关键字参数的函数 Object getItem( const Object \u0026amp;key ) const; // 键值访问，用于Python容器类型（如字典/列表） Py_hash_t hashValue() const; // 计算对象哈希值 bool is( PyObject *pother ) const; // return p == pother; bool is( const Object \u0026amp;other ) const; // return p == other.p; // 检测 p 是否为某个类型 bool isNull() const; bool isNone() const; bool isCallable() const; bool isDict() const; bool isList() const; bool isMapping() const; bool isNumeric() const; bool isSequence() const; bool isTrue() const; bool isTuple() const; bool isString() const; bool isBytes() const; bool isBoolean() const; bool isType( const Type \u0026amp;t ) const; // 当前对象的类型是否与参数t的类型完全相同 void delItem( const Object \u0026amp;key ); // 删除 p 中的键值对 }; } ","date":"2025-08-11T00:00:00Z","permalink":"https://zuoco.github.io/p/python%E7%9A%84c-%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%9101-pycxx%E4%B8%AD%E7%9A%84%E6%9C%89%E9%82%A3%E4%BA%9B%E7%B1%BB%E5%9E%8B/","title":"Python的C++扩展开发（01） - PyCxx中的有那些类型"},{"content":"先简单梳理一下，以后慢慢研究。\nFreeCAD的Python绑定机制 1. 基础架构：PyObjectBase FreeCAD中所有需要导出到Python的C++类都继承自PyObjectBase基类。这个基类提供了C++对象与Python对象之间的桥接功能，包含了Python对象头部结构和各种Python C API的包装方法。\n2. XML接口定义 FreeCAD使用XML文件来定义Python绑定的接口。例如，Mesh模块的Python绑定在MeshPy.xml中定义，其中指定了导出的类名、命名空间、继承关系和要导出的方法。\n3. 代码生成系统 FreeCAD使用模板系统自动从XML定义生成C++绑定代码。这个系统会生成必要的C++包装器代码，实现Python对象与C++对象之间的转换。\n4. Python模块注册 每个模块都实现一个继承自Py::ExtensionModule的类来创建Python模块。这个模块类注册了要导出的函数和方法。\n5. 模块初始化 通过PyMOD_INIT_FUNC宏定义的模块入口点函数，调用initModule()函数创建并注册模块到Python命名空间。最终通过Base::Interpreter().addModule()将扩展模块添加到Python环境中。\nPyObjectBase 类型 FreeCAD的Python绑定系统基于PyObjectBase基类，这是所有需要导出到Python命名空间的C++类的基础类。该类提供了Python对象的标准接口，包括属性访问、方法调用和生命周期管理。FreeCAD 中几乎所有关键类都需要在 Python 中可见，以便用于宏录制（macro recording）和自动化（automation）目的。\nPython绑定系统的基础代码位于PyObjectBase.h文件中，这篇文章就主要讲解该文件中的内容。\n1 2 3 4 5 6 class BaseExport PyObjectBase : public PyObject //NOLINT { Py_Header // 注入 Python 类型元信息 // ... 其他成员 ... }; PyObject实际上是struct _object，可以理解为所有Python对象的根类型。 Py_Header宏：\n1 2 3 4 5 #define Py_Header \\ public: \\ static PyTypeObject Type; \\ static PyMethodDef Methods[]; \\ virtual PyTypeObject *GetType(void) {return \u0026amp;Type;} 通过宏展开注入 Type 类型对象和 Methods 方法表使 PyObjectBase 子类在 Python 中表现为完整类型。\nType 是 Python 类型对象，使 C++ 类能在 Python 中表现为完整类型。 Methods 是 Python 方法表，通过 PyMethodDef 数组声明所有可导出方法。 为了简化从PyObjectBase类继承并定义导出到 Python 的新方法，FreeCAD还提供了一些便捷的宏（macro）：\nPYFUNCDEF_D 定义一个新的导出方法。 PYFUNCIMP_D 定义这个新导出方法的具体实现。在实现的时候，可以使用 Py_Return、Py_Error、Py_Try 和 Py_Assert 等宏。 PYMETHODEDEF 宏用于在 Python 方法表中创建对应的条目。 ","date":"2025-08-10T00:00:00Z","permalink":"https://zuoco.github.io/p/freecad06-python%E4%B8%8Ec-%E4%BA%92%E6%93%8D%E4%BD%9C/","title":"FreeCAD（06）— Python与C++互操作"},{"content":" 1. Python/C API接口 2. 使用 C/C++ 编写 Python 模块 3. 在C/C++代码中调用Python代码 3.1. 导入模块中的函数 3.2. 导入模块中的类 1. Python/C API接口 Python/C API 是 Python 官方提供的 C 语言接口，允许 C/C++ 程序与 Python 解释器交互，CPython就是这套接口的实现。 这套接口有两种用法：\n在Python代码中调用使用C/C++编写扩展模块： 把性能关键或系统级代码写成 C/C++ 函数，编译成共享库（.so / .pyd），在 Python 里像普通模块一样 import。 在C/C++代码中调用Python代码： 在 C 代码里启动 Python 虚拟机、执行 Python 脚本、调用 Python 函数、使用 Python 对象，从而直接复用现成的 Python 生态。 以CPython为例记录一下这两种用法。\n2. 使用 C/C++ 编写 Python 模块 将C/C++与Python集成有两种主要开发模式：\n将C/C++函数公开为Python模块函数。 从C++类创建新的Python类。 这里展示使用CPython将C函数公开为Python模块函数：\n1. 编写C函数 mymodule.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;Python.h\u0026gt; // 定义函数 static PyObject* add(PyObject* self, PyObject* args) { int a, b; if (!PyArg_ParseTuple(args, \u0026#34;ii\u0026#34;, \u0026amp;a, \u0026amp;b)) return NULL; return PyLong_FromLong(a + b); } //2. 定义方法表 static PyMethodDef module_methods[] = { {\u0026#34;add\u0026#34;, add, METH_VARARGS, \u0026#34;Add two integers\u0026#34;}, {NULL, NULL, 0, NULL} }; //3. 定义模块结构 static struct PyModuleDef mymodule = { PyModuleDef_HEAD_INIT, \u0026#34;mymodule\u0026#34;, \u0026#34;Example module that adds two numbers\u0026#34;, -1, module_methods }; // 4. 模块初始化 PyMODINIT_FUNC PyInit_mymodule(void) { return PyModule_Create(\u0026amp;mymodule); } 2. 构建脚本 setup.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 from setuptools import setup, Extension ext = Extension( \u0026#39;mymodule\u0026#39;, sources=[\u0026#39;mymodule.c\u0026#39;] ) setup( name=\u0026#39;mymodule\u0026#39;, version=\u0026#39;1.0\u0026#39;, description=\u0026#39;CPython extension example\u0026#39;, ext_modules=[ext] ) 3. 编译\n1 2 3 4 5 6 7 8 zci@Gem:~/000$ python3 setup.py build_ext --inplace zci@Gem:~/000$ zci@Gem:~/000$ tree -L 1 . ├── build ├── mymodule.c ├── mymodule.cpython-312-x86_64-linux-gnu.so # 编译成的动态库 └── setup.py 4. 使用模块 test.py\n1 2 3 import mymodule result = mymodule.add(3, 5) print(result) # 输出: 8 3. 在C/C++代码中调用Python代码 分为三步：\n1 2 3 4 5 6 7 8 9 10 // 1. 初始化Python解释器 void Py_Initialize(); int Py_IsInitialized(); // 解析器的是否已经初始化完成，完成返回大于0，否则返回0。 // 2. 执行Python代码 // 3. 释放解释器资源 void Py_Finalize(); 3.1. 导入模块中的函数 接下来细说第2步： 从Python脚本文件中导入模块，并执行模块中的函数： 1. 添加 Python 脚本路径到 sys.path。\n1 PyRun_SimpleString(\u0026#34;import sys\\nsys.path.append(\u0026#39;path/to/_script\u0026#39;)\u0026#34;); 2. 导入 Python 模块: 使用 PyImport_ImportModule 导入模块。\n1 2 3 4 5 PyObject* pModule = PyImport_ImportModule(\u0026#34;mymodule\u0026#34;); // mymodule.py if (!pModule) { PyErr_Print(); // 打印错误信息 return -1; // 处理错误 } 3. 获取模块中的函数对象: 通过 PyObject_GetAttrString 获取模块中的函数对象，PyObject_GetAttrString() 会增加返回对象的引用计数。\n1 2 3 4 5 6 7 8 9 10 // 获取模块中的my_function函数。 PyObject* pFunc = PyObject_GetAttrString(pModule, \u0026#34;my_function\u0026#34;); // 检查 pFunc 是否为可调用对象（函数、方法、类等） if (!pFunc || !PyCallable_Check(pFunc)) { PyErr_Print(); Py_XDECREF(pFunc); // 释放 pFunc 的引用计数 Py_DECREF(pModule); // 释放模块对象 pModule 的引用计数 return -1; } 4. 准备参数并调用函数： 根据函数的参数类型，使用 Py_BuildValue 构造参数，并通过 PyObject_CallObject 调用函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 例如 my_function 函数接受一个整数参数 // \u0026#34;(i)\u0026#34;： 元组： (i，)。 PyObject* pArgs = Py_BuildValue(\u0026#34;(i)\u0026#34;, 42); // 构建 Python 参数对象，参数为 42 PyObject* pResult = PyObject_CallObject(pFunc, pArgs); if (!pResult) { PyErr_Print(); } else { // 处理返回值，例如返回值是一个整数 if (PyLong_Check(pResult)) // 检查一下给定的 pResult 对象是否是 PyLongObject（Python 整数对象）或其子类型 { int result = PyLong_AsLong(pResult); // 将 Python 的整数对象（PyLongObject）转换为 C/C++ 的 long 类型。 std::cout \u0026lt;\u0026lt; \u0026#34;Python function returned: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } } // Py_BuildValue、PyObject_CallObject 都会增加返回对象的引用计数。 Py_XDECREF(pResult); Py_DECREF(pArgs); 5. 释放资源\n1 2 Py_XDECREF(pFunc); Py_DECREF(pModule); 3.2. 导入模块中的类 myclass.py 如下：\n1 2 3 4 5 6 7 8 class MyClass: def __init__(self, value): self.value = value def get_value(self): return self.value # 其他 ... 导入类型用的还是PyObject_GetAttrString(), 创建实例用的是也是PyObject_CallObject()。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;Python.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { Py_Initialize(); PyRun_SimpleString(\u0026#34;import sys\\nsys.path.append(\u0026#39;./\u0026#39;)\u0026#34;); PyObject* pModule = PyImport_ImportModule(\u0026#34;myclass\u0026#34;); if (!pModule) { PyErr_Print(); return -1; } // 1. 获取类对象， 这个 pClass 是类对象本身（type 对象），不是类的实例 PyObject* pClass = PyObject_GetAttrString(pModule, \u0026#34;MyClass\u0026#34;); if (!pClass || !PyType_Check(pClass)) { PyErr_Print(); std::cerr \u0026lt;\u0026lt; \u0026#34;MyClass not found or is not a class.\u0026#34; \u0026lt;\u0026lt; std::endl; Py_XDECREF(pClass); Py_DECREF(pModule); Py_Finalize(); return -1; } // 2. 创建类实例（调用构造函数） PyObject* pArgs = Py_BuildValue(\u0026#34;(i)\u0026#34;, 100); // 构造函数参数：(100,) PyObject* pInstance = PyObject_CallObject(pClass, pArgs); // 创建实例 if (!pInstance) { PyErr_Print(); std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to create instance of MyClass.\u0026#34; \u0026lt;\u0026lt; std::endl; Py_DECREF(pArgs); Py_DECREF(pClass); Py_DECREF(pModule); Py_Finalize(); return -1; } // 3. 调用实例方法 PyObject* pGetValueFunc = PyObject_GetAttrString(pInstance, \u0026#34;get_value\u0026#34;); // 获取 get_value() 方法 if (pGetValueFunc \u0026amp;\u0026amp; PyCallable_Check(pGetValueFunc)) { // 调用函数 PyObject* pResult = PyObject_CallObject(pGetValueFunc, nullptr); if (pResult) { if (PyLong_Check(pResult)) { long value = PyLong_AsLong(pResult); // 获取函数返回 std::cout \u0026lt;\u0026lt; \u0026#34;get_value() returned: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } Py_DECREF(pResult); } else { PyErr_Print(); } Py_DECREF(pGetValueFunc); } // 4. 清理资源 Py_DECREF(pArgs); Py_DECREF(pInstance); Py_DECREF(pClass); Py_DECREF(pModule); Py_Finalize(); return 0; } ","date":"2025-08-10T00:00:00Z","permalink":"https://zuoco.github.io/p/python%E7%9A%84c/c-%E7%BB%91%E5%AE%9A/","title":"Python的C/C++绑定"},{"content":" src/Main/MainCmd.cpp CLI版本的入口程序 src/Main/MainGui.cpp GUI版本的入口程序 src/Main/MainPy.cpp Python模块（FreeCAD）的初始化函数，负责在Python环境中加载FreeCAD核心功能 src/Main/FreeCADGuiPy.cpp Python模块（FreeCADGui）的初始化函数，负责在Python环境中加载FreeCADGui核心功能 1. Python模块初始化 2. FreeCAD模块初始化 3. FreeCADGui模块初始化 1. Python模块初始化 FreeCAD定义了宏——PyMOD_INIT_FUNC来辅助实现Python模块的初始化函数:\n1 #define PyMOD_INIT_FUNC(name) PyMODINIT_FUNC PyInit_##name(void) 这里的PyMODINIT_FUNC其实是 Python/C API 库中的一个宏，在 Python 3 中，PyMODINIT_FUNC 就是 PyObject*，表示函数返回值。\nPyInit_xxx(void)，就是模块的初始化函数，它在import模块时执行，并返回一个Python模块对象。\n2. FreeCAD模块初始化 FreeCAD模块初始化函数定义在MainPy.cpp中：\n1 2 3 4 5 6 7 8 PyMOD_INIT_FUNC(FreeCAD) { // ...... // 这个函数负责Python模块的初始化。 // ...... return module; // 返回模块对象 } 这个宏（PyMOD_INIT_FUNC）展开就是：\n1 2 3 4 5 6 PyObject* PyInit_FreeCAD(void) { // ...... return module; // 返回一个 PyObject* 类型的对象 } 我们复制 “PyMOD_INIT_FUNC(” 到FreeCAD工程源码中搜索，就能看到都有那些模块。\n3. FreeCADGui模块初始化 加载FreeCADGui模块时会先加载FreeCAD模块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // FreeCADGuiPy.cpp PyMOD_INIT_FUNC(FreeCADGui) { try { Base::Interpreter().loadModule(\u0026#34;FreeCAD\u0026#34;); // 加载FreeCAD模块， Base::Interpreter()返回 Python 解释器单例 App::Application::Config()[\u0026#34;AppIcon\u0026#34;] = \u0026#34;freecad\u0026#34;; App::Application::Config()[\u0026#34;SplashScreen\u0026#34;] = \u0026#34;freecadsplash\u0026#34;; App::Application::Config()[\u0026#34;CopyrightInfo\u0026#34;] = \u0026#34;\\xc2\\xa9 Juergen Riegel, Werner Mayer, Yorik van Havre and others 2001-2024\\n\u0026#34;; App::Application::Config()[\u0026#34;LicenseInfo\u0026#34;] = \u0026#34;FreeCAD is free and open-source software licensed under the terms of LGPL2+ license.\\n\u0026#34;; App::Application::Config()[\u0026#34;CreditsInfo\u0026#34;] = \u0026#34;FreeCAD wouldn\u0026#39;t be possible without FreeCAD community.\\n\u0026#34;; if (Base::Type::fromName(\u0026#34;Gui::BaseView\u0026#34;).isBad()) { Gui::Application::initApplication(); } static struct PyModuleDef FreeCADGuiModuleDef = {PyModuleDef_HEAD_INIT, // 这个参数是固定的。 \u0026#34;FreeCADGui\u0026#34;, // 模块名称 \u0026#34;FreeCAD GUI module\\n\u0026#34;, // 模块的描述 -1, // 模块实例的大小（-1 表示动态分配） FreeCADGui_methods, // 模块导出的方法表 nullptr, nullptr, nullptr, nullptr}; PyObject* module = PyModule_Create(\u0026amp;FreeCADGuiModuleDef); // 创建模块对象 return module; } catch (const Base::Exception\u0026amp; e) { PyErr_Format(PyExc_ImportError, \u0026#34;%s\\n\u0026#34;, e.what()); } catch (...) { PyErr_SetString(PyExc_ImportError, \u0026#34;Unknown runtime error occurred\u0026#34;); } return nullptr; } 上面代码中涉及到一个struct PyModuleDeff结构体类型， 这是定义 Python 模块的核心结构体。它描述了模块的基本信息、方法、资源管理等。\n1 2 3 4 5 6 7 8 9 10 11 struct PyModuleDef { PyModuleDef_Base m_base; // 这个参数是固定的,就是PyModuleDef_HEAD_INIT const char* m_name; // 模块名称 const char* m_doc; // 模块文档字符串 Py_ssize_t m_size; // 模块实例的大小（-1 表示动态分配） PyMethodDef *m_methods; // 模块导出的方法表 PyModuleDef_Slot *m_slots; // 模块的插槽（slots） traverseproc m_traverse; // 遍历函数（垃圾回收） inquiry m_clear; // 清理函数（垃圾回收） freefunc m_free; // 释放函数 }; 这里面需要注意的是PyMethodDef m_methods成员，这是模块的方法列表，PyMethodDef结构的原型是：\n1 2 3 4 5 6 7 struct PyMethodDef { const char *ml_name; // 定义该方法在 Python 中的名称（即用户调用时使用的函数名）。 PyCFunction ml_meth; // 指向实现该方法的 C 函数指针。 int ml_flags; // 标志位组合，描述该方法的参数规则和行为。 const char *ml_doc; // 方法的描述 }; FreeCADGui的模块方法列表如下（m_methods参数），包含5个核心GUI操作方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct PyMethodDef FreeCADGui_methods[] = { // 创建并显示主窗口 {\u0026#34;showMainWindow\u0026#34;, FreeCADGui_showMainWindow, METH_VARARGS, \u0026#34;showMainWindow() -- Show the main window\\n\u0026#34; \u0026#34;If no main window does exist one gets created\u0026#34;}, // 启动GUI事件循环 {\u0026#34;exec_loop\u0026#34;, FreeCADGui_exec_loop, METH_VARARGS, \u0026#34;exec_loop() -- Starts the event loop\\n\u0026#34; \u0026#34;Note: this will block the call until the event loop has terminated\u0026#34;}, // 设置非GUI模式 {\u0026#34;setupWithoutGUI\u0026#34;, FreeCADGui_setupWithoutGUI, METH_VARARGS, \u0026#34;setupWithoutGUI() -- Uses this module without starting\\n\u0026#34; \u0026#34;an event loop or showing up any GUI\\n\u0026#34;}, {\u0026#34;embedToWindow\u0026#34;, FreeCADGui_embedToWindow, METH_VARARGS, \u0026#34;embedToWindow() -- Embeds the main window into another window\\n\u0026#34;}, {nullptr, nullptr, 0, nullptr} /* sentinel */ }; ","date":"2025-08-09T00:00:00Z","permalink":"https://zuoco.github.io/p/freecad05-python%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96/","title":"FreeCAD（05） — Python模块初始化"},{"content":" 6月17号，Kimi发布了一款新编程模型——Kimi-Dev，在SWE-bench Verified上，以60.4的成绩获得了开源Sota，仅次于Gemini 2.5 Pro和Claude了，模型仅有72B参数，该模型的设计中包含了两个对抗角色： BugFixer和TesWriter，其中BugFixer职业解决Bug， TesWriter专门编写测试用例，用于测试。这两个模块都是基于共同的最小框架，包含两个阶段，File Localization和Code Edits，就是先定位要修改的文件，然后修改代码中的Bug，kimi团队收集了Github上的大量Issue和Pull Request，基于这些内容学习推理与解决额问题。\n看起来这款新模型是一种“Agent”的思路，在底层模型不占优势的情况下，通过Agent的思路来提升模型的使用性能，这应该是Kimi团队在产品路线上的调整。自从Depseek R1发布之后， 国内AI圈子的流量都在DeepSeek和千问上，Kimi一直沉寂，实际上大模型基础建设只适合资本大户来做，对于中小企业更适合在模型之上提供服务，对于模型进行优化，提供特定场景下的创新与性能。\n","date":"2025-06-19T00:00:00Z","permalink":"https://zuoco.github.io/p/kimi-dev/","title":"Kimi-Dev"},{"content":" 1. 异常类型基类 2. 抛出异常 3. 派生的异常类型 1. 异常类型基类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 namespace Base { class BaseExport Exception: public BaseClass { TYPESYSTEM_HEADER_WITH_OVERRIDE(); // 类型系统 public: ~Exception() noexcept override = default; virtual const char* what() const noexcept; // 获取_sErrMsg成员 virtual void ReportException() const; // 报告异常信息，用于记录日志、显示错误提示或调试信息。 /* 设置/获取异常信息 */ inline void setMessage(const char* sMessage); // 将sMessage赋值给内部成员_sErrMsg inline void setMessage(const std::string\u0026amp; sMessage); inline std::string getMessage() const; inline std::string getFile() const; // _file inline int getLine() const; // _line inline std::string getFunction() const; // _function inline void setDebugInformation(const std::string\u0026amp; file, int line, const std::string\u0026amp; function); // 设置异常的调试上下文信息（_line、_file、_function） inline bool getReported() const { return _isReported; // 返回异常是否已经被报告过（即是否已经通过某种方式输出或记录） } inline void setReported(bool reported) { _isReported = reported; // 设置异常的报告状态，标记异常是否已处理。 } protected: explicit Exception(const char* sMessage); explicit Exception(std::string sMessage); Exception(); Exception(const Exception\u0026amp; inst); Exception(Exception\u0026amp;\u0026amp; inst) noexcept; protected: /* 异常相关的上下文信息 */ std::string _sErrMsg; std::string _file; int _line; std::string _function; mutable bool _isReported; // 异常是否已报告 }; } 2. 抛出异常 提供了三个版本的throw函数，不同平台上实现有细微的不同。\n1 2 3 #define THROW(exception); #define THROWM(exception, message) #define THROWMF_FILEEXCEPTION(message, filenameorfileinfo) // 携带一些信息 3. 派生的异常类型 AbortException 中断异常，继承自Exception XMLBaseException XML异常基础类型，继承自Exception XMLParseException XML文档解析出错，继承自XMLBaseException XMLAttributeError XML属性异常，请求的XML属性不存在时抛出异常，继承自XMLBaseException FileException 文件IO异常类型，继承自Exception FileSystemError 文件系统操作错误的异常类，继承自Exception MemoryException 内存异常 BadGraphError 图异常，不是有向无环图 UtilsMismatchError 单位异常 CADKernelError 内核（OCC）异常 异常类型非常多，就不一一列举了。\n","date":"2025-06-14T00:00:00Z","permalink":"https://zuoco.github.io/p/freecad04-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/","title":"FreeCAD（04） — 异常类型"},{"content":" 1. 项目概述 2. 项目组成 2.1. 核心模块架构 2.2. 项目目录结构 3. 核心功能 4. 双重实现架构 1. 项目概述 Open3D是一个用于3D数据处理的现代开源库，Open3D前端公开了一组精心选择的数据结构和算法，支持C++和Python两种接口。后端经过高度优化，并设置了并行化支持。Open3D还提供了一个独立的3D查看器应用程序，可在Debian(Ubuntu)、macOS和Windows上运行。\n2. 项目组成 2.1. 核心模块架构 Open3D项目主要由以下核心模块组成：\ncamera - 相机相关功能 core - 核心功能模块 data - 数据处理模块 geometry - 几何处理模块 io - 输入输出模块 ml - 机器学习模块 pipelines - 算法管道模块 t/geometry - 张量几何模块 t/io - 张量输入输出模块 t/pipelines - 张量管道模块 utility - 实用工具模块 visualization - 可视化模块 2.2. 项目目录结构 项目的主要目录结构包括：\ncpp/ - C++核心实现 python/ - Python接口实现 docs/ - 项目文档 3rdparty/ - 第三方依赖库 cmake/ - CMake构建配置 docker/ - Docker配置 util/ - 实用工具脚本 3. 核心功能 Open3D的核心功能包括：\n3D数据结构 - 支持各种3D数据格式 3D数据处理算法 - 提供完整的3D数据处理工具链 场景重建 - 支持3D场景重建功能 表面对齐 - 实现表面配准算法 3D可视化 - 强大的3D可视化功能 物理渲染(PBR) - 支持基于物理的渲染 机器学习支持 - 集成PyTorch和TensorFlow GPU加速 - 为核心3D操作提供GPU加速 跨语言支持 - 提供C++和Python接口 4. 双重实现架构 Open3D采用双重实现架构，提供传统实现和张量实现：\n传统实现：geometry、io、pipelines 张量实现：t/geometry、t/io、t/pipelines 安装 从pipy源安安装：\n1 pip install open3d 下载安装：\n1 pip install open3d-0.19.0-cp312-cp312-manylinux_2_31_x86_64.whl ","date":"2025-06-07T00:00:00Z","permalink":"https://zuoco.github.io/p/open3d%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/","title":"Open3D介绍与安装"},{"content":" 1. 类型系统 2. 根类型 — BaseClass 3. 关键宏 1. 类型系统 src/base/type.h文件中提供了类型信息、类型注册的功能，通过类名来创建对象，看起来是个工厂。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 namespace Base { struct TypeData; class BaseExport Type { public: Type(const Type\u0026amp; type) = default; Type(Type\u0026amp;\u0026amp; type) = default; Type() = default; ~Type() = default; // 一堆成员函数 ... void* createInstance(); // 创建对象，根据index查找typedata，使用typedata中的函数创建对象。 static void* createInstanceByName(const char* TypeName, bool bLoadModule = false); // 根据提供的typename创建对象，内部调用了createInstance() // 创建一个类型，需要传入父类型 static Type createType(const Type\u0026amp; parent, const char* name, instantiationMethod method = nullptr); private: unsigned int index {0}; // typedata的索引 static std::map\u0026lt;std::string, unsigned int\u0026gt; typemap; // \u0026lt;类名称, 类型值\u0026gt; static std::vector\u0026lt;TypeData*\u0026gt; typedata; // typedata 列表 static std::set\u0026lt;std::string\u0026gt; loadModuleSet; // 模块集合 }; } TypeData类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Base::TypeData { TypeData(const char* theName, const Type type = Type::badType(), const Type theParent = Type::badType(), Type::instantiationMethod method = nullptr) : name(theName) , parent(theParent) , type(type) , instMethod(method) {} std::string name; // 类型名称 Type parent; // 父类的类型 Type type; // 类型值，对于与name Type::instantiationMethod instMethod; // 一个函数，用于创建对象 }; 2. 根类型 — BaseClass src/Base/BaseClass.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 namespace Base { namespace Base { class BaseExport BaseClass { public: /* 获取类型的Type值 */ static Type getClassTypeId(); virtual Type getTypeId() const; // 获取子类自己的类型Type，用于多态场景下 /* 是否派生于某个类型 */ bool isDerivedFrom(const Type type) const { return getTypeId().isDerivedFrom(type); } template\u0026lt;typename T\u0026gt; bool isDerivedFrom() const { return getTypeId().isDerivedFrom(T::getClassTypeId()); } /* 注册根类型到类型系统中，里面调用了Type::createType（） */ static void init(); /* 与Python的交互接口，用于支持脚本操作 */ virtual PyObject* getPyObject(); virtual void setPyObject(PyObject*); /* 创建对象，根类型中，该函数返回空 */ static void* create() { return nullptr; } /* 当前对象是否为T类型 */ template\u0026lt;typename T\u0026gt; bool is() const { return getTypeId() == T::getClassTypeId(); } private: static Type classTypeId; // getClassTypeId()获取到的就是这个玩意儿 protected: /* 注册新类型到类型系统，里面调用了Type::createType（） */ static void initSubclass(Base::Type\u0026amp; toInit, // 这是用于保存返回值，就是Type::createType（）的返回值 const char* ClassName, const char* ParentName, Type::instantiationMethod method = nullptr); public: BaseClass(); BaseClass(const BaseClass\u0026amp;) = default; BaseClass(BaseClass\u0026amp;\u0026amp;) = default; virtual ~BaseClass(); }; } 3. 关键宏 src/Base/BaseClass.h\n我们在创建子类型时，需要添加一些宏函数，这些宏简化了子类对 Base::BaseClass 的继承，思路类似于Qt中的QObject宏，自动处理：\n类型标识（getClassTypeId / getTypeId） 动态创建（create 方法） 类型注册（通过 initSubclass） 1 2 3 4 5 6 7 8 9 10 // 类型定义时使用 #define TYPESYSTEM_HEADER_WITH_OVERRIDE() \\ public: \\ static Base::Type getClassTypeId(void); \\ Base::Type getTypeId(void) const override; \\ static void init(void); \\ static void* create(void); \\ \\ private: \\ static Base::Type classTypeId 用途：在子类头文件使用该宏来声明类型系统所需的方法和静态成员。\n关键成员：\ngetClassTypeId()：返回类的静态类型标识。 getTypeId()：虚函数，返回实例的运行时类型标识。 init()：初始化类型（注册到 Type 系统）。 create()：创建实例的工厂方法。 classTypeId：类的静态类型标识（由 Type 类管理）。 还有一个TYPESYSTEM_HEADER宏，这是老的版本，功能是一样的，只是TYPESYSTEM_HEADER没有使用“override”来显式重写父类虚函数，可能是为了兼容98版本。\n上面是定义，当然也提供了用于实现的宏，并且给了多个版本：\nTYPESYSTEM_SOURCE_P: 普通可实例化的类（非模板、非抽象）。 TYPESYSTEM_SOURCE_TEMPLATE_P(_class_): 模板类（如 MyTemplateClass）。 TYPESYSTEM_SOURCE_ABSTRACT_P(_class_): 抽象类（不可实例化）。 上面三个宏没有实现initSubclass方法，所以又提供了三个宏(基于上面的宏)，用于实现initSubclass方法：\nTYPESYSTEM_SOURCE(_class_, _parentclass_) TYPESYSTEM_SOURCE_TEMPLATE_T(_class_, _parentclass_) TYPESYSTEM_SOURCE_ABSTRACT(_class_, _parentclass_) ","date":"2025-06-02T00:00:00Z","permalink":"https://zuoco.github.io/p/freecad03-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%A0%B9%E7%B1%BB%E5%9E%8Bbase%E6%A8%A1%E5%9D%97/","title":"FreeCAD（03） — 类型系统与根类型（Base模块）"},{"content":"代码目录结构 1 2 3 4 5 6 7 8 9 10 11 . └── freecad ├── src # 源码 ├── tools ├── tests ├── cMake ├── conda ├── contrib ├── data # 示例 ├── CMakeLists.txt └── 其他 src源码目录，其中App、Base、Main组成提个无UI运行程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ├── src │ ├── 3rdParty # 三方库，K维树、网格等等。 │ ├── App # 非界面代码，Document、Property、DocumentObject，支持Python。 │ ├── Base # 底层基础类型。 │ ├── Build # 编译时的版本信息 │ ├── CXX # 对于PyCXX的修改,便于Python脚本调用C++代码。 │ ├── Doc # 生成手册文档 │ ├── Gui # 界面 │ ├── MacAppBundle # Mac安装包配置文件 │ ├── Main # 程序入口，包括CLI和GUI两个入口程序 │ ├── Mod # 模块，CAM、工程图、有限元等等模块 │ ├── Tools │ ├── XDGData # Linux桌面相关文件 │ ├── zipios++ # 压缩文件读写 │ ├── CMakeLists.txt │ └── 其他 Base目录下是FreeCAD的类型系统，接口类，抽象类等等。\nApp目录下是属性系统，文档对象相关的代码。\nMain目录下就是不同模式的main函数了。\n源码中Mod目录下的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 src/Mod/ ├── Part # 创建基础的3D元素，圆柱、立方体等等 ├── OpenSCAD # 建模 ├── PartDesign # 零件设计 ├── CAM # 工艺，数控 ├── Draft # 2D草图 ├── Drawing # 工程图 ├── Sketcher # ├── Assembly # 装配图 ├── Fem # 有限元 ├── Material # 材料属性 ├── Mesh # 网格化 ├── MeshPart ├── Points # 点云 ├── ReverseEngineering # 从点云创建实体 ├── Robot # 机器人 └── 其他 ","date":"2025-06-01T00:00:00Z","permalink":"https://zuoco.github.io/p/freecad02-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/","title":"FreeCAD（02） — 代码结构"},{"content":" 1. 简单介绍 2. Linux 2.1. 安装依赖 2.2. 编译 3. Windows 3.1. 安装MSVC编译环境 3.2. 下载源码 3.3. 安装依赖包 Freecad-libpack 3.4. 编译 1. 简单介绍 FreeCAD的架构是基于工作台系统（Workbench）的，工作台是针对特定的设计任务而组建的，每个工作台都包含一系列专门的工具这是一种模块化设计，例如CAD、CAM、CAE。看起来和solidworks差不多。\n关键依赖库：\n几何内核： OpenCASCADE(OCC)。 3D渲染： OpenInventor、Coin3D、Pivy。 Python脚本工具： PyCXX、Swig、Boost.python。脚本引擎和模块扩展支持，在命令模式支持Python脚本驱动，GUI模式下支持Python脚本宏录制。。 UI： Qt、PySide。 主要工作台:\nPart工作台：基础几何建模。 PartDesign工作台：参数化特征建模。 Sketcher工作台：2D草图绘制。 TechDraw工作台：技术制图。 FEM工作台：有限元分析。 2. Linux 2.1. 安装依赖 依赖于Qt、Pyside6、python3，这三个库的版本要匹配，而Ubuntu24软件源中的Python版本为3.12，但是PySide6目前不支持这个版本，所以需要先安装python3.10或者3.11，并将/usr/bin/python链接到/usr/local/bin/python3.10。\n安装好python3.10后，参考这个链接FreeCAD的依赖库安装其他依赖库。\n2.2. 编译 1. 获取源码 下载FreeCAD的源码仓库，查看.gitmodules文件，按照文件指示下载子模块代码。\n2. 编译\n1 2 3 4 mkdir build cd build cmake .. make -j16 3. 运行\n3. Windows 3.1. 安装MSVC编译环境 不安装visual studio，我们只需要MSVC编译套件，直接下载Visual Studio 2022 生成工具：\n在 “工作负载” 选项卡中，勾选 “使用 C++ 的桌面开发”。 勾选 “MSVC v143 - VS 2022 C++ x64/x86 生成工具”（最新版本）。 勾选 Windows 10/11 SDK（根据系统版本选择）。 例如我安装到： C:\\app\\Microsoft Visual Studio\\Build Tools\\VC\\Tools\\MSVC\\14.44.35207\\bin\\Hostx64\\x64，然后将该目录添加到环境变量中。\n3.2. 下载源码 1 git clone --recurse-submodules https://github.com/FreeCAD/FreeCAD.git 这样会下载整个仓库的所有版本，体积较大，也可以到freecad的github仓库下载指定的版本，但是freecad源码不包含子模块，需要单独下载子模块，具体见文件“.gitmodules”。\n3.3. 安装依赖包 Freecad-libpack 到Freecad-libpack Github仓库下载并解压到指定目录，例如： C:\\Users\\zci\\Desktop\\Code\\FreeCAD\\LibPack-1.1.0-v3.1.1.3-Release，然后在FreeCAD源码的cmake文件中设置环境变量，如此下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ## == Win32 is default behaviour use the LibPack copied in Source tree ========== if(MSVC) option(FREECAD_RELEASE_PDB \u0026#34;Create PDB files for Release version.\u0026#34; ON) option(FREECAD_RELEASE_SEH \u0026#34;Enable Structured Exception Handling for Release version.\u0026#34; ON) option(FREECAD_LIBPACK_USE \u0026#34;Use the LibPack to Build FreeCAD (only Win32 so far).\u0026#34; ON) option(FREECAD_USE_PCH \u0026#34;Activate precompiled headers where it\u0026#39;s used.\u0026#34; ON) ## libpack的环境变量 set(ENV{FREECAD_LIBPACK_DIR},\u0026#34;C:/Users/zci/Desktop/Code/FreeCAD/LibPack-1.1.0-v3.1.1.3-Release\u0026#34;) if (DEFINED ENV{FREECAD_LIBPACK_DIR}) set(FREECAD_LIBPACK_DIR $ENV{FREECAD_LIBPACK_DIR} CACHE PATH \u0026#34;Directory of the FreeCAD LibPack\u0026#34;) message(STATUS \u0026#34;Found libpack env variable: ${FREECAD_LIBPACK_DIR}\u0026#34;) else() set(FREECAD_LIBPACK_DIR ${CMAKE_SOURCE_DIR} CACHE PATH \u0026#34;Directory of the FreeCAD LibPack\u0026#34;) endif() 3.4. 编译 1 2 3 4 5 mkdir __BUILD cd __BUILD cmake .. cmake --build C:/Users/zci/Desktop/Code/FreeCAD/FreeCAD-1.0.1/__BUILD --parallel -j16 --config Release 编译完成后还不能直接运行，因为一堆动态库不在环境变量中，可以添加环境变量，也可以将动态库都拷贝到freecad.exe目录下。\n","date":"2025-05-25T00:00:00Z","permalink":"https://zuoco.github.io/p/freecad01-%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%AF%91/","title":"FreeCAD（01） — 介绍以及编译"},{"content":"1. 什么是OOM 在内存不足时，内存管理系统会回收内核中可以释放的内存，当实在没有内存可用的时候，就会进入OOM（Out of Memory）状态，内存管理系统会执行OOM Killer，依据一定的规则杀死一些进程来释放内存，对于个人PC来说，这都不是事儿，但对于服务器，有可能就会将重要的业务进程给干死了，所以有的服务器会将sysctl的vm.panic_on_omc参数设为1，当发生OOM时强制关闭系统，如果设置为0(默认)，在OOM时就会运行OOM Killer。\n1 dmesg | grep -i \u0026#34;out of memory\u0026#34; # 查看OOM事件 2. OOM Killer机制 OOM Killer机制依靠两个因素选择要杀的进程，oom_score和oom_score_adj，其中oom_score是内核通过进程的内存消耗计算出来的，oom_score_adj（取值-1000 ~ 1000）是用户用来干预oom的（用户权重），内核会向oom_score + oom_score_adj值最高的进程发送关闭信号。\n2.1. oom Killer代码 内核代码：linux-6.14.6/mm/oom_kill.c\nOOM杀手算法的评分机制: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 long oom_badness(struct task_struct *p, unsigned long totalpages) { long points; long adj; // 1. 排除不可杀进程 if (oom_unkillable_task(p)) return LONG_MIN; p = find_lock_task_mm(p); if (!p) return LONG_MIN; // 2. 获取用户权重，并判断该进程是否可杀 adj = (long)p-\u0026gt;signal-\u0026gt;oom_score_adj; if (adj == OOM_SCORE_ADJ_MIN || test_bit(MMF_OOM_SKIP, \u0026amp;p-\u0026gt;mm-\u0026gt;flags) || in_vfork(p)) { task_unlock(p); return LONG_MIN; } // 3. 基础评分 = 物理内存 + 交换分区 + 页表内存 points = get_mm_rss(p-\u0026gt;mm) + get_mm_counter(p-\u0026gt;mm, MM_SWAPENTS) + mm_pgtables_bytes(p-\u0026gt;mm) / PAGE_SIZE; task_unlock(p); // 4. 归一化调整值 = OOM评分调整值 * 总内存/1000 adj *= totalpages / 1000; // 5. 最终评分 points += adj; return points; } 查找oom最大的进程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 static void select_bad_process(struct oom_control *oc) { oc-\u0026gt;chosen_points = LONG_MIN; if (is_memcg_oom(oc)) mem_cgroup_scan_tasks(oc-\u0026gt;memcg, oom_evaluate_task, oc); else { struct task_struct *p; rcu_read_lock(); // 否则遍历系统所有进程，通过oom_evaluate_task评估每个进程，若返回true则立即停止遍历（找到候选进程） for_each_process(p) if (oom_evaluate_task(p, oc)) break; rcu_read_unlock(); } } 杀死进程 1 2 3 4 static void oom_kill_process(struct task_struct *victim, const char *message) { // 杀死进程，太多了，就不放了 } 3. /proc/sys/vm/oom_kill_allocating_task 写入1表示优先杀死导致内存不足的任务，而不是选择评分最高的任务。\n","date":"2025-05-21T20:53:24+08:00","permalink":"https://zuoco.github.io/p/%E5%86%85%E6%A0%B8oom%E6%9C%BA%E5%88%B6/","title":"内核OOM机制"},{"content":" 1. 认识模型的输入输出 2. 微调数据集 2.1. 一般数据集 3. 训练Function calling能力的数据集 3.1. Tool Schema 数据集的核心作用 3.2. Tool Schema 数据集格式 4. 带有思考过程的数据集 5. 带有思考过程、Function calling的数据集 1. 认识模型的输入输出 从模型底层原理看，大模型会使用一些特殊字符来标记用户的不同类型输入、系统提示词、以及工具调用或者多模态输入等。以Qwen3为例，在一次实际的对话过程中，模型的真实输入和输出如下所示： 上图中 \u0026lt;|im_start|\u0026gt; 代表文本开始，而 user 则代表消息身份，用于构建多轮对话，而 \u0026lt;|im_end|\u0026gt; 则代表文本结束，即用户输入结束，而 \u0026lt;|im_start|\u0026gt; 代表新一段文本开始， assistant 代表接下来由模型创建消息，而 \u0026lt;|im_end|\u0026gt; 同样代表模型创建消息的结束。模型就是通过这样一组特殊字符标记来规范自己的行为，判断当前消息类型，以及通过输出特殊标记来确定停止时间。对于绝大多数模型，我们可以在模型的 tokenizer_config.json 中看到完整的特殊标记符（以及系统提示词模板）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 { \u0026#34;add_bos_token\u0026#34;: false, \u0026#34;add_prefix_space\u0026#34;: false, \u0026#34;added_tokens_decoder\u0026#34;: { \u0026#34;151643\u0026#34;: { \u0026#34;content\u0026#34;: \u0026#34;\u0026lt;|endoftext|\u0026gt;\u0026#34;, \u0026#34;lstrip\u0026#34;: false, \u0026#34;normalized\u0026#34;: false, \u0026#34;rstrip\u0026#34;: false, \u0026#34;single_word\u0026#34;: false, \u0026#34;special\u0026#34;: true }, \u0026#34;151644\u0026#34;: { \u0026#34;content\u0026#34;: \u0026#34;\u0026lt;|im_start|\u0026gt;\u0026#34;, \u0026#34;lstrip\u0026#34;: false, \u0026#34;normalized\u0026#34;: false, \u0026#34;rstrip\u0026#34;: false, \u0026#34;single_word\u0026#34;: false, \u0026#34;special\u0026#34;: true }, \u0026#34;151645\u0026#34;: { \u0026#34;content\u0026#34;: \u0026#34;\u0026lt;|im_end|\u0026gt;\u0026#34;, \u0026#34;lstrip\u0026#34;: false, \u0026#34;normalized\u0026#34;: false, \u0026#34;rstrip\u0026#34;: false, \u0026#34;single_word\u0026#34;: false, \u0026#34;special\u0026#34;: true }, \u0026#34;151646\u0026#34;: { \u0026#34;content\u0026#34;: \u0026#34;\u0026lt;|object_ref_start|\u0026gt;\u0026#34;, \u0026#34;lstrip\u0026#34;: false, \u0026#34;normalized\u0026#34;: false, \u0026#34;rstrip\u0026#34;: false, \u0026#34;single_word\u0026#34;: false, \u0026#34;special\u0026#34;: true }, # ... # ... 2. 微调数据集 微调属于有监督的训练，所以需要输入输出对形式的数据集。\n2.1. 一般数据集 以huggingface上提供的一个医疗数据集为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [ { \u0026#34;instruction\u0026#34;: \u0026#34;小儿肥胖超重该如何治疗\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;女宝宝，刚7岁，这一年，察觉到，我家孩子身上肉很多，而且，食量非常的大，平时都不喜欢吃去玩，请问：小儿肥胖超重该如何治疗。\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;孩子出现肥胖症的情况。家长要通过孩子运功和健康的饮食来缓解他的症状，可以先让他做一些有氧运动，比如慢跑，爬坡，游泳等，并且饮食上孩子多吃黄瓜，胡萝卜，菠菜等，禁止孩子吃一些油炸食品和干果类食物，这些都是干热量高脂肪的食物，而且不要让孩子总是吃完就躺在床上不动，家长在治疗小儿肥胖期间如果孩子情况严重就要及时去医院在医生的指导下给孩子治疗。\u0026#34;, \u0026#34;history\u0026#34;: null }, { \u0026#34;instruction\u0026#34;: \u0026#34;小儿肥胖超重该怎样医治\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;男孩子，刚4岁，最近，发现，我家孩子体重要比别的孩子重很多，而且，最近越来越能吃了，还特别的懒，请问：小儿肥胖超重该怎样医治。\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;孩子一旦患上肥胖症家长要先通过运动和饮食来改变孩子的情况，要让孩子做一些他这个年龄段能做的运动，如游泳，慢跑等，要给孩子多吃一些像苹果，猕猴桃，胡萝卜等食物，禁止孩子吃高热量，高脂肪的食物，像蛋糕，干果，曲奇饼干等，严格的控制孩子的饮食，不要让他暴饮暴食，多运动对改变孩子肥胖都是有好处的，在治疗小儿肥胖期间如果情况严重，建议家长先带孩子去医院检查一下孩子肥胖症的原因在针对性的治疗。\u0026#34;, \u0026#34;history\u0026#34;: null }, { \u0026#34;instruction\u0026#34;: \u0026#34;小儿肥胖能吃该如何治疗\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;男宝，已经5岁，今年，察觉到，孩子身上越来越肉乎了，同时，吃的饭也比一般孩子多，平时都不喜欢吃去玩，请问：小儿肥胖能吃该如何治疗。\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;当孩子患上肥胖症的时候家长可以增加孩子的运动量和控制他的饮食来改变症状，像游泳，爬坡这类游泳运动对肥胖的症状都很好的效果，像冬瓜，西红柿这样高纤维的蔬菜要多吃一些，孩子不可以吃像蛋糕，夏威夷果这些高热量的食物，而且不要让孩子总是吃完就躺在床上不动，家长在治疗小儿肥胖期间如果孩子情况严重就要及时去医院在医生的指导下给孩子治疗。\u0026#34;, \u0026#34;history\u0026#34;: null }, 每一个”{}“中都有input和output，微调程序需要将数据集转化为如下格式， 才能训练模型：\n1 2 3 \u0026lt;|im_start|\u0026gt;system 小儿肥胖超重该怎样医治\u0026lt;|im_end|\u0026gt;\\n\u0026lt;|im_start|\u0026gt;user\\n男孩子，刚4岁，最近，发现，我家孩子体重要比别的孩子重很多，而且，最近越来越能吃了，还特别的懒，请问：小儿肥胖超重该怎样医治。\u0026lt;|im_end|\u0026gt;\\n\u0026lt;|im_start|\u0026gt;assistant\\n孩子一旦患上肥胖症家长要先通过运动和饮食来改变孩子的情况，要让孩子做一些他这个年龄段能做的运动，如游泳，慢跑等，要给孩子多吃一些像苹果，猕猴桃，胡萝卜等食物，禁止孩子吃高热量，高脂肪的食物，像蛋糕，干果，曲奇饼干等，严格的控制孩子的饮食，不要让他暴饮暴食，多运动对改变孩子肥胖都是有好处的，在治疗小儿肥胖期间如果情况严重，建议家长先带孩子去医院检查一下孩子肥胖症的原因在针对性的治疗。 \u0026lt;|im_end|\u0026gt; 上面的数据是给程序看的，我们整理一下，如下：\n1 2 3 4 5 6 7 8 9 \u0026lt;|im_start|\u0026gt;system 小儿肥胖超重该怎样医治 \u0026lt;|im_end|\u0026gt; \u0026lt;|im_start|\u0026gt;user 男孩子，刚4岁，最近，发现，我家孩子体重要比别的孩子重很多，而且，最近越来越能吃了，还特别的懒，请问：小儿肥胖超重该怎样医治。 \u0026lt;|im_end|\u0026gt; \u0026lt;|im_start|\u0026gt;assistant 孩子一旦患上肥胖症家长要先通过运动和饮食来改变孩子的情况，要让孩子做一些他这个年龄段能做的运动，如游泳，慢跑等，要给孩子多吃一些像苹果，猕猴桃，胡萝卜等食物，禁止孩子吃高热量，高脂肪的食物，像蛋糕，干果，曲奇饼干等，严格的控制孩子的饮食，不要让他暴饮暴食，多运动对改变孩子肥胖都是有好处的，在治疗小儿肥胖期间如果情况严重，建议家长先带孩子去医院检查一下孩子肥胖症的原因在针对性的治疗。 \u0026lt;|im_end|\u0026gt; 在训练过程中，通过\u0026lt;|im_start|\u0026gt;system...\u0026lt;|im_end|\u0026gt; 来标记系统提示词。实际进行微调时，模型会根据assistant为界，学习assistant之前的文本输入情况下应该如何输出。上面展示的是带有系统提示词的微调数据集格式，也有些微调数据集是没有系统提示词的。\n3. 训练Function calling能力的数据集 微调只能优化模型的Function calling能力，并不能从无到有让模型学会Function calling，所以微调只反对本身具备外部工具调用能力的模型。而且数据集中需要包含`tool schema·信息，如果对话过程中带入了Function calling，此时模型会读取tool schema，这个tool schema又是啥子？在对话系统中引入 Function Calling（函数调用）时，模型需要依赖 Tool Schema（工具架构）来理解可用的工具及其参数。Tool Schema 是对工具（如 API、数据库操作、外部服务等）的结构化定义，它明确告诉模型：\n工具的功能是什么？ 工具的输入参数有哪些？ 参数的类型和约束条件是什么？ 工具的输出格式是什么？ 3.1. Tool Schema 数据集的核心作用 定义工具的接口： Tool Schema 是模型与外部工具之间的“契约”，确保模型生成的调用符合工具的实际需求。例如，调用天气查询 API 时，必须指定 location 参数，且类型为字符串。 参数验证： 模型生成的调用参数需符合 Tool Schema 的格式要求（如字段名、类型、必填项），避免无效调用。 生成结构化输出：\n模型会根据 Tool Schema 的描述，生成符合要求的 JSON 或其他结构化数据作为调用参数。 3.2. Tool Schema 数据集格式 Tool Schema有多种定义方式，Python 函数 + 类型注解、Pydantic 模型、JSON Schema，MCP会自动创建tool schema。\nTool Schema Json 的大概形式如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 tool_schema = [ { \u0026#34;name\u0026#34;: \u0026#34;get_weather\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;查询指定城市的天气信息\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;要查询天气的城市名称\u0026#34; } }, \u0026#34;required\u0026#34;: [\u0026#34;location\u0026#34;] } } ] 此时，如果我们进行如下对话：\n系统提示词（instruction） ：你是一名助人为乐的助手。当用户查询天气的时候，请调用get_weather函数进行天气信息查询。\n用户输入（input） ： 你好，请帮我查询下北京天气。 助手回复（output） ：{\u0026ldquo;name\u0026rdquo;: \u0026ldquo;get_weather\u0026rdquo;, \u0026ldquo;arguments\u0026rdquo;: {\u0026ldquo;location\u0026rdquo;: \u0026ldquo;北京\u0026rdquo;}}\n这个”助手回复（output）“就是一条Function call message， 根据这条信息来进行外部工具调用。此时模型真实的输入和输出内容如下：\n接下来在进行训练时，模型同样是根据assistant前的内容，学习assistant后面的输出内容。\n4. 带有思考过程的数据集 如果是带有思考链，则数据集大概形式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;system\u0026#34;: \u0026#34;你是一名助人为乐的助手。当用户查询天气的时候，请调用get_weather函数进行天气信息查询。\u0026#34;, \u0026#34;conversations\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;你好，好久不见！\u0026#34; } { \u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34;, \u0026#34;contant\u0026#34;: \u0026#34;是的呀，好久不见，最近有什么事情要分享给我吗？\u0026#34;, \u0026#34;reasoning_content\u0026#34;: \u0026#34;好的, 用户发来“你好，好久不见！”,我需要回应。首先，用户可能希望得到亲切的回应，所以应该用友好的语气。\u0026#34;, } ] } 此时对应的模型真实的内部输入和输出结果如下：\n1 2 3 4 5 6 7 8 9 \u0026lt;|im_start|\u0026gt;system 你是一名助人为乐的助手。\u0026lt;|im_end|\u0026gt; \u0026lt;|im_start|\u0026gt;user 你好，好久不见。\u0026lt;|im_end|\u0026gt; \u0026lt;|im_start|\u0026gt;assistant \u0026lt;think\u0026gt; 好的，用户发来“你好，好久不见！”，我需要回应。首先，用户可能希望得到亲切的回应，所以应该用友好的语气。 \u0026lt;/think\u0026gt; 是的呀，好久不见，最近有什么有趣的事情要和我分享么？\u0026lt;|im_end|\u0026gt; \u0026lt;think\u0026gt;与\u0026lt;/think\u0026gt;之间的就是思考过程，后面紧跟着就是模型回答。\n5. 带有思考过程、Function calling的数据集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;system\u0026#34;: \u0026#34;你是一名助人为乐的助手。\u0026#34;, \u0026#34;conversations\u0026#34;: [ { \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;你好，好久不见！\u0026#34; } { \u0026#34;role\u0026#34;: \u0026#34;assistant\u0026#34;, \u0026#34;contant\u0026#34;: \u0026#34; \u0026lt;tool_call\u0026gt;/n{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;get_weather\\\u0026#34;, \\\u0026#34;arguments\\\u0026#34;: \\\u0026#34;location\\\u0026#34;: \\\u0026#34;北京\\\u0026#34;}/n\u0026lt;/tool_call\u0026gt;\u0026#34;, \u0026#34;reasoning_content\u0026#34;: \u0026#34;好的，用户问北京今天的天气，我应该尝试调用工具 get_weather，并将参数设置为北京。\u0026#34;, } ] } 训练模型时读取到的格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;|im_start|\u0026gt;system 你是一名助人为乐的助手。当用户查询天气的时候，请调用get_weather函数进行天气信息查询。 # Tools You may call one or more functions to assist with the user query. You are provided with function signatures within \u0026lt;tools\u0026gt;\u0026lt;/tools\u0026gt; XML tags: \u0026lt;tools\u0026gt; {\u0026#34;name\u0026#34;: \u0026#34;get_weather\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;查询指定城市的天气信息\u0026#34;, \u0026#34;parameters\u0026#34;: {\u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: {\u0026#34;location\u0026#34;: {\u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;要查询天气的城市名称\u0026#34;}}, \u0026#34;required\u0026#34;: [\u0026#34;location\u0026#34;]}} \u0026lt;/tools\u0026gt; For each function call, return a json object with function name and arguments within \u0026lt;tool_call\u0026gt;\u0026lt;/tool_call\u0026gt; XML tags: \u0026lt;tool_call\u0026gt; {\u0026#34;name\u0026#34;: \u0026lt;function-name\u0026gt;, \u0026#34;arguments\u0026#34;: \u0026lt;args-json-object\u0026gt;} \u0026lt;/tool_call\u0026gt; \u0026lt;|im_end|\u0026gt; \u0026lt;|im_start|\u0026gt;user 你好，请帮我查询下北京天气。 \u0026lt;|im_end|\u0026gt; \u0026lt;|im_start|\u0026gt;assistant \u0026lt;think\u0026gt; 好的，用户问北京今天的天气，我应该尝试调用工具 get_weather，并将参数设置为北京。 \u0026lt;/think\u0026gt; \u0026lt;tool_call\u0026gt; {\u0026#34;name\u0026#34;: \u0026#34;get_weather\u0026#34;, \u0026#34;arguments\u0026#34;: {\u0026#34;location\u0026#34;: \u0026#34;北京\u0026#34;}} \u0026lt;/tool_call\u0026gt;\u0026lt;|im_end|\u0026gt; 同时拥有Function calling、混合推理等功能，属于功能非常复杂的模型了。在实际微调过程中，稍有不慎就会令其丧失原有能力。\n","date":"2025-05-17T00:00:00Z","permalink":"https://zuoco.github.io/p/%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%832-%E8%AE%A4%E8%AF%86%E5%BE%AE%E8%B0%83%E6%95%B0%E6%8D%AE%E9%9B%86/","title":"模型微调（2） — 认识微调数据集"},{"content":" 1. 全量微调与高效微调 2. 模型微调的优劣势分析 3. 高效微调与LoRA、QLoRA 3.1. LoRA 与 QLoRA 二者对比如下 3.2. 高效微调的应用场景 4. 主流微调工具 4.1. unsloth 4.2. ms-SWIFT 4.3. 模型性能评估框架EvalScope 所谓大模型微调，指的在已有的大规模预训练模型基础上，使用特定的数据集进行训练，进一步优化模型的表现，以适应特定任务或场景的需求。不同于RAG或者Agent技术，通过搭建工作流，关联外部工具等等来优化模型表现，微调是通过修改模型参数来优化模型能力，是一种能够让模型“永久”掌握某种能力的方法。\n1. 全量微调与高效微调 从方法的大类上来划分，微调又可以划分为全量微调和高效微调，全量微调就是带入全部数据进行微调，一般是由大模型研发团队完成，例如DepSeek研发团队，千问研发团队。高效微调是只带入部分数据进行微调，适合用户拿到模型后，使用特定数据集进行微调，以改善模型在特定场景下的表现。\n2. 模型微调的优劣势分析 尽管模型微调能够通过修改模型参数的方式，永久的修改模型的能力，但这其实是一把双刃剑，如果处理不当，很可能造成模型原始能力的灾难性遗忘、即会导致模型原始能力丢失，对于复杂模型尤其如此。而为了能够满足微调最初目标，我们必须小心谨慎的设计模型微调数据集和微调训练流程，并经过反复多次训练验证，得到一个最佳模型。\n3. 高效微调与LoRA、QLoRA 尽管全量微调可以对模型的能力进行深度改造，但要带入模型全部参数进行训练，需要消耗大量的算力，且有一定的技术门槛。相比之下，在绝大多数场景中，如果我们只想提升模型某个具体领域的能力，那高效微调会更加合适。尽管在2020年前后，深度学习领域诞生了很多高效微调的方法，但现在适用于大模型的最主流的高效微调方法只有一种——LoRA。\nLoRA（Low-Rank Adaptation）微调是一种参数高效的微调方法，旨在通过引入低秩矩阵来减少微调时需要调整的参数数量，从而显著降低显存和计算资源的消耗。具体来说，LoRA 微调并不直接调整原始模型的所有参数，而是通过在某些层中插入低秩的适配器（Adapter）层来进行训练。\nLoRA的原理：　在标准微调中，我们会修改模型的所有权重，而在 LoRA 中，只有某些低秩矩阵（适配器）被训练和调整。这意味着原始模型的参数保持不变，只是通过少量的新参数来调整模型的输出。 低秩矩阵的引入可以在显存和计算能力有限的情况下，依然有效地对大型预训练模型进行微调，从而让 LoRA 成为显存较小的设备上的理想选择。 LoRA的优势：\n显存优化： 只需要调整少量的参数（适配器），显著减少了显存需求，适合显存有限的GPU。　计算效率： 微调过程中的计算负担也更轻，因为减少了需要调整的参数量。　灵活性： 可以与现有的预训练模型轻松结合使用，适用于多种任务，如文本生成、分类、问答等。　而QLoRA（Quantized Low-Rank Adaptation） 则是 LoRA 的一个扩展版本，它结合了 LoRA 的低秩适配器和量化技术。QLoRA 进一步优化了计算效率和存储需求，特别是在极端显存受限的环境下。与 LoRA 不同的是，QLoRA 会将插入的低秩适配器层的部分权重进行量化（通常是量化为 INT4 或INT8），在保持性能的同时显著降低模型的存储和计算需求。　－　核心思想： 在 LoRA 的基础上加入量化技术，减少权重表示的位数，从而降低显存和计算需求。QLoRA 结合了低秩适配器和量化的优点，能够在显存有限的设备上进行更高效的微调。 －　量化： 通过将模型权重量化为低精度（如 INT4），减少内存占用，并提高推理和训练速度。 －　优势：\n在显存非常有限的情况下仍能进行微调。 可以处理更大规模的模型。 适合用于边缘设备和需要低延迟推理的场景。 3.1. LoRA 与 QLoRA 二者对比如下 特性 Lora QLoRA 核心技术 低秩适配器 低秩适配器 + 量化技术 适用场景 显存有限，但是设备性能好 显存极限受限或需要快速推理 计算效率 较高 更高 量化技术 无量化 将权重量化为低精度(int4或int8) 内存消耗 较低 更低 训练复杂度 较简单 较复杂，需要量化与适配 3.2. 高效微调的应用场景 在实际大模型应用场景中，高效微调主要用于以下四个方面：\n对话风格微调*：高效微调可以用于根据特定需求调整模型的对话风格。例如，针对客服系统、虚拟助理等场景，模型可以通过微调来适应不同的 语气、礼貌程度 或 回答方式，从而在与用户互动时提供更符合要求的对话体验。通过微调少量的参数（例如对话生成的策略、情感表达等），可以使模型表现出更具针对性和个性化的风格。 知识灌注：知识灌注是指将外部知识或领域特定的信息快速集成到已有的预训练模型中。通过高效微调，模型可以更好地学习新领域的专有知识，而无需重新从头开始训练。例如，对于法律、医疗等专业领域，可以使用少量的标注数据对预训练模型进行微调，帮助模型理解特定行业的术语、规则和知识，进而提升专业领域的问答能力。 推理能力提升：高效微调还可以用于提升大模型的推理能力，尤其是在处理更复杂推理任务时。通过微调，模型能够更加高效地理解长文本、推理隐含信息，或者从数据中提取逻辑关系，进而在多轮推理任务中提供更准确的答案。这种微调方式可以帮助模型在解答复杂问题时，提高推理准确性并减少错误。 Agent能力（Function calling能力、或者MCP能力）提升：在多任务协作或功能调用场景中，高效微调能够显著提升模型的Agent能力，使得模型能够有效地与其他系统进行交互、调用外部API或执行特定任务。通过针对性微调，模型可以学会更精准的功能调用策略、参数解析和操作指令，从而在自动化服务、智能助手或机器人控制等领域表现得更加高效和智能。 4. 主流微调工具 unsloth、Llama、Factory、ms-SWIFT和ColossalAI。除此之外，也可以借助更加底层的库，如peft、LoRA、transformer等实现高效微调。对于初学者来说，首先使用现成工具来进行微调，四种工具基本说明如下。\n4.1. unsloth unsloth 是一个专为大型语言模型（LLM）设计的动态量化与微调框架，unsloth 与 HuggingFace 生态兼容，可以很容易地transformers、peft、trl 等库结合，以实现模型的监督微调（SFT）和直接偏好优化（DPO）。 Unsloth 的动态量化方法，最新的 Dynamic 2.0 版本，旨在在尽量减少性能损失的同时显著压缩大型语言模型（LLMs）的体积。对于 Qwen3 模型，尤其是 4-bit 动态量化版本，现有的评测显 示其性能下降非常有限，甚至在某些任务上与原始模型相当。 动态量化由利也有弊，其好处在于可以极大程度压缩模型运行所需占用的显存大小，同时几乎不损失性能，但问题在于动态量化的模型，无论是推理还是微调，只能单卡运行，这就使得其吞吐量有限，无法在一台物理机上实现多GPU并行从而扩大吞吐量。\n4.2. ms-SWIFT ms-swift是由魔搭社区（ModelScope）开发的高效微调和部署框架，旨在为研究人员和开发者提供一站式的大模型与多模态大模型的训练、推理、评测、量化和部署解决方案。支持超过 450 种大型模型（LLMs）和 150多种多模态大模型（MLLMs）的训练和部署。\n4.3. 模型性能评估框架EvalScope EvalScope是由阿里巴巴魔搭社区（ModelScope）推出的一款开源模型评估框架，旨在为大语言模型（LLM）和多模态模型提供统一、系统化的性能评估方案。该框架具备高度的自动化和可扩展性，适用于研究机构、工业界以及模型开发者在模型验证与性能对比场景中的广泛需求。\n","date":"2025-05-16T00:00:00Z","permalink":"https://zuoco.github.io/p/%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%831-lora%E5%BE%AE%E8%B0%83/","title":"模型微调（1） — LoRA微调"},{"content":" 1. 本地环境 2. CUDA安装 3. AI部署框架 4. 安装ollama 5. AI 模型部署 6. 前端接入 7. 效果展示 1. 本地环境 1. 主机\n主机：天钡 GEM12 Pro CPU: AMD Ryzen 7 PRO 8845HS 内存：32GB 2. 系统\n发行版：Fedora Linux 41 (Workstation Edition) 内 核：6.14.6-200.fc41.x86_64 3. 显卡 NVIDIA GTX 5060 Ti 16GB\n2. CUDA安装 登陆nvidia developer官网，进入CUDA Toolkit，并选择需要的版本。根据下面网页的提示选择系统版本后，页面下方会给出对应的安装过程，根据指示安装即可，安装完成后可以在终端查看显卡信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 zcli@fedora:~$ nvidia-smi Sun May 18 22:05:08 2025 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 575.51.03 Driver Version: 575.51.03 CUDA Version: 12.9 | |-----------------------------------------+------------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | # 第一行标题 | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | # 第二行标题，其中Perf表示当前性能状态（P0 ~ P15，P0 是最高性能，P12/P15 是节能模式） | | | MIG M. | # 第三行标题 |=========================================+========================+======================| | 0 NVIDIA Graphics Device On | 00000000:01:00.0 On | N/A | # 第一行数据，对应第一行标题 | 0% 47C P5 10W / 180W | 1346MiB / 16311MiB | 0% Default | # 第二行数据，对应第二行标题 | | | N/A | # 第三行数据，对应第三行标题 +-----------------------------------------+------------------------+----------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | # 进程列表 | ID ID Usage | |=========================================================================================| | 0 N/A N/A 36667 G /usr/bin/gnome-shell 393MiB | # 几个使用GPU进程的进程以及使用的显存 | 0 N/A N/A 37509 C+G /usr/bin/ptyxis 73MiB | | 0 N/A N/A 37546 G /usr/bin/Xwayland 38MiB | | 0 N/A N/A 37828 G ...ess --variations-seed-version 207MiB | | 0 N/A N/A 38479 C+G /opt/microsoft/msedge/msedge 6MiB | | 0 N/A N/A 38542 G ...per --variations-seed-version 415MiB | | 0 N/A N/A 38747 G /usr/bin/clash-verge 2MiB | +-----------------------------------------------------------------------------------------+ 3. AI部署框架 模型只是一堆参数，需要通过推理工具来运行，推理工具将模型参数加载到显存中，并依据输入的文字生成输出。\n我们接下来要完成:\n大模型框架部署(推理工具)，以Ollama为例； 模型部署，以Qwen32-14B为例； 前端接入，以CherryStudio为例； 4. 安装ollama 参考【Ollama部署】篇。\n5. AI 模型部署 因为Ollama服务已经启动了，所以就不必再次运行ollama serve命令了。直接开run： 提示： ollama run qwen3:14b会从Ollama服务器拉取模型，国内网络可能不太行，可以使用ollama run modelscope.cn/Qwen/Qwen3-14B-GGUF。\n1 2 3 4 5 6 7 8 9 10 11 zcli@fedora:~$ ollama run qwen3:14b # 如果模型还没有下载就会先下载模型，等待即可 pulling manifest pulling a8cc1361f314: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████▏ 9.3 GB pulling eb4402837c78: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████▏ 1.5 KB pulling d18a5cc71b84: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████▏ 11 KB pulling cff3f395ef37: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████▏ 120 B pulling 78b3b822087d: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████▏ 488 B verifying sha256 digest writing manifest success \u0026gt;\u0026gt;\u0026gt; Send a message (/? for help) 好了，可以开始提问了，按照惯例先Hello Word:\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; 你好呀！ \u0026lt;think\u0026gt; 好的，用户发来“你好呀！”，我需要友好回应。首先，要保持亲切，用表情符号增加温度。然后，可以询问用户是否需要帮助，但不要显得太正式。可能用户只是打招呼， 所以简单回应即可，留出空间让用户继续交流。注意用词口语化，避免复杂句子。检查有没有拼写错误，确保回复自然。最后，保持开放态度，让用户知道我随时准备帮助他 们。 \u0026lt;/think\u0026gt; 你好呀！😊 很高兴见到你！今天过得怎么样呀？需要我帮忙做点什么吗？ \u0026gt;\u0026gt;\u0026gt; Send a message (/? for help) 此时的显存占用：11490MiB / 16311MiB，看来，16G显存部署一个14B刚刚好。\n--verbose参数： 显示推理过程的耗时情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 zcli@fedora:~$ ollama run qwen3:14b --verbose \u0026gt;\u0026gt;\u0026gt; 西红柿怎么吃？ \u0026lt;think\u0026gt; 嗯，用户问的是“西红柿怎么吃？”，这个问题看起来挺简单的，但其实可能需要更深入的思考。首先，我得考虑用户可能的背景。他们可能是刚开始接触西红柿，或者想找 一些新的吃法。也可能他们之前吃过，但想尝试更多不同的做法。 ...... ...... # 这个就略了吧 \u0026lt;/think\u0026gt; 西红柿（番茄）是一种非常百搭的食材，既可以直接生吃，也可以通过多种烹饪方式制作成美味佳肴。以下是常见的吃法和一些创意做法，供你参考： ...... ...... # 这个也略吧 根据你的口味和需求，可以灵活选择以上吃法！如果需要具体菜谱或步骤，也可以告诉我哦 😊 # 下面的输出是重点 total duration: 33.622874783s # 总耗时33.6秒 load duration: 9.67421ms # 模型加载耗时9.67ms prompt eval count: 12 token(s) # 输入提示（prompt）的 token 数量，输入提示词被分词为 12 个 token。 prompt eval duration: 25.738437ms # 处理这 12 个 token 的提示词用了约 25.7 毫秒。 prompt eval rate: 466.23 tokens/s # 处理输入提示的速度（token/s），默认启用 enable_thinking=True（思考模式）。 eval count: 1278 token(s) # 模型生成输出的 token 总数。 eval duration: 33.587006893s # 生成输出的总耗时，占总耗时的 99.9%（total duration 的 33.62 秒）。说明生成阶段是性能瓶颈。。 eval rate: 38.05 tokens/s # 生成输出的速度（token/s），生成速度较慢（38 tokens/s），这与 14B 参数量的 Dense 模型特性一致， # Qwen3 的 MoE 模型（如 Qwen3-30B-A3B）通过激活部分参数（30B 总参数，仅激活 3B）实现更高的生成速度。 模型文件位于目录：/usr/share/ollama下。\n6. 前端接入 Ollama默认是在11434端口提供服务。明白了这个就可以到www.cherry-ai.com下载Cherry Studio了。 安装好后，选择『设置』，然后在『设置』中选择『Ollama』： 点击『添加』，然后填写“模型ID”，“模型名称”，“分组名称”，这些信息通过ollama list命令获取，注意了，这里的“模型ID”是ollama list命令输出的“NAME”，而不是ID,然后点击右上角的“检测”，提示“连接成功”就OK了，至于API密钥，随便填个什么就行，最后将默认助手的模型设置为我们刚刚添加的模型就可以使用了。\n7. 效果展示 以上文提到的西红柿问题为例，我们让qwen3-14b自己评价自己性能表现： ","date":"2025-05-15T00:00:00Z","permalink":"https://zuoco.github.io/p/%E4%BD%BF%E7%94%A8ollama%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2qwen3-14b/","title":"使用Ollama本地部署Qwen3-14b"},{"content":"1. 什么是内存碎片化 随着系统的运行，内存会不断被分配和释放，被分割成大量不连续的小块空闲区域，这会致系统无法分配较大连续物理内存页面，当我们发现空闲内存总量可观，但是大块内存数量少，以及大块内存申请效率低下时，可能就是内存碎片化比较严重。\n2. 检查内存碎片化程度 先了解一个重要文件：\n1 2 3 4 zcli@fedora:~$ cat /proc/buddyinfo Node 0, zone DMA 0 0 0 0 0 0 0 0 1 1 2 Node 0, zone DMA32 8 11 6 7 7 7 10 8 7 9 573 Node 0, zone Normal 1958 592 249 207 133 32 98 87 36 11 4422 文件每一行的格式为：\n1 2 # 4KB 8KB 2M 4M Node \u0026lt;node_id\u0026gt;, zone \u0026lt;zone_name\u0026gt; \u0026lt;order0\u0026gt; \u0026lt;order1\u0026gt; ... \u0026lt;order9\u0026gt; \u0026lt;order10\u0026gt; Node 0： 表示单个 NUMA 节点（无 NUMA 架构时仅一个节点）。\nzone \u0026lt;zone_name\u0026gt;：内存区域类型，常见类型包括：\nDMA：直接内存访问（DMA）区域，用于 32 位设备的内存访问（地址范围有限）。 DMA32：扩展的 32 位 DMA 区域（地址范围比 DMA 更广）。 Normal：普通内存区域，用于大多数内存分配。 \u0026lt;orderN\u0026gt;：\n表示阶（order）为 N 的空闲内存块数量(N从0开始)。每个阶的内存块大小为 2^N * PAGE_SIZE（通常 PAGE_SIZE = 4KB），order9是2M，order10是4M。\n对于32位的系统，内存区域类型:\n1 2 3 DMA Normal HighMem # 高内存区，在32位系统上用于扩展可寻址内存范围，对于64位系统，没有这东西。 如果内存总量充足，但是大块内存申请效率低，甚至引发OOM，或者系统重启，此时可以查看order9和order10的内存块数量，高阶阶空闲块越少代表内存碎片化越严重。\n3. 如何解决 3.1. 内存整理 内核虚拟文件系统中有这么一个文件：/proc/sys/vm/compact_memory\n1 2 root@fedora:~# ls -al /proc/sys/vm/compact_memory --w-------. 1 root root 0 5月20日 22:44 /proc/sys/vm/compact_memory # 写入1或0 0： 禁止内存整理功能（默认值）。 1： 启用内存压缩，并触发一次内存整理操作。\n1. 临时启用内存压缩功能\n1 sudo susctl vm.compact_memory=1 以上方法是一次性的，重启后失效。\n2. 永久启用\n将下面内容写入/etc/sysctl.conf文件中：\n1 vm.compact_memory=1 然后执行：\n1 sudo sysctl -p 但是要注意:\n内存压缩是一个同步、阻塞式的操作，会增加CPU和IO开销，不建议在生产环境频繁使用。 内存压缩需要启用内核CONFIG_COMPACTION选项，可以通过以下命令查看该功能是否启用： 1 grep CONFIG_COMPACTION /boot/config-$(uname -r) # 输出CONFIG_COMPACTION=y表示启用了该功能。 3.2. 增加预留内存 /proc/sys/vm/min_free_kbytes，这个文件可以查看系统预留内存的大小。文件中的值定义了在系统中应始终保持空闲的最小内存量（以KB为单位）。这个参数对于防止内存完全耗尽，确保系统即使在高负载下也能平稳运行至关重要。当可用内存降至 min_free_kbytes 设置的阈值之下时，Linux 内核的内存回收机制会主动尝试释放内存，例如通过回收缓存或交换出不活跃的页面到磁盘。\n3.3. 增加预留内存的方法 1. 临时措施\n1 2 sudo sysctl -w vm.min_free_kbytes=\u0026lt;new_value\u0026gt; # sudo sysctl -w vm.min_free_kbytes=2097152 设置为2G 1. 永久措施\n向/etc/sysctl.conf写入vm.min_free_kbytes = \u0026lt;new_value\u0026gt;;\n执行命令sudo sysctl -p;\n适当增加预留内存，可以使系统更加积极的整理内存，而不是等到有程序申请大块内存时才进行整理。\n","date":"2025-05-13T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%8C%96/","title":"内存碎片化"},{"content":" 1. Ollama安装 2. Ollama基础命令 1. Ollama安装 登陆ollama官网，官网直接给出了一行命令，该命令可以自动下载并安装ollama：\n1 curl -fsSL https://ollama.com/install.sh | sh 该命令会下载一个脚本，该脚本使用curl命令下载ollama安装程序，并执行安装程序，但是这个curl始终不能连接网络，所以只能手动下载安装文件：\n1. 第一步： 下载安装脚本\n1 curl -fsSL https://ollama.com/install.sh -o ollama_install.sh # 下载安装脚本 2. 第二步： 在这个安装脚本中查找“下载链接” 打开下载下来的脚本，搜索https://ollama.com/download/ollama-linux-，找到类似如下代码：\n1 2 3 4 status \u0026#34;Downloading Linux ${ARCH} bundle\u0026#34; curl --fail --show-error --location --progress-bar \\ \u0026#34;https://ollama.com/download/ollama-linux-${ARCH}.tgz${VER_PARAM}\u0026#34; | \\ $SUDO tar -xzf - -C \u0026#34;$OLLAMA_INSTALL_DIR\u0026#34; 这段代码的功能就是下载ollama安装文件，从代码来看，安装文件会被解压到$OLLAMA_INSTALL_DIR目录下，其实就是usr/local/目录，我门先不管这些，在这段脚本前添加echo \u0026quot;https://ollama.com/download/ollama-linux-${ARCH}.tgz${VER_PARAM}\u0026quot;命令，然后运行脚本，打印出来的链接就是了。\n3. 下载安装文件 复制前面打印出来的链接，直接到浏览器中下载，并将下载好的压缩包保存到和安装脚本相同目录下。\n1 2 3 zcli@fedora:~$ ls -lh | grep ollama -rwxrwxrwx. 1 zcli zcli 13K 5月18日 21:11 ollama_install.sh # 安装脚本 -rw-r--r--. 1 zcli zcli 1.6G 5月18日 21:04 ollama-linux-amd64.tgz # 安装文件 4. 修改安装脚本 定位到第二步中给出的代码：\n1 2 3 4 status \u0026#34;Downloading Linux ${ARCH} bundle\u0026#34; curl --fail --show-error --location --progress-bar \\ \u0026#34;https://ollama.com/download/ollama-linux-${ARCH}.tgz${VER_PARAM}\u0026#34; | \\ $SUDO tar -xzf - -C \u0026#34;$OLLAMA_INSTALL_DIR\u0026#34; 修改为：\n1 2 3 # 也就是不curl了，直接将已经下载好的安装文件解压到指定目录。 status \u0026#34;Downloading Linux ${ARCH} bundle\u0026#34; $SUDO tar -xzf ollama-linux-amd64.tgz -C \u0026#34;$OLLAMA_INSTALL_DIR\u0026#34; # 解压到指定目录 5. 执行安装脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 zcli@fedora:~$ ./ollama_install.sh \u0026gt;\u0026gt;\u0026gt; Cleaning up old version at /usr/local/lib/ollama [sudo] zcli 的密码： \u0026gt;\u0026gt;\u0026gt; Installing ollama to /usr/local \u0026gt;\u0026gt;\u0026gt; Downloading Linux amd64 bundle \u0026gt;\u0026gt;\u0026gt; Creating ollama user... \u0026gt;\u0026gt;\u0026gt; Adding ollama user to render group... \u0026gt;\u0026gt;\u0026gt; Adding ollama user to video group... \u0026gt;\u0026gt;\u0026gt; Adding current user to ollama group... \u0026gt;\u0026gt;\u0026gt; Creating ollama systemd service... \u0026gt;\u0026gt;\u0026gt; Enabling and starting ollama service... Created symlink \u0026#39;/etc/systemd/system/default.target.wants/ollama.service\u0026#39; → \u0026#39;/etc/systemd/system/ollama.service\u0026#39;. \u0026gt;\u0026gt;\u0026gt; NVIDIA GPU installed. OK，安装好了，在Linux上，这个ollama安装为一个Linux服务，并且安装后就自动运行起来了，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 zcli@fedora:~$ sudo systemctl status ollama.service ● ollama.service - Ollama Service Loaded: loaded (/etc/systemd/system/ollama.service; enabled; preset: disabled) Drop-In: /usr/lib/systemd/system/service.d └─10-timeout-abort.conf, 50-keep-warm.conf Active: active (running) since Sun 2025-05-18 23:03:56 CST; 1min 31s ago Invocation: 2dbc0a03db1c4a08a17829fa4039bf63 Main PID: 43831 (ollama) Tasks: 13 (limit: 37474) Memory: 24.5M (peak: 40.9M) CPU: 248ms CGroup: /system.slice/ollama.service └─43831 /usr/local/bin/ollama serve 2. Ollama基础命令 下载模型 1 2 # 但是ollama默认下载的可能是量化版本，且国内访问会很慢，可以从modelscope下载 ollama pull \u0026lt;模型名\u0026gt;:\u0026lt;版本号\u0026gt; modelscope.cn/Qwen/\u0026lt;模型名称\u0026gt;:\u0026lt;版本号\u0026gt; # 国内下载 运行模型 1 ollama run \u0026lt;模型名称\u0026gt;:\u0026lt;版本号\u0026gt; 查看推理过程 1 ollama run \u0026lt;模型名\u0026gt; --verbose # 显示推理过程的耗时情况 列出所有模型 1 ollama list 查看模型参数信息 1 ollama show \u0026lt;模型名称\u0026gt; 删除模型 1 ollama rm \u0026lt;模型名称\u0026gt; 查看正在运行的模型 1 ollama ps 停止运行中的模型 1 ollama stop \u0026lt;模型名称\u0026gt; ","date":"2025-05-01T00:00:00Z","permalink":"https://zuoco.github.io/p/ollama%E9%83%A8%E7%BD%B2/","title":"Ollama部署"},{"content":" 1. Function Calling 1.1. 核心流程 1.2. 问题 2. MCP 2.1. 核心组件与架构 3. MCP与Functional Calling的关系 1. Function Calling 大模型的 Function Calling（函数调用） 是一种让大语言模型与外部工具或 API 交互的核心技术。它使模型能够根据用户请求，智能地生成结构化调用指令（如 JSON 格式），触发开发者预定义的函数，从而突破纯文本生成的限制，执行实际任务（如查天气、发邮件、查数据库等）。\n1.1. 核心流程 1. 用户提问\n用户提出需要外部能力的请求，例如： “今天北京的温度是多少？”\n2. 模型决策\n模型分析请求，判断是否需要调用函数（例如天气查询 API），并选择匹配的函数（如 get_current_weather）。\n3. 生成结构化请求\n模型输出标准化的函数调用参数（非自然语言），例如：\n1 2 3 4 { \u0026#34;function\u0026#34;: \u0026#34;get_current_weather\u0026#34;, \u0026#34;arguments\u0026#34;: {\u0026#34;location\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;} } 4. 开发者代码执行函数 开发者代码解析该请求，调用真实 API 获取数据：\n1 weather_data = get_current_weather(\u0026#34;北京\u0026#34;, \u0026#34;celsius\u0026#34;) # 返回：{\u0026#34;temp\u0026#34;: 25, \u0026#34;condition\u0026#34;: \u0026#34;晴\u0026#34;} 5. 将结果返回给模型\n将 API 返回的数据重新传给模型：\n1 {\u0026#34;temp\u0026#34;: 25, \u0026#34;condition\u0026#34;: \u0026#34;晴\u0026#34;} 6. 生成最终回答\n模型将原始数据转化为自然语言回复： “北京今天气温 25 摄氏度，天气晴朗。”\n1.2. 问题 业务（用户提问）和平台接口调用是一体的，客户端直连平台API，需要管理函数的声明，参数传递，结果分析。而且每一次提问，就会进行一次Function Calling。不同的Calling之间是隔离的。\n2. MCP MCP（Model Context Protocol）是由 Anthropic 推出的开源协议，旨在实现大语言模型（LLM）与外部数据源和工具的高效集成。这是一种通用接口协议，类似于 OpenAPI，但专为 AI 模型设计。它通过标准化通信协议、数据格式和规则，让 LLM 能够安全、灵活地连接本地和远程资源（如数据库、API、文件系统等）。\n2.1. 核心组件与架构 MCP 采用 客户端 - 服务器 架构，主要组件包括：\nMCP Hosts\n角色：受控本地资源的入口层，发起上下文请求。\n示例：Claude Desktop、AI 开发 IDE。 MCP Clients\n角色：协议转换层，维护与服务端的持久连接。 示例：语言模型接口适配器。 MCP Servers\n角色：封装数据/工具能力，提供标准化接口。\n示例：文档解析服务、API 网关服务。 Local Data\n角色：受控本地资源（如企业知识库、私有数据库）。 Remote Services 角色：云端扩展能力（如搜索引擎、支付接口）。 3. MCP与Functional Calling的关系 可以简单理解为，MCP是对于Functional Programming的封装，业务层不在需要直接Function Calling，这些都由MCP Servers完成。业务层只需要对接标准的MCP协议接口即可，而且以此业务请求也可以触发多次Function Calling，并将Calling结果整合输出给用户。\n","date":"2025-03-08T00:00:00Z","permalink":"https://zuoco.github.io/p/function-calling-%E4%B8%8E-mcp%E5%8D%8F%E8%AE%AE/","title":"Function Calling 与 MCP协议"},{"content":" 1. 功能介绍 2. 整体架构与模块化设计 3. 业务分层设计 4. 应用代码模块化 5. 项目的核心库模块化 6. 软件设计思想 6.1. 抽象化 6.2. 高内聚低耦合 6.3. 重用原则 1. 功能介绍 Deskflow是一款免费且开源的键盘和鼠标共享应用程序，它允许你使用单个键盘和鼠标无缝控制多台计算机。类似于软件KVM（键盘、视频、鼠标）切换器，但不含视频组件，Deskflow让你可以将光标从一台屏幕边缘移出并进入另一台计算机的屏幕，键盘控制会自动跟随。\n2. 整体架构与模块化设计 Deskflow采用客户端-服务器架构，物理设备接入端就是服务端。\n3. 业务分层设计 Deskflow采用了清晰的分层架构设计：\n应用层 GUI应用程序和命令行工具 业务逻辑层 客户端/服务器核心逻辑，协议处理 服务层 网络通信、事件系统、配置管理 平台抽象层 操作系统接口抽象 基础设施层 日志、工具类、基础数据结构 4. 应用代码模块化 组件 描述 deskflow-gui 主图形用户界面 deskflow-client 接收输入事件的客户端应用程序 deskflow-server 发送输入事件的服务器应用程序 deskflow-daemon 用于系统集成的后台服务 deskflow-core 组件间共享的核心功能 5. 项目的核心库模块化 lib模块 功能 arch模块 操作系统抽象层，处理平台相关的底层操作 base模块 基础设施模块，提供事件系统、日志、工具类等 net模块 网络通信模块，负责TCP/SSL连接和数据传输 platform模块 平台适配模块，处理不同操作系统的具体实现 client/server模块 客户端和服务器核心逻辑 deskflow模块 应用程序框架和配置管理 6. 软件设计思想 6.1. 抽象化 项目定义了一个基础接口类IInterface作为所有接口类的基类，所有接口类都只包含纯虚方法，每个接口类会提供多个派生类，分别适配不同操作系统。通过一个Arch单例类型整合了不同操作系统的系统调用。并基于此封装了IO、事件、网络、多线等等框架，所以业务层无需关心底层实现，直接调用封装好的框架即可。\n6.2. 高内聚低耦合 高内聚\n项目采用清晰的分层架构，将相关功能聚集在对应的模块中。每个库模块都专注于特定的功能领域，如 base 模块负责基础事件处理和日志功能，net 模块专门处理网络通信，platform 模块集中处理平台相关功能。平台特定的实现代码按操作系统进行分组，Windows、macOS、Linux 的相关代码分别聚集在对应的文件中，这种组织方式确保了同一平台的相关功能具有高内聚性。每个模块内部的功能高度相关，例如 base 模块集中了事件处理、日志记录、作业调度等核心基础功能。\n低耦合\n接口与实现完全分离\n项目大量使用抽象接口，所有接口都继承自统一的基类 IInterface，这种设计确保了依赖抽象而非具体实现，实现了低耦合。以线程接口为例，通过IArchMultithread接口定义了跨平台的统一抽象，各平台的具体实现通过继承该接口来提供功能，核心业务逻辑与平台相关代码完全解耦，如果有需要可以优化/修改平台层代码而不影响业务层代码。\n事件驱动的松耦合架构\n系统采用事件队列机制实现组件间通信，通过 IEventQueue 接口定义事件处理能力。组件间通过事件进行异步交互，避免了直接依赖。\n网络通信的抽象化\n网络层通过 ISocket 等接口定义统一的网络通信抽象，将具体的 TCP、SSL 实现与上层业务逻辑解耦。\n依赖注入\n抽象基类 PlatformScreen 通过构造函数注入依赖，接受 IEventQueue* 参数，这也降低了组件间的耦合度。\n6.3. 重用原则 模块化的库结构设计\n项目采用了高度模块化的架构，将功能分解为多个独立的静态库，实现了代码的最大化重用。整个源码被组织成arch、base、client、common、deskflow、gui、io、mt、net、platform、server等多个库模块，每个库都有明确的职责边界，可以被多个应用程序重用。\n接口抽象和继承体系\n项目建立了完整的接口抽象体系，所有接口类都继承自统一的基础接口IInterface。这种设计确保了接口的一致性，使得不同的具体实现可以通过相同的接口被重用。\n平台抽象层的重用设计\n项目通过平台抽象层实现了跨平台的代码重用。例如，IPlatformScreen接口定义了平台无关的屏幕操作方法，而具体的实现则针对不同平台分别提供。构建系统根据目标平台自动选择相应的实现文件。\n工厂模式的应用\n客户端和服务端都使用工厂模式来创建平台特定的屏幕实现。ClientApp::createScreen()方法根据编译时的平台宏定义，创建相应的平台实现（如MSWindowsScreen、OSXScreen、XWindowsScreen或EiScreen）。服务端也采用了相同的模式。\n共享组件的重用\n项目中的核心组件如事件队列（EventQueue）、网络通信（TCPSocket）等被设计为可重用的共享组件。客户端和服务端应用程序都链接相同的基础库集合，实现了代码的高度重用。\n","date":"2025-03-02T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E5%92%8C%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/","title":"Deskflow 项目功能和整体架构介绍"},{"content":" 1. 中序遍历 2. 后序遍历 二叉树遍历中，以根节点的顺序为准，例如“根 —\u0026gt; 左 —\u0026gt; 右”就是前序遍历，“左 —\u0026gt; 右 —\u0026gt; 根”就是后序遍历，从左到右一层一层的遍历就是层序遍历。Linux红黑树主要提供中序和后序两种方法。\n1. 中序遍历 左 —\u0026gt; 根 —\u0026gt; 右\n1 2 3 4 struct rb_node *rb_first(const struct rb_root *); // 中序遍历的最小节点，最左边 struct rb_node *rb_last(const struct rb_root *); // 中序遍历的最大节点，最右边 struct rb_node *rb_next(const struct rb_node *); // 中序遍历的后继节点 struct rb_node *rb_prev(const struct rb_node *); // 中序遍历的前驱节点 找到最小节点：\n1 2 3 4 5 6 7 8 9 10 11 struct rb_node *rb_first(const struct rb_root *root) { struct rb_node\t*n; n = root-\u0026gt;rb_node; if (!n) return NULL; while (n-\u0026gt;rb_left) // 没有左孩子就对了 n = n-\u0026gt;rb_left; return n; } 找到最大节点：\n1 2 3 4 5 6 7 8 9 10 11 struct rb_node *rb_last(const struct rb_root *root) { struct rb_node\t*n; n = root-\u0026gt;rb_node; if (!n) return NULL; while (n-\u0026gt;rb_right) // 没有右孩子就对了 n = n-\u0026gt;rb_right; return n; } node的后继节点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct rb_node *rb_next(const struct rb_node *node) { struct rb_node *parent; if (RB_EMPTY_NODE(node)) return NULL; if (node-\u0026gt;rb_right) { // 1. 如果node有右子树，下一个节点就是右子树中最左节点。 node = node-\u0026gt;rb_right; while (node-\u0026gt;rb_left) node = node-\u0026gt;rb_left; return (struct rb_node *)node; } // 2. 没有右子树，需要向上回溯，并更新当前节点以及其父节点，直到找到一个父节点，当前node节点是父节点的左孩子，这个父节点就是要找到后继节点，这是搜索二叉树的排序性质。 while ((parent = rb_parent(node)) \u0026amp;\u0026amp; node == parent-\u0026gt;rb_right) node = parent; return parent; } 前驱节点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct rb_node *rb_prev(const struct rb_node *node) { struct rb_node *parent; if (RB_EMPTY_NODE(node)) return NULL; if (node-\u0026gt;rb_left) { // 1. 如果node有左子树，左子树中的最右节点就是后继节点 node = node-\u0026gt;rb_left; while (node-\u0026gt;rb_right) node = node-\u0026gt;rb_right; return (struct rb_node *)node; } // 2. node没有左子树，需要向上回溯，并更新当前节点以及其父节点，直到找到一个父节点，当前的node节点是父节点的右节点，这个父节点就是要找到后继节点。 while ((parent = rb_parent(node)) \u0026amp;\u0026amp; node == parent-\u0026gt;rb_left) node = parent; return parent; } 2. 后序遍历 左 —\u0026gt; 右 —\u0026gt; 根\n1 2 struct rb_node *rb_first_postorder(const struct rb_root *); // 获取红黑树后序遍历的第一个节点，要符合“左 —\u0026gt; 右 —\u0026gt; 根”的规则 struct rb_node *rb_next_postorder(const struct rb_node *); // 获取当前节点在后序遍历中的后继节点 获取红黑树后序遍历的第一个节点： 和中序遍历是一个节点。\n1 2 3 4 5 6 7 struct rb_node *rb_first_postorder(const struct rb_root *root) { if (!root-\u0026gt;rb_node) return NULL; return rb_left_deepest_node(root-\u0026gt;rb_node); // 找到树左侧的最深节点。 } 后序遍历中的后继节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct rb_node *rb_next_postorder(const struct rb_node *node) { const struct rb_node *parent; if (!node) return NULL; parent = rb_parent(node); if (parent \u0026amp;\u0026amp; node == parent-\u0026gt;rb_left \u0026amp;\u0026amp; parent-\u0026gt;rb_right) { // node是父节点的左孩子，由于 “左 —\u0026gt; 右 —\u0026gt; 根” 的要求，所以到父节点的右子树中，寻找左侧的最深节点 return rb_left_deepest_node(parent-\u0026gt;rb_right); } else { // 1. 父节点是NULL，说明node是根节点，此时返回NULL。 // 2. 父节点没有右子树，后继节点就是父节点。 // 3. node是父节点的右孩子，后继节点就是父节点。 return (struct rb_node *)parent; } } 给定一个节点，找到该节点左侧的最深节点\n1 2 3 4 5 6 7 8 9 10 11 12 static struct rb_node *rb_left_deepest_node(const struct rb_node *node) { // 遍历中，如果节点有左子树，那就进入左子树，如果没有左子树，那就进入右子树，直到找到一个没有孩子的节点 for (;;) { if (node-\u0026gt;rb_left) node = node-\u0026gt;rb_left; else if (node-\u0026gt;rb_right) node = node-\u0026gt;rb_right; else return (struct rb_node *)node; } } 内核中没有用搜到后序遍历的使用，等以后需要的时候再去研究。\n","date":"2025-02-24T00:00:00Z","permalink":"https://zuoco.github.io/p/06-linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91-%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81/","title":"06 — Linux内核数据结构 — 红黑树 — 遍历（代码）"},{"content":"1. 插入节点的用户接口 红黑树第一篇讲到调用插入函数rb_add插入节点时会调用两个重要函数，rb_link_node，rb_insert_color。其中rb_link_node用来将新节点链接到树中，而rb_insert_color用来在插入后修复平衡。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // less: 用户节点的排序逻辑 static __always_inline void rb_add(struct rb_node *node, struct rb_root *tree, bool (*less)(struct rb_node *, const struct rb_node *)) { struct rb_node **link = \u0026amp;tree-\u0026gt;rb_node; struct rb_node *parent = NULL; // 如果 node 小于 parent，向左子树移动；否则向右子树移动，直到 *link 为 NULL，就是要插入的位置。 while (*link) { parent = *link; if (less(node, parent)) link = \u0026amp;parent-\u0026gt;rb_left; else link = \u0026amp;parent-\u0026gt;rb_right; } rb_link_node(node, parent, link); // 将节点连接到树中 rb_insert_color(node, tree);\t// 修复平衡 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /**\t* 将新节点链接到红黑树中，将新节点 node 链接到红黑树中，作为 parent 的子节点，并更新 rb_link 指向新节点。 */ static inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link) { node-\u0026gt;__rb_parent_color = (unsigned long)parent; // 保存父节点信息 node-\u0026gt;rb_left = node-\u0026gt;rb_right = NULL; // 初始化新节点 *rb_link = node; } // 在 RCU（Read-Copy-Update）同步模型下，将新节点 node 链接到红黑树中。 // 用于需要 RCU 保护的红黑树插入操作，如并发读写场景。 static inline void rb_link_node_rcu(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link) { node-\u0026gt;__rb_parent_color = (unsigned long)parent; node-\u0026gt;rb_left = node-\u0026gt;rb_right = NULL; rcu_assign_pointer(*rb_link, node); } 重点函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 // tools/lib/rbtree.c // 新节点默认初始化为红色。 void rb_insert_color(struct rb_node *node, struct rb_root *root) { __rb_insert(node, root, dummy_rotate); } /**\t* node，新插入的节点。 * augment_rotate，这是给增强型红黑树用的，在非增强型红黑树中只是传入一个占位符，无需理会。 */ static __always_inline void __rb_insert(struct rb_node *node, struct rb_root *root, void (*augment_rotate)(struct rb_node *old, struct rb_node *new)) { struct rb_node *parent = rb_red_parent(node); // 获取当前节点的父节点指针。 struct rb_node *gparent, *tmp； while (true) { /** * Case1, 插入节点为根节点。 将其设为黑色，结束循环。 * unlikely使用了linux上的一种性能优化手段，我们暂时理解为将“!parent”转换为bool值。 */ if (unlikely(!parent)) { rb_set_parent_color(node, NULL, RB_BLACK); break; } /** * Case2, 父节点是黑色，无需修复（性质未被破坏），退出。 */ if(rb_is_black(parent)) break; /**\t* Case3, 父节点是红色，代码能走到这里，说明父节点是红色（需修复） * 这里有分为几种子情况讨论 */ gparent = rb_red_parent(parent); tmp = gparent-\u0026gt;rb_right; // 获取叔节点 /* Case3-1： 父节点是祖父节点的左子节点 */ if (parent != tmp) { /* Case3-1-1： 叔叔是红色 */ if (tmp \u0026amp;\u0026amp; rb_is_red(tmp)) { // 进行颜色平衡 rb_set_parent_color(tmp, gparent, RB_BLACK); // 将叔节点设置为黑色。 rb_set_parent_color(parent, gparent, RB_BLACK); // 将父节点设置为黑色。 // 设置了叔节点和父节点的颜色，相应也要更新祖父节点的颜色 node = gparent; // 当前节点更新到祖父节点 parent = rb_parent(node); rb_set_parent_color(node, parent, RB_RED); // 将祖父节点设置为红色。 continue; // 上面是这种局部修复可能会导致整体的不平衡，所以还要继续向上递归检查。 } /* Case3-1-2： 叔节点是黑色的 */ tmp = parent-\u0026gt;rb_right; /**\t* Case3-1-2-1：新插入的节点是父节点的右子节点； * 注意了Case3-1-2-1和Case3-1-2-2的代码合起来才是完整的Case3-1-2-1逻辑； * Case3-1-2-2包含了Case3-1-2-1需要的部分旋转以及节点提升的逻辑。 */ if (node == tmp) { tmp = node-\u0026gt;rb_left; WRITE_ONCE(parent-\u0026gt;rb_right, tmp); WRITE_ONCE(node-\u0026gt;rb_left, parent); if (tmp) { rb_set_parent_color(tmp, parent, RB_BLACK); } rb_set_parent_color(parent, node, RB_RED); augment_rotate(parent, node); parent = node; tmp = node-\u0026gt;rb_right; } /* Case3-1-2-2：新插入的节点是父节点的左子节点 */ WRITE_ONCE(gparent-\u0026gt;rb_left, tmp); WRITE_ONCE(parent-\u0026gt;rb_right, gparent); if (tmp) { rb_set_parent_color(tmp, gparent, RB_BLACK); } __rb_rotate_set_parents(gparent, parent, root, RB_RED); // 提升parent节点（parent和gparent交换了身份），以及对应的颜色变换 augment_rotate(gparent, parent); break; } else /* Case3-2： 父节点是祖父节点的右子节点 */ { tmp = gparent-\u0026gt;rb_left; /* Case3-2-1: 叔叔节点是红色的, 只需要变色操作 */ if (tmp \u0026amp;\u0026amp; rb_is_red(tmp)) { rb_set_parent_color(tmp, gparent, RB_BLACK); rb_set_parent_color(parent, gparent, RB_BLACK); node = gparent; parent = rb_parent(node); rb_set_parent_color(node, parent, RB_RED); continue; } tmp = parent-\u0026gt;rb_left; /* Case3-2-2: 叔叔节点是黑色的, 需要“旋转 + 变色”操作 */ if (node == tmp) { /* Case3-2-2-1: 新节点是父节点的左子节点, 需要“右旋 + 变色”操作。和Case3-1-2类似，这里的部分逻辑在Case3-2-2-2 */ tmp = node-\u0026gt;rb_right; WRITE_ONCE(parent-\u0026gt;rb_left, tmp); WRITE_ONCE(node-\u0026gt;rb_right, parent); if (tmp) rb_set_parent_color(tmp, parent, RB_BLACK); rb_set_parent_color(parent, node, RB_RED); augment_rotate(parent, node); parent = node; tmp = node-\u0026gt;rb_left; } /* Case3-2-2-2: 新节点是父节点的右孩子, 需要“左旋 + 变色”操作 */ WRITE_ONCE(gparent-\u0026gt;rb_right, tmp); WRITE_ONCE(parent-\u0026gt;rb_left, gparent); if (tmp) rb_set_parent_color(tmp, gparent, RB_BLACK); __rb_rotate_set_parents(gparent, parent, root, RB_RED); augment_rotate(gparent, parent); break; } } } ","date":"2025-02-17T00:00:00Z","permalink":"https://zuoco.github.io/p/05-linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91-%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E4%BB%A3%E7%A0%81/","title":"05 — Linux内核数据结构 — 红黑树 — 插入节点（代码）"},{"content":" 1. 增强型与非增强型 2. 插入节点 2.1. 插入节点是根节点 2.2. 父节点是黑色的 2.3. 父节点是红色的 2.3.1. 父节点是祖父节点的左子节点 2.3.2. 父节点是祖父节点的右子节点 1. 增强型与非增强型 Linux 内核中的红黑树（Red-Black Tree）提供了两种实现方式：\n非增强型（Non-augmented）：仅维护基本的树结构。 增强型（Augmented）：在节点中维护额外信息（如子树大小、区间范围等），支持更复杂操作。 为了统一接口并减少代码冗余，rb_insert_color() 和 rb_erase() 使用通用的增强型实现，但在非增强场景中通过 虚拟回调函数（dummy callbacks） 和 编译器优化 来避免性能开销。\n1 2 3 4 5 6 /** * 所有函数声明为 static inline，且函数体为空，用于在非增强场景中作为增强回调函数的占位符。 */ static inline void dummy_propagate(struct rb_node *node, struct rb_node *stop) {} static inline void dummy_copy(struct rb_node *old, struct rb_node *new) {} static inline void dummy_rotate(struct rb_node *old, struct rb_node *new) {} 本片只记录非增强型。\n2. 插入节点 上一篇章的红黑树示意图中，提到4个特征，插入节点时可能会破坏这4个特征中的一个或多个，此时就需要进行恢复。考虑到新节点是红色的，我们分为下面三种情况（Linux红黑树平衡逻辑）进行讨论：\nCase1 插入节点是根节点 Case2 插入节点的父节点是黑色的 Case3 插入节点的父节点是红色的 Case3-1 父节点是祖父节点的左子节点 Case3-1-1 叔叔是红色的 Case3-1-2 叔叔是黑色的（Case3-1-2-1、Case3-1-2-2） Case3-2 父节点是祖父节点的右子节点 Case3-2-1 叔叔是红色的 Case3-2-2 叔叔是黑色的（Case3-2-2-1、Case3-2-2-2） 2.1. 插入节点是根节点 直接将节点改为黑色就完事了，如果插入节点不是根节点，那就看叔叔节点的颜色。\n2.2. 父节点是黑色的 平衡没有破坏，直接返回。\n2.3. 父节点是红色的 根据父节点是祖父节点的左孩子还是右孩子分为两种情况讨论。\n2.3.1. 父节点是祖父节点的左子节点 Case3-1-1 叔叔节点是红色的 只需变色操作，每次修复后，cur_node都要更新到爷爷节点，并再次判断平衡是否有破坏，也就是将之前的祖父节点作为cur_node，同样parent，gparent也要更新。 Case3-1-2 叔叔节点是黑色的 此时有分为两种情况 ： 新节点是父节点的左孩子、新节点是父节点的右还是。\n新节点是父节点的右孩子 : 左旋 + 右旋 + 变色 新节点是父节点的左孩子 : 右旋 + 变色 2.3.2. 父节点是祖父节点的右子节点 Case3-2-1 叔叔节点是红色的\n只需变色操作，每次修复后，cur_node都要更新到爷爷节点，并再次判断平衡是否有破坏，也就是将之前的祖父节点作为cur_node，同样parent，gparent也要更新。 Case3-2-2 叔叔节点是黑色的\n新节点是父节点的右孩子 : 左旋 + 变色 新节点是父节点的左孩子 ","date":"2025-02-14T00:00:00Z","permalink":"https://zuoco.github.io/p/04-linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91-%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E4%B8%8E%E5%B9%B3%E8%A1%A1%E5%8E%9F%E7%90%86/","title":"04 — Linux内核数据结构 — 红黑树 — 插入节点与平衡（原理）"},{"content":" 1. 移除节点的用户接口 2.1. __rb_erase_color() 1. 移除节点的用户接口 rb_erase()： include/linux/rbtree.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 extern void rb_erase(struct rb_node *, struct rb_root *); /** * tools/lib/rbtree.c * 移除黑色节点会导致经过该节点的路径所包含的黑节点比其他路径少一个，破坏了平衡。 * 当被删除节点（node）有左右孩子时间，需要使用后继节点（successor）来填补node的位置，此时问题就变成了“删除后successor”。 */ void rb_erase(struct rb_node *node, struct rb_root *root) { struct rb_node *rebalance; /** * rb_erase_augmented 完成两件事： * 1. 执行节点删除操作，node； * 2. 该函数会完成一部分简单的平衡任务，如果没有完全平衡就返回一个节点地址，返回的节点地址有两种情况： * a. node没有孩子，且是黑色，返回node的父节点。 * b. node有左右孩子，并且后继节点是黑色，返回后继节点的父节点。 */ rebalance = __rb_erase_augmented(node, root, \u0026amp;dummy_callbacks); // 完成部分平衡修复工作 if (rebalance) { // 进一步完成平衡 ____rb_erase_color(rebalance, root, dummy_rotate); } } __rb_erase_augmented()： 删除节点，并完成初步的平衡工作，尽可能在该函数内完成平衡，如果情况简单，该函数内部就完成了，就返回NULL，如果情况比较复杂，该函数内部只能完成部分，就返回待平衡节点地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 /* tools/lib/rbtree.c */ static __always_inline struct rb_node * __rb_erase_augmented(struct rb_node *node, struct rb_root *root, const struct rb_augment_callbacks *augment) { struct rb_node *child = node-\u0026gt;rb_right; struct rb_node *tmp = node-\u0026gt;rb_left; struct rb_node *parent, *rebalance; unsigned long pc; /* if {没有孩子/只有右孩子} else if {只有左孩子} else {两个孩子都在} */ if (!tmp) { /** * Case 0: 被删除节点有右孩子或者没有孩子， 如果有孩子只能是红色。 * !tmp == true也就是tmp == NULL，没有左孩子，那就剩下两种情况了：“只有右孩子”、“没有孩子”。 */ pc = node-\u0026gt;__rb_parent_color; // 获取被删除节点的父节点指针 parent = __rb_parent(pc); // 获取被删除节点的父节点指针 __rb_change_child(node, child, parent, root); // parent的子节点从node改为child: (A -\u0026gt; B -\u0026gt; C) 变为 （A -\u0026gt; C） /* 根据有没有孩子决定要不要在本函数内部修复平衡 */ if (child) { // Case1: 只有红色右孩子，此时孩子变色即可，本函数内部修复。 child-\u0026gt;__rb_parent_color = pc; // child的父节点指针指向自己的祖父节点， 同时颜色被置为与父节点同色（黑色）。 rebalance = NULL; // 不再需要额外修复。 } else { // Case2: 没有孩子，且为节点为黑色（删除红色节点不会破环平衡）， // 此时的平衡修复工作量大，所以返回rebalance给__rb_erase_color()，由__rb_erase_color()进行修复。 rebalance = __rb_is_black(pc) ? parent : NULL; } tmp = parent; } else if (!child) { /** * Case 3: 被删除节点只有左孩子，此时孩子也只能是红色。 */ // 经过下面上行函数： parent \u0026lt;--\u0026gt; node \u0026lt;--\u0026gt; tmp 变为 parent \u0026lt;--\u0026gt; tmp tmp-\u0026gt;__rb_parent_color = pc = node-\u0026gt;__rb_parent_color; // 原本 node \u0026lt;-- tmp，现在 parent \u0026lt;-- tmp，并且tmp颜色设置为node同色(本函数内部恢复平衡)。 parent = __rb_parent(pc); __rb_change_child(node, tmp, parent, root); // 原本 parent --\u0026gt; node，现在 parent --\u0026gt; tmp rebalance = NULL; tmp = parent; } else { /** * Case 4: 被删除节点有左右孩子，此时需要使用“后继节点”替换将要被删除的节点。 * if-else 语句块处理被删除节点的右子树。 */ struct rb_node *successor = child, *child2; /* 选择后继节点，也就是右子树中的最大节点（最左节点）。 */ tmp = child-\u0026gt;rb_left; if (!tmp) { /* * Case 4-1: 如下图，被删除节点（n），因为s没有左子树，所以n的右子树中最大就是s。 * * (n) (s) * / \\ / \\ * (x) (s) -\u0026gt; (x) (c) * \\ * (c) */ parent = successor; // 上图中的 s child2 = successor-\u0026gt;rb_right; // 上图中的 c augment-\u0026gt;copy(node, successor); } else { /* * Case 4-2: 如下图，被删除节点（n），因为s有左子树，所以n的右子树中最大就是s。 * * (n) (s) * / \\ / \\ * (x) (y) -\u0026gt; (x) (y) * / / * (p) (p) * / / * (s) (c) * \\ * (c) */ do { // 在被删除节点的右子树中，沿着最左边沿一直找，找到最左边的节点，就是被删除节点的右子树中的最大节点。 parent = successor; successor = tmp; tmp = tmp-\u0026gt;rb_left; } while (tmp); /** * 找到了后继节点，由于后继节点是最左节点，所以它没有左子树，只有右子树。 * parent --\u0026gt; p, * successor --\u0026gt; s, * child2 --\u0026gt; c, */ child2 = successor-\u0026gt;rb_right; WRITE_ONCE(parent-\u0026gt;rb_left, child2); // p --\u0026gt; c WRITE_ONCE(successor-\u0026gt;rb_right, child); // s --\u0026gt; y rb_set_parent(child, successor); // child的父节点设置为successor，y --\u0026gt; s，同时保留y的颜色 augment-\u0026gt;copy(node, successor); augment-\u0026gt;propagate(parent, successor); } /* 处理node的左子树 */ tmp = node-\u0026gt;rb_left; // 被删除节点的左子树的 WRITE_ONCE(successor-\u0026gt;rb_left, tmp); // 原本 node --\u0026gt; tmp，现在successor --\u0026gt; tmp rb_set_parent(tmp, successor); // tmp --\u0026gt; successor pc = node-\u0026gt;__rb_parent_color; tmp = __rb_parent(pc); // node的父节点 __rb_change_child(node, successor, tmp, root); // 原本 tmp(pc) --\u0026gt; node，现在 tmp(pc) --\u0026gt; successor。 /**\t* 因为 successor 是 node 的右子树中的最左节点，所以它必然没有左孩子，但是右孩子就不一定了。 * 如果有右孩子，那么这该节点一定是红色的，否则这棵树中经过node节点的路径说包含的黑色节点数量不同了。 * 如果没有右孩子，这个节点可能是红色，也可能是黑色：if {有孩子} else {没有孩子}。 */ if (child2) { // successor 有右孩子（child2是后继节点的右子树） successor-\u0026gt;__rb_parent_color = pc; // successor继承node的父节点和颜色： successor --\u0026gt; tmp， 颜色也设置为和node同色。 rb_set_parent_color(child2, parent, RB_BLACK); // child2 --\u0026gt; parent，并将child2的颜色设置为黑色。 rebalance = NULL; } else { // successor 没有右孩子 unsigned long pc2 = successor-\u0026gt;__rb_parent_color; successor-\u0026gt;__rb_parent_color = pc; /** * 如果successor是红色，删除它不影响平衡； * 如果successor是黑色，删除它会破坏平衡，需要修复平衡。 */ rebalance = __rb_is_black(pc2) ? parent : NULL; } tmp = successor; } augment-\u0026gt;propagate(tmp, NULL); return rebalance; } __rb_erase_color()： 在__rb_erase_augmented()之后调用，进一步完成平衡工作。\n1 2 3 4 5 6 7 static __always_inline void ____rb_erase_color(struct rb_node *parent, struct rb_root *root, void (*augment_rotate)(struct rb_node *old, struct rb_node *new)) { // 和 rb_insert_color() 的流程差不多 // 根据parent的兄弟节点的颜色分布，分情况讨论。 } ","date":"2025-02-09T00:00:00Z","permalink":"https://zuoco.github.io/p/03-linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91-%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9%E4%BB%A3%E7%A0%81/","title":"03 — Linux内核数据结构 — 红黑树 — 移除节点（代码）"},{"content":" 1. 删除节点的并平衡的整体思路 2. 删除黑色节点 2.1. 兄弟是黑色 2.2. 兄弟是红的 3. 其他 1. 删除节点的并平衡的整体思路 移除节点分为集中情况，如下图所示：\n比较麻烦的是Case2-2和Case4-2-2，Case2-2就是删除一个黑色节点（node），导致经过node节点的路径中黑节点少了一个，这违反了红黑树的平衡特性。而Case4-2-2需要使用后继节点（successor）替补被删除的节点，相当将successor从它原本的位置删除，也就说转换为删除黑色节点的问题了。\nCase4中，后继节点就是node在右子树中的最大节点（最左节点），所以后继节点肯定没有左孩子，可能有右孩子，也可能孑然一身。如果有右孩子，那一定是“黑——红”布局，就是说successor是黑色的，它的右孩子是红色的，否则会破坏第一篇章的特征2。\n下面主要讲解删除黑色节点的情况。\n2. 删除黑色节点 删除后会破坏特征2，也就所说经过该节点的路径都少一个黑节点，此时要根据兄弟节点的颜色分为2种情况讨论： 兄弟是黑的、兄弟是红的。\n2.1. 兄弟是黑色 兄弟节点至少一个红孩子：\n兄弟节点两个孩子都是黑孩： 其他类型和前面的类似。 前面展示的情形中，被删除节点的父节点都是黑色的，如果是红色的只需要变色即可，如下所示： 2.2. 兄弟是红的 总结为：变色 + 旋转 + 变色。\n3. 其他 如果要删除的节点的父节点是根节点，此时只需要把要删除的节点的兄弟节点变成红色即可。\n","date":"2025-02-07T00:00:00Z","permalink":"https://zuoco.github.io/p/02-linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91-%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9%E4%B8%8E%E5%B9%B3%E8%A1%A1%E5%8E%9F%E7%90%86/","title":"02 — Linux内核数据结构 — 红黑树 — 移除节点与平衡（原理）"},{"content":" 1. 什么是红黑树 2. Linux内核红黑树源码 2.1. 节点 2.2. 树 2.3. 红黑树操作 1. 什么是红黑树 红黑树的基本形态如下：\n首先阅读一下比较正式的定义：“红黑树是一种平衡二叉查找树，它在二叉搜索树的基础上，通过附加的规则和操作（变色和旋转）来维持树的相对平衡，从而保证在最坏情况下基本操作（查找、插入、删除）的时间复杂度为O(log n)”。这里面有一些概念，例如二叉树、二叉（搜索）树、平衡。\n搜索树： 就是通过优化节点的排序，使得树可以使用二分法高效的搜索，说白了就是一种专门用于搜索的树结构。要想使用二分搜索，就需要节点满足：左节点 \u0026lt; 当前节点 \u0026lt; 右节点（中序遍历结果为升序），如此一来，在搜索中就可以选择进入左子树还是右子树。 平衡： 二叉搜索树在数次插入和删除操作后，可能就变形了，变长了近似链表的结构，此时树的操作时间复杂度就可能变成了O(n)，也就是这颗树变成了一个高度为n，没有树杈的光杆司令，上图中的黄色背景是红黑树的特征，当树结构不符合特征时，就会触发修复操作（变色、旋转），修复的结果就是使得树更加的矮胖。 树高: 红黑树的颜色规定，实际上是约束树的高度，尤其是特征2，任意一个节点，可能有多条路径到达叶子节点，由于黑色节点的数量必须相同，所以多条路径之间的高度相差不会不大(2倍)，最短路径就是没有红节点，最长路径就是红节点最多，但是由于红节不能连续，所以只能红黑相间，也就是数量一样多。 2. Linux内核红黑树源码 2.1. 节点 源文件： /include/linux/rbtree_types.h\n1 2 3 4 5 6 7 8 9 10 11 // 节点结构 struct rb_node { unsigned long __rb_parent_color; // 用最低位来表示本节点的颜色（0 表示红色，1 表示黑色），而其余高位用于存储父节点的地址。 struct rb_node *rb_right; struct rb_node *rb_left; } __attribute__((aligned(sizeof(long)))); // 根节点结构 struct rb_root { struct rb_node *rb_node; }; 节点定义的是树的链接关系，不包含用户数据。实际使用中需要定义一个用户结构（user_data），用户结构中包含节点(node)和用户数据(data)。 同样，树结构中也是只有节点，树结构本身不管理用户数据，当我们遍历树并访问用户数据(data)时，就需要先找到树中的节点node，然后根据node地址找到user_data的地址，然后使用./-\u0026gt;来访问用户结构中的data成员。 2.2. 树 源文件: /include/linux/rbtree_types.h\n1 #define RB_ROOT (struct rb_root) { NULL, } // 创建一个空树 2.3. 红黑树操作 提取出父节点的地址（去除颜色信息），父节点地址和当前节点的颜色保存在一个unsigned long成员中：\n源文件： /include/linux/rbtree.h\n1 2 3 4 5 /** * r 是一个指向红黑树节点的指针。 * 3 的二进制表示为 000...0011，因此 ~3 是 111...1100，即掩码掉最低两位。 */ #define rb_parent(r) ((struct rb_node *)((r)-\u0026gt;__rb_parent_color \u0026amp; ~3)) 从树节点指针获取包含它的用户结构体指针： 通过树的节点地址获取用户节点地址：\n1 2 3 4 5 6 7 8 9 10 /** * 只是封装了container_of() */ #define\trb_entry(ptr, type, member) container_of(ptr, type, member) // 安全版本，ptr为空指针时，直接返回NULL #define rb_entry_safe(ptr, type, member) \\ ({ typeof(ptr) ____ptr = (ptr); \\ ____ptr ? rb_entry(____ptr, type, member) : NULL; \\ }) 因为树的节点是用户节点的成员，所以知道树节点地址就可以使用container_of找到用户节点的地址，然后使用./-\u0026gt;方法访问用户节点的成员。\n判断树是否为空：\n1 2 3 4 /** * READ_ONCE()使用volatile直接从内存中读取变量值。 */ #define RB_EMPTY_ROOT(root) (READ_ONCE((root)-\u0026gt;rb_node) == NULL) 判断给定节点是否已经插入树中：\n1 2 3 4 5 /** * 当节点未被插入树时，__rb_parent_color 被设置为节点自身的地址（即 (unsigned long)(node)），因此通过比较可以判断节点状态。 */ #define RB_EMPTY_NODE(node) \\ ((node)-\u0026gt;__rb_parent_color == (unsigned long)(node)) 将节点标记为空节点： 移除节点后使用：\n1 2 3 4 5 /** * 通常在节点被移除红黑树后调用此宏，确保其状态被重置，避免重复插入或未定义行为。 */ #define RB_CLEAR_NODE(node) \\ ((node)-\u0026gt;__rb_parent_color = (unsigned long)(node)) 插入新节点：\n1 2 3 // less: 用户节点的排序逻辑， // 将node插入到树中，并修复平衡。 void rb_add(struct rb_node *node, struct rb_root *tree, bool (*less)(struct rb_node *, const struct rb_node *)); 移除节点：\n1 2 3 4 /** * 从红黑树中删除指定节点，并修复树的平衡性。 */ void rb_erase(struct rb_node *, struct rb_root *); 树遍历：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 中序遍历 */ extern struct rb_node *rb_next(const struct rb_node *); // 中序后继节点 extern struct rb_node *rb_prev(const struct rb_node *); // 中序前驱节点 extern struct rb_node *rb_first(const struct rb_root *); // 树中的第一个节点（最小值节点） extern struct rb_node *rb_last(const struct rb_root *); // 树中的最后一个节点（最大值节点） /* 也提供了后序遍历 */ extern struct rb_node *rb_first_postorder(const struct rb_root *); // 返回红黑树中后序遍历的第一个节点（最左的叶子节点）。 extern struct rb_node *rb_next_postorder(const struct rb_node *); // 返回当前节点的后序后继节点。 /** * 以 后序遍历 的方式安全地遍历红黑树（rb_root），允许在遍历过程中删除当前节点（pos，包含树节点的用户节点）。 */ #define rbtree_postorder_for_each_entry_safe(pos, n, root, field) \\ for (pos = rb_entry_safe(rb_first_postorder(root), typeof(*pos), field); \\ pos \u0026amp;\u0026amp; ({ n = rb_entry_safe(rb_next_postorder(\u0026amp;pos-\u0026gt;field), typeof(*pos), field); 1; }); \\ // 判断当前用户节点是否为NULL，并且缓存下一个用户节点，以便于安全删除当前节点 pos = n) 后续遍历用于依赖子节点的处理顺序，例如释放资源，先释放子节点，再释放父节点。 中序遍历用于有序访问（如最小值到最大值）。 { n = rb_entry_safe(rb_next_postorder(\u0026amp;pos-\u0026gt;field), typeof(*pos), field); 1; }，使用了GCC的扩展语法 —— 复合语句表达式：{expression; 1;};,始终返回1。 替换节点： 直接替换节点，无需重新平衡树：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 将 victim 节点从红黑树中替换为 new 节点。 * 内部使用原子操作，无需锁保护。 * 适用于非 RCU 环境，用于普通上下文（如进程上下文）。 * new 必须与 victim 具有相同的子节点和颜色，否则可能破坏红黑树的性质。 */ extern void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root); /** * 在 RCU（Read-Copy-Update）环境中替换节点。 * 允许在替换过程中存在读者，通过 RCU 机制确保旧节点在读者完成访问后才被释放。 * 适用于 RCU 上下文，如中断上下文或需要无锁并发的场景。 */ extern void rb_replace_node_rcu(struct rb_node *victim, struct rb_node *new, struct rb_root *root); 查找节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * 查找与 node 等价的节点 * 若找到，返回匹配的节点。 * 若未找到，将 node 插入树中，并返回 NULL。 */ static __always_inline struct rb_node * rb_find_add(struct rb_node *node, struct rb_root *tree, int (*cmp)(struct rb_node *, const struct rb_node *)) { struct rb_node **link = \u0026amp;tree-\u0026gt;rb_node; struct rb_node *parent = NULL; int c; while (*link) { parent = *link; c = cmp(node, parent); if (c \u0026lt; 0) link = \u0026amp;parent-\u0026gt;rb_left; else if (c \u0026gt; 0) link = \u0026amp;parent-\u0026gt;rb_right; else return parent; } // 插入节点，并平衡 rb_link_node(node, parent, link); rb_insert_color(node, tree); return NULL; } 仅查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * 返回匹配的节点指针，若未找到，返回 NULL。 */ static __always_inline struct rb_node * rb_find(const void *key, const struct rb_root *tree, int (*cmp)(const void *key, const struct rb_node *)) { struct rb_node *node = tree-\u0026gt;rb_node; while (node) { int c = cmp(key, node); if (c \u0026lt; 0) node = node-\u0026gt;rb_left; else if (c \u0026gt; 0) node = node-\u0026gt;rb_right; else return node; } return NULL; } 查找红黑树中所有与 key 等价的节点，按中序顺序依次访问\n1 2 3 #define rb_for_each(node, key, tree, cmp) \\ for ((node) = rb_find_first((key), (tree), (cmp)); \\ (node); (node) = rb_next_match((key), (node), (cmp))) 查找与 key 等价的 最左边的节点:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * 若找到： 返回最左边的匹配节点指针。 * 若未找到：返回 NULL */ static __always_inline struct rb_node * rb_find_first(const void *key, const struct rb_root *tree, int (*cmp)(const void *key, const struct rb_node *)) { struct rb_node *node = tree-\u0026gt;rb_node; struct rb_node *match = NULL; while (node) { int c = cmp(key, node); if (c \u0026lt;= 0) { if (!c) match = node; node = node-\u0026gt;rb_left; } else if (c \u0026gt; 0) { node = node-\u0026gt;rb_right; } } return match; } 处理重复键，与 rb_next_match 配合使用，实现完整的匹配项遍历。 从当前节点 node 开始，查找与 key 等价的 下一个节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * 若找到： 返回下一个匹配的节点指针。 * 若未找到：返回 NULL。 */ static __always_inline struct rb_node * rb_next_match(const void *key, struct rb_node *node, int (*cmp)(const void *key, const struct rb_node *)) { node = rb_next(node); if (node \u0026amp;\u0026amp; cmp(key, node)) node = NULL; return node; } 处理重复键，与 rb_find_first 配合使用，实现完整的匹配项遍历。 ","date":"2025-02-05T00:00:00Z","permalink":"https://zuoco.github.io/p/01-linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E5%A2%9E%E5%BC%BA%E5%9E%8B%E7%BA%A2%E9%BB%91%E6%A0%91/","title":"01 — Linux内核数据结构 — 非增强型红黑树"},{"content":" 1. 队列定义 2. 队列操作宏 QTAILQ 是 QEMU 实现的一种尾队列（Tail Queue）结构，基于双向链表，并且维护了一个指向队列尾部的指针，使得在尾部插入操作更高效。代码位于include/qemu/queue.h。\n1. 队列定义 队列连接结构：\n1 2 3 4 typedef struct QTailQLink { void *tql_next; struct QTailQLink *tql_prev; } QTailQLink; 队列头结构定义：\n从队列头部的定义可以看出来，这个队列设计了两种模式： 正向链表模式、双向链表模式，用户可以根据需求进行实例化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* * 队列头，根据用户类型type创建一个表示队列头的类型， * 由于是联合体，初始化时使用tqh_first成员，就表示正向链表模式。 * 在循环双向链表模式下tqh_circ.tql_next和tqh_first指的是一个东西（类型为用户节点）， * 所以循环双向链表模式下会使用tqh_first读取到的数据就是tqe_circ.tql_next。 */ #define QTAILQ_HEAD(name, type) \\ union name { \\ struct type *tqh_first; \\ QTailQLink tqh_circ; \\ } /* * 链表头初始化， * 默认作为循环双向链表模式来初始化的， * prev指向自己，得到一个空的循环双向链表。 */ #define QTAILQ_HEAD_INITIALIZER(head) \\ { .tqh_circ = { NULL, \u0026amp;(head).tqh_circ } } /* * 节点的连接域，根据用户类型type创建一个表示节点连接域的类型。 * 初始化时使用的是tqe_circ成员，就是循环双向链表模式。 * 在循环双向链表模式下tqe_circ.tql_next和tqe_next指的是一个东西， * 所以循环双向链表模式下会使用tqe_next读取到的数据就是tqe_circ.tql_next。 */ #define QTAILQ_ENTRY(type) \\ union { \\ struct type *tqe_next; \\ QTailQLink tqe_circ; \\ } 工程中，用户在自定义节点结构中包含一个QTAILQ_ENTRY（UUSER_TYPE）类型的成员，创建一个队列的代码如下：\n1 2 3 4 5 6 7 8 9 10 // 用户节点结构 typedef struct Qcow2DiscardRegion { BlockDriverState *bs; uint64_t offset; uint64_t bytes; QTAILQ_ENTRY(Qcow2DiscardRegion) next; // 节点连接域 } Qcow2DiscardRegion; // 队列头部 QTAILQ_HEAD (, Qcow2DiscardRegion) discards; // discards就代表一个队列了 2. 队列操作宏 1 2 3 4 #define QTAILQ_INIT(head) do { \\ (head)-\u0026gt;tqh_first = NULL; \\ (head)-\u0026gt;tqh_circ.tql_prev = \u0026amp;(head)-\u0026gt;tqh_circ; \\ } while (/*CONSTCOND*/0) 这个没有什么好说的，和QTAILQ_HEAD_INITIALIZER宏的功能是一样的，队列初始化。\n插入节点：\n1 2 3 4 5 6 7 8 9 #define QTAILQ_INSERT_HEAD(head, elm, field) do { \\ if (((elm)-\u0026gt;field.tqe_next = (head)-\u0026gt;tqh_first) != NULL) \\ (head)-\u0026gt;tqh_first-\u0026gt;field.tqe_circ.tql_prev = \\ \u0026amp;(elm)-\u0026gt;field.tqe_circ; \\ else \\ (head)-\u0026gt;tqh_circ.tql_prev = \u0026amp;(elm)-\u0026gt;field.tqe_circ; \\ (head)-\u0026gt;tqh_first = (elm); \\ (elm)-\u0026gt;field.tqe_circ.tql_prev = \u0026amp;(head)-\u0026gt;tqh_circ; \\ } while (/*CONSTCOND*/0) head： 队列头。 elm： 用户节点对象的指针。 field： 用户节点中的节点连接域。 将给定节点（elm）插入到头部，if处理非空队列，else处理空队列。\n1 2 3 4 5 6 #define QTAILQ_INSERT_TAIL(head, elm, field) do { \\ (elm)-\u0026gt;field.tqe_next = NULL; \\ (elm)-\u0026gt;field.tqe_circ.tql_prev = (head)-\u0026gt;tqh_circ.tql_prev; \\ (head)-\u0026gt;tqh_circ.tql_prev-\u0026gt;tql_next = (elm); \\ (head)-\u0026gt;tqh_circ.tql_prev = \u0026amp;(elm)-\u0026gt;field.tqe_circ; \\ } while (/*CONSTCOND*/0) 将给定节点插入到尾部，头部维护了一个指向尾部的指针。\n1 2 QTAILQ_INSERT_AFTER(head, listelm, elm, field) // 在指定节点（listelm）后面插入 QTAILQ_INSERT_BEFORE(listelm, elm, field) // 在指定节点（listelm）前面插入 移除节点：\n1 2 QTAILQ_REMOVE(head, elm, field) // 移除指定节点，会判断该节点是否为尾节点 QTAILQ_REMOVE_SEVERAL(head, left, right, field) // 从尾队列中移除[left, right]范围内的所有节点，包含left和right节点本身，会判断right是否为尾节点。 正序遍历队列：\n1 2 QTAILQ_FOREACH(var, head, field) // 遍历尾队列（TAILQ）中的所有节点，只读场景，var用来保存当前节点以便于循环体中使用 QTAILQ_FOREACH_SAFE(var, head, field, next_var) // 安全遍历尾队列（TAILQ）中的所有节点，提前保存下一个节点（next_var），允许在遍历过程中删除当前节点后循环可以继续。 逆序遍历队列：\n1 2 QTAILQ_FOREACH_REVERSE(var, head, field) // 逆序遍历队列，只读 QTAILQ_FOREACH_REVERSE_SAFE(var, head, field, prev_var) // 逆序遍历队列，支持安全删除 访问队列：\n1 2 3 4 5 6 7 8 QTAILQ_EMPTY(head) // 判断队列是否为空 QTAILQ_IN_USE(elm, field) // 指定节点是否在队列中 QTAILQ_FIRST(head) // 获取队列的第一个节点 QTAILQ_LAST(head) // 获取队列的最后一个节点 QTAILQ_NEXT(elm, field) // 获取指定节点的下一个节点 QTAILQ_PREV(elm, field) // 获取前一个节点 ","date":"2024-11-23T00:00:00Z","permalink":"https://zuoco.github.io/p/qemu%E5%B0%BE%E9%98%9F%E5%88%97-tail-queue/","title":"Qemu尾队列 Tail Queue"},{"content":"直接使用 pip 在全局环境中安装 Python 包，会干扰系统的包管理器（如 apt）。从Python 3.11 开始引入的一项安全措施 —— 虚拟环境，旨在防止用户意外地破坏系统Python的环境。 使用方法:\n1 2 3 4 apt install python3.11-venv python3 -m venv myenv # myenv是虚拟环境的目录 # 激活虚拟环境 source myenv/bin/activate 运行source myenv/bin/activate命令后就进入了python虚拟环境中： 在虚拟环境下可以正常使用pip命令，下载的软件包位于虚拟环境中。使用完毕后执行deactivate命令推出虚拟环境。\n","date":"2024-11-12T00:00:00Z","permalink":"https://zuoco.github.io/p/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","title":"Python虚拟环境"},{"content":"1. Qemu类型系统 Qemu目前主要是C语言编写（有少量Rust），C语言没有语言层面的面向对象支持，所以Qemu开发团队就为Qemu设计了一套对象系统，我们本专题要讲的就是Qemu的对象系统。\n在Qemu代码中，我们经常看到如下代码：\n1 type_init(\u0026lt;class_name\u0026gt;_register_types); \u0026lt;class_name\u0026gt;_register_types: Qemu中定义一个类型后通过type_init宏函数来注册该类型。 下面我们就来看一下type_init宏函数的定义：\n1 2 // include/qemu/module.h #define type_init(function) module_init(function, MODULE_INIT_QOM); function: 类型注册函数; MODULE_INIT_QOM: Qemu对象模型模块; module_init也是一个宏函数，它的定义如下:\n1 2 3 4 5 #define module_init(function, type) \\ static void __attribute__((constructor)) do_qemu_init_ ## function(void) \\ { \\ register_module_init(function, type); \\ } 首先我们分析一下这个宏函数:\n使用了##，用于拼接，例如function是“cpu_register_types”，结果就是do_qemu_init_cpu_register_types，这样可以避免命名冲突，确保每个模块的注册函数独立存在。 __attribute__((constructor))，GCC的一个函数属性，由该属性标记的函数，会在main函数前面执行。 实际上，这个宏函数就是将用户设计好的类型注册到一个Hash表中，也就是type(类型名称)和function(类型注册函数)。 1.1. 类型注册 上面我们提到了register_module_init，这个函数定义如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // util/module.c void register_module_init(void (*fn)(void), module_init_type type) { ModuleEntry *e; ModuleTypeList *l; e = g_malloc0(sizeof(*e)); e-\u0026gt;init = fn; e-\u0026gt;type = type; l = find_type(type); QTAILQ_INSERT_TAIL(l, e, node); } 这个函数在main函数前就会被执行，它包含了4个知识点，下面我们一一讲解:\n1.2. ModuleEntry类型 1 2 3 4 5 6 typedef struct ModuleEntry { void (*init)(void); // 类型注册函数，就是type_init(\u0026lt;class_name\u0026gt;_register_types);中的\u0026lt;class_name\u0026gt;_register_types QTAILQ_ENTRY(ModuleEntry) node; module_init_type type; // 所属模块类型，类型系统就是MODULE_INIT_QOM } ModuleEntry; 关于\n","date":"2024-11-12T00:00:00Z","permalink":"https://zuoco.github.io/p/qemu%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8Bqom/","title":"Qemu对象模型（QOM）"},{"content":" 1. 队列定义 1.1. 使用案例 2. 队列操做 2.1. 基本访问方法 2.2. 队列初始化 2.3. 插入节点 2.3.1. 插入到头部 2.3.2. 插入到尾部 2.3.3. 插入到中间 3. 移除节点 3.1. 移除头部节点 3.2. 移除指定节点 3.3. 遍历 3.3.1. 遍历队列 3.3.2. 遍历队列（安全） 3.4. 尾节点快速定位 3.5. 队列合并 3.5.1. 合并到尾部 3.5.2. 合并到头部 3.6. 分割队列 4. 完整代码 1. 队列定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 队列头 #define QSIMPLEQ_HEAD(name, type) \\ struct name { \\ struct type *sqh_first; /* first element */ \\ struct type **sqh_last; /* addr of last next element */ \\ } // 初始化一个队列 #define QSIMPLEQ_HEAD_INITIALIZER(head) \\ { NULL, \u0026amp;(head).sqh_first } // 节点中的连接域，指向下一个节点 #define QSIMPLEQ_ENTRY(type) \\ struct { \\ struct type *sqe_next; /* next element */ \\ } 1.1. 使用案例 qemu-8.2.2/qemu-img.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // 节点类型 typedef struct ImgBitmapAction { enum ImgBitmapAct act; const char *src; /* only used for merge */ QSIMPLEQ_ENTRY(ImgBitmapAction) next; } ImgBitmapAction; // 磁盘持久化位图操作。 static int img_bitmap(int argc, char **argv) { // ...... // 省略一堆代码 // ...... // 队列头 QSIMPLEQ_HEAD(, ImgBitmapAction) actions; ImgBitmapAction *act, *act_next; const char *op; int inactivate_ret; // 初始化队列 QSIMPLEQ_INIT(\u0026amp;actions); for (;;) { // ...... switch (c) { // ...... case OPTION_ADD: act = g_new0(ImgBitmapAction, 1); act-\u0026gt;act = BITMAP_ADD; // 添加节点 QSIMPLEQ_INSERT_TAIL(\u0026amp;actions, act, next); add = true; break; // ...... } } // 判断队列是否为空 if (QSIMPLEQ_EMPTY(\u0026amp;actions)) { error_report(\u0026#34;Need at least one of --add, --remove, --clear, \u0026#34; \u0026#34;--enable, --disable, or --merge\u0026#34;); goto out; } // ...... // 遍历队列 QSIMPLEQ_FOREACH_SAFE(act, \u0026amp;actions, next, act_next) { switch (act-\u0026gt;act) { // ...... } if (err) { // ...... } g_free(act); } // ...... out: // ...... return ret; } 2. 队列操做 2.1. 基本访问方法 1 2 3 4 5 6 7 8 9 10 11 12 13 // 常规判空： 单线程环境、受锁保护的多线程临界区、性能敏感但线程安全已保障的场景。 #define QSIMPLEQ_EMPTY(head) ((head)-\u0026gt;sqh_first == NULL) // 原子判空： 无锁编程（Lock-free）场景，多线程环境无显式锁保护时，需检测队列状态变化的异步场景。 #define QSIMPLEQ_EMPTY_ATOMIC(head) \\ (qatomic_read(\u0026amp;((head)-\u0026gt;sqh_first)) == NULL) // 获取队列的首节点。 #define QSIMPLEQ_FIRST(head) ((head)-\u0026gt;sqh_first) // 获取elm的下一个节点 #define QSIMPLEQ_NEXT(elm, field) ((elm)-\u0026gt;field.sqe_next) 2.2. 队列初始化 1 2 3 4 #define QSIMPLEQ_INIT(head) do { \\ (head)-\u0026gt;sqh_first = NULL; \\ (head)-\u0026gt;sqh_last = \u0026amp;(head)-\u0026gt;sqh_first; \\ } while (/*CONSTCOND*/0) 2.3. 插入节点 2.3.1. 插入到头部 1 2 3 4 5 #define QSIMPLEQ_INSERT_HEAD(head, elm, field) do { \\ if (((elm)-\u0026gt;field.sqe_next = (head)-\u0026gt;sqh_first) == NULL) \\ (head)-\u0026gt;sqh_last = \u0026amp;(elm)-\u0026gt;field.sqe_next; \\ (head)-\u0026gt;sqh_first = (elm); \\ } while (/*CONSTCOND*/0) elm: 待插入的节点。 field: 节点的连接域。 head: 队列的头。 1. 空队列插入节点 2. 非空队列插入节点 2.3.2. 插入到尾部 1 2 3 4 5 #define QSIMPLEQ_INSERT_TAIL(head, elm, field) do { \\ (elm)-\u0026gt;field.sqe_next = NULL; \\ *(head)-\u0026gt;sqh_last = (elm); \\ (head)-\u0026gt;sqh_last = \u0026amp;(elm)-\u0026gt;field.sqe_next; \\ } while (/*CONSTCOND*/0) 2.3.3. 插入到中间 1 2 3 4 5 #define QSIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do { \\ if (((elm)-\u0026gt;field.sqe_next = (listelm)-\u0026gt;field.sqe_next) == NULL) \\ (head)-\u0026gt;sqh_last = \u0026amp;(elm)-\u0026gt;field.sqe_next; \\ (listelm)-\u0026gt;field.sqe_next = (elm); \\ } while (/*CONSTCOND*/0) elm: 等待插入的节点。 listelm: 插入该节点后。 中间插入的节点分为两种情况： listelm是尾节点，和QSIMPLEQ_INSERT_TAIL差不多。 listelm不是尾节点，插入过程如下：\n3. 移除节点 3.1. 移除头部节点 1 2 3 4 5 6 #define QSIMPLEQ_REMOVE_HEAD(head, field) do { \\ typeof((head)-\u0026gt;sqh_first) elm = (head)-\u0026gt;sqh_first; \\ if (((head)-\u0026gt;sqh_first = elm-\u0026gt;field.sqe_next) == NULL) \\ (head)-\u0026gt;sqh_last = \u0026amp;(head)-\u0026gt;sqh_first; \\ elm-\u0026gt;field.sqe_next = NULL; \\ } while (/*CONSTCOND*/0) 队列中的有两个及以上节点： 队列中只有一个节点： 3.2. 移除指定节点 1 2 3 4 5 6 7 8 9 10 11 12 13 #define QSIMPLEQ_REMOVE(head, elm, type, field) do { \\ if ((head)-\u0026gt;sqh_first == (elm)) { \\ QSIMPLEQ_REMOVE_HEAD((head), field); \\ } else { \\ struct type *curelm = (head)-\u0026gt;sqh_first; \\ while (curelm-\u0026gt;field.sqe_next != (elm)) \\ curelm = curelm-\u0026gt;field.sqe_next; \\ if ((curelm-\u0026gt;field.sqe_next = \\ curelm-\u0026gt;field.sqe_next-\u0026gt;field.sqe_next) == NULL) \\ (head)-\u0026gt;sqh_last = \u0026amp;(curelm)-\u0026gt;field.sqe_next; \\ (elm)-\u0026gt;field.sqe_next = NULL; \\ } \\ } while (/*CONSTCOND*/0) elm: 要删除的节点。 如果elm是第一个节点，则使用QSIMPLEQ_REMOVE_HEAD进行删除。\n如果elm是中间节点： 如果elm是最后一个节点：\n3.3. 遍历 3.3.1. 遍历队列 不删除节点时使用。\n1 2 3 4 #define QSIMPLEQ_FOREACH(var, head, field) \\ for ((var) = ((head)-\u0026gt;sqh_first); \\ (var); \\ (var) = ((var)-\u0026gt;field.sqe_next)) 使用案例：\n1 2 3 4 5 6 7 8 9 10 // qemu-8.2.2/audio/audio.c。 // 遍历全局音频设备链表，逐个初始化每个音频设备。 void audio_init_audiodevs(void) { AudiodevListEntry *e; QSIMPLEQ_FOREACH(e, \u0026amp;audiodevs, next) { audio_init(e-\u0026gt;dev, \u0026amp;error_fatal); } } 3.3.2. 遍历队列（安全） 遍历队列时可以安全删除节点。\n1 2 3 4 #define QSIMPLEQ_FOREACH_SAFE(var, head, field, next) \\ for ((var) = ((head)-\u0026gt;sqh_first); \\ (var) \u0026amp;\u0026amp; ((next = ((var)-\u0026gt;field.sqe_next)), 1); \\ (var) = (next)) 使用案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // qemu-8.2.2/migration/ram.c // 在虚拟机迁移结束或发生错误时调用，清理未处理完的页面请求队列，防止资源泄露。 // 释放 RAMState 结构体中的 src_page_requests 队列中所有剩余的页面请求。 static void migration_page_queue_free(RAMState *rs) { struct RAMSrcPageRequest *mspr, *next_mspr; /* This queue generally should be empty - but in the case of a failed * migration might have some droppings in. */ RCU_READ_LOCK_GUARD(); // 遍历队列 QSIMPLEQ_FOREACH_SAFE(mspr, \u0026amp;rs-\u0026gt;src_page_requests, next_req, next_mspr) { memory_region_unref(mspr-\u0026gt;rb-\u0026gt;mr); // 删除节点 QSIMPLEQ_REMOVE_HEAD(\u0026amp;rs-\u0026gt;src_page_requests, next_req); g_free(mspr); } } 3.4. 尾节点快速定位 1 2 3 4 5 #define QSIMPLEQ_LAST(head, type, field) \\ (QSIMPLEQ_EMPTY((head)) ? \\ NULL : \\ ((struct type *)(void *) \\ ((char *)((head)-\u0026gt;sqh_last) - offsetof(struct type, field)))) 如果队列为空，则返回NULL。如果队列不为空，则返回队尾节点。 ofensetof()，获取结构体成员相对于结构体的偏移量。 offsetof(struct type, field)，获取field在type中的偏移量。 (char *)((head)-\u0026gt;sqh_last)，转换为 char* 类型以便进行字节级的指针运算。 (char *)((head)-\u0026gt;sqh_last) - offsetof(struct type, field)，从尾元素的 next 指针地址回退到包含它的结构体起始地址。 (struct type *)(void *)，双重类型转换，先将计算出的地址转为 void*（通用指针类型），再转为目标类型 struct type *（具体结构体指针）。 3.5. 队列合并 3.5.1. 合并到尾部 1 2 3 4 5 6 7 #define QSIMPLEQ_CONCAT(head1, head2) do { \\ if (!QSIMPLEQ_EMPTY((head2))) { \\ *(head1)-\u0026gt;sqh_last = (head2)-\u0026gt;sqh_first; \\ (head1)-\u0026gt;sqh_last = (head2)-\u0026gt;sqh_last; \\ QSIMPLEQ_INIT((head2)); \\ } \\ } while (/*CONSTCOND*/0) 将 head2 队列的所有元素插入到 head1 队列的尾部。 只有当 head2 队列非空时才执行操作，空队列合并是无效操作，直接跳过。 3.5.2. 合并到头部 1 2 3 4 5 6 7 #define QSIMPLEQ_PREPEND(head1, head2) do { \\ if (!QSIMPLEQ_EMPTY((head2))) { \\ *(head2)-\u0026gt;sqh_last = (head1)-\u0026gt;sqh_first; \\ (head1)-\u0026gt;sqh_first = (head2)-\u0026gt;sqh_first; \\ QSIMPLEQ_INIT((head2)); \\ } \\ } while (/*CONSTCOND*/0) 将 head2 队列的所有元素插入到 head1 队列的头部。 只有当 head2 队列非空时才执行操作，空队列合并是无效操作，直接跳过。\n3.6. 分割队列 将原队列从指定节点之后分割为两个独立队列。\n1 2 3 4 5 6 7 8 9 10 #define QSIMPLEQ_SPLIT_AFTER(head, elm, field, removed) do { \\ QSIMPLEQ_INIT(removed); \\ if (((removed)-\u0026gt;sqh_first = (head)-\u0026gt;sqh_first) != NULL) { \\ if (((head)-\u0026gt;sqh_first = (elm)-\u0026gt;field.sqe_next) == NULL) { \\ (head)-\u0026gt;sqh_last = \u0026amp;(head)-\u0026gt;sqh_first; \\ } \\ (removed)-\u0026gt;sqh_last = \u0026amp;(elm)-\u0026gt;field.sqe_next; \\ (elm)-\u0026gt;field.sqe_next = NULL; \\ } \\ } while (/*CONSTCOND*/0) head: 队列头，为空时直接返回。 elm: 从elm开始分割队列，将eml（包括）之前的节点划分给removed。 removed: 指向移除的队列。 以elm为非末尾节为例： 4. 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 /* * Simple queue definitions. */ #define QSIMPLEQ_HEAD(name, type) \\ struct name { \\ struct type *sqh_first; /* first element */ \\ struct type **sqh_last; /* addr of last next element */ \\ } #define QSIMPLEQ_HEAD_INITIALIZER(head) \\ { NULL, \u0026amp;(head).sqh_first } #define QSIMPLEQ_ENTRY(type) \\ struct { \\ struct type *sqe_next; /* next element */ \\ } /* * Simple queue functions. */ #define QSIMPLEQ_INIT(head) do { \\ (head)-\u0026gt;sqh_first = NULL; \\ (head)-\u0026gt;sqh_last = \u0026amp;(head)-\u0026gt;sqh_first; \\ } while (/*CONSTCOND*/0) #define QSIMPLEQ_INSERT_HEAD(head, elm, field) do { \\ if (((elm)-\u0026gt;field.sqe_next = (head)-\u0026gt;sqh_first) == NULL) \\ (head)-\u0026gt;sqh_last = \u0026amp;(elm)-\u0026gt;field.sqe_next; \\ (head)-\u0026gt;sqh_first = (elm); \\ } while (/*CONSTCOND*/0) #define QSIMPLEQ_INSERT_TAIL(head, elm, field) do { \\ (elm)-\u0026gt;field.sqe_next = NULL; \\ *(head)-\u0026gt;sqh_last = (elm); \\ (head)-\u0026gt;sqh_last = \u0026amp;(elm)-\u0026gt;field.sqe_next; \\ } while (/*CONSTCOND*/0) #define QSIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do { \\ if (((elm)-\u0026gt;field.sqe_next = (listelm)-\u0026gt;field.sqe_next) == NULL) \\ (head)-\u0026gt;sqh_last = \u0026amp;(elm)-\u0026gt;field.sqe_next; \\ (listelm)-\u0026gt;field.sqe_next = (elm); \\ } while (/*CONSTCOND*/0) #define QSIMPLEQ_REMOVE_HEAD(head, field) do { \\ typeof((head)-\u0026gt;sqh_first) elm = (head)-\u0026gt;sqh_first; \\ if (((head)-\u0026gt;sqh_first = elm-\u0026gt;field.sqe_next) == NULL) \\ (head)-\u0026gt;sqh_last = \u0026amp;(head)-\u0026gt;sqh_first; \\ elm-\u0026gt;field.sqe_next = NULL; \\ } while (/*CONSTCOND*/0) #define QSIMPLEQ_SPLIT_AFTER(head, elm, field, removed) do { \\ QSIMPLEQ_INIT(removed); \\ if (((removed)-\u0026gt;sqh_first = (head)-\u0026gt;sqh_first) != NULL) { \\ if (((head)-\u0026gt;sqh_first = (elm)-\u0026gt;field.sqe_next) == NULL) { \\ (head)-\u0026gt;sqh_last = \u0026amp;(head)-\u0026gt;sqh_first; \\ } \\ (removed)-\u0026gt;sqh_last = \u0026amp;(elm)-\u0026gt;field.sqe_next; \\ (elm)-\u0026gt;field.sqe_next = NULL; \\ } \\ } while (/*CONSTCOND*/0) #define QSIMPLEQ_REMOVE(head, elm, type, field) do { \\ if ((head)-\u0026gt;sqh_first == (elm)) { \\ QSIMPLEQ_REMOVE_HEAD((head), field); \\ } else { \\ struct type *curelm = (head)-\u0026gt;sqh_first; \\ while (curelm-\u0026gt;field.sqe_next != (elm)) \\ curelm = curelm-\u0026gt;field.sqe_next; \\ if ((curelm-\u0026gt;field.sqe_next = \\ curelm-\u0026gt;field.sqe_next-\u0026gt;field.sqe_next) == NULL) \\ (head)-\u0026gt;sqh_last = \u0026amp;(curelm)-\u0026gt;field.sqe_next; \\ (elm)-\u0026gt;field.sqe_next = NULL; \\ } \\ } while (/*CONSTCOND*/0) #define QSIMPLEQ_FOREACH(var, head, field) \\ for ((var) = ((head)-\u0026gt;sqh_first); \\ (var); \\ (var) = ((var)-\u0026gt;field.sqe_next)) #define QSIMPLEQ_FOREACH_SAFE(var, head, field, next) \\ for ((var) = ((head)-\u0026gt;sqh_first); \\ (var) \u0026amp;\u0026amp; ((next = ((var)-\u0026gt;field.sqe_next)), 1); \\ (var) = (next)) #define QSIMPLEQ_CONCAT(head1, head2) do { \\ if (!QSIMPLEQ_EMPTY((head2))) { \\ *(head1)-\u0026gt;sqh_last = (head2)-\u0026gt;sqh_first; \\ (head1)-\u0026gt;sqh_last = (head2)-\u0026gt;sqh_last; \\ QSIMPLEQ_INIT((head2)); \\ } \\ } while (/*CONSTCOND*/0) #define QSIMPLEQ_PREPEND(head1, head2) do { \\ if (!QSIMPLEQ_EMPTY((head2))) { \\ *(head2)-\u0026gt;sqh_last = (head1)-\u0026gt;sqh_first; \\ (head1)-\u0026gt;sqh_first = (head2)-\u0026gt;sqh_first; \\ QSIMPLEQ_INIT((head2)); \\ } \\ } while (/*CONSTCOND*/0) #define QSIMPLEQ_LAST(head, type, field) \\ (QSIMPLEQ_EMPTY((head)) ? \\ NULL : \\ ((struct type *)(void *) \\ ((char *)((head)-\u0026gt;sqh_last) - offsetof(struct type, field)))) /* * Simple queue access methods. */ #define QSIMPLEQ_EMPTY_ATOMIC(head) \\ (qatomic_read(\u0026amp;((head)-\u0026gt;sqh_first)) == NULL) #define QSIMPLEQ_EMPTY(head) ((head)-\u0026gt;sqh_first == NULL) #define QSIMPLEQ_FIRST(head) ((head)-\u0026gt;sqh_first) #define QSIMPLEQ_NEXT(elm, field) ((elm)-\u0026gt;field.sqe_next) ","date":"2024-11-03T00:00:00Z","permalink":"https://zuoco.github.io/p/qemu%E7%AE%80%E5%8D%95%E9%98%9F%E5%88%97-simple-queue/","title":"Qemu简单队列 Simple Queue"},{"content":"这是一个先进先出的队列结构，队列中的元素是vector。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class StreamBuffer { public: StreamBuffer() = default; ~StreamBuffer() = default; // 无删除、无拷贝的高效数据读取地读取缓冲区数据，将数据合并到第一个块中并返回这个块的地址。 // peek方法实现了智能的块合并策略：当请求的数据跨越多个块时，会自动将多个块合并到第一个块中，确保返回连续的内存空间。 const void *peek(uint32_t n); // 从m_chunks的头部丢弃指定数量的字节 void pop(uint32_t n); // 向m_chunks中写入指定字节数 void write(const void *data, uint32_t n); uint32_t getSize() const; // m_size private: static const uint32_t kChunkSize; // 用来限制单个Chunk的最大容量 using Chunk = std::vector\u0026lt;uint8_t\u0026gt;; using ChunkList = std::list\u0026lt;Chunk\u0026gt;; // 队列中每一个Chunk最大只能是4096 ChunkList m_chunks; uint32_t m_size = 0; // m_chunks包含的总字节数 uint32_t m_headUsed = 0; // m_chunks中第一个Chunk块中已弹出的字节数量 }; 1 const uint32_t StreamBuffer::kChunkSize = 4096; ","date":"2024-10-27T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E5%8C%BA%E8%AE%BE%E8%AE%A1%E9%9B%B6%E6%8B%B7%E8%B4%9D%E9%98%9F%E5%88%97/","title":"DeskFlow 字节缓冲区设计（零拷贝队列）"},{"content":" 1. 链表定义 1.1. 优化 2. 链表操作 2.1. 访问链表 2.2. 链表初始化 2.3. 插入操作 2.3.1. 链表头部插入新节点 2.3.2. 指定节点后插入节点 2.3.3. 指定节点前插入节点 2.4. 判断节点是否在链表中 2.5. 移除节点 2.5.1. 移除指定节点 2.5.2. 移除指定节点（安全版本） 2.6. 遍历链表 交换两个链表的全部节点 3. 使用示例 3.1. 节点结构 3.2. 链表头结构 qemu-8.2.2/include/qemu/queue.h是QEMU中实现的通用数据结构库，源自FreeBSD的queue.h。\n1. 链表定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* * 链表头： 包含一个指向首元节点的指针 */ #define QLIST_HEAD(name, type) \\ struct name { \\ struct type *lh_first; /* first element */ \\ } /* * 链表初始化。 * 首元节点指针初始化为NULL。 */ #define QLIST_HEAD_INITIALIZER(head) \\ { NULL } /* * 链表节点的连接域。 * 节点类型的结构体中包含此结构体，用于连接链表。 */ #define QLIST_ENTRY(type) \\ struct { \\ struct type *le_next; /* 指向下一个节点 */ \\ struct type **le_prev; /* 指向前驱节点的le_next字段，这是一个效率设计 */ \\ } 1.1. 优化 Qemu-List带来的优化就是**le_prev，一般情况下，单链表是没有prev相关的字段，而双链表的prev字段是指向前驱节点的，但是Qemu-List不属于这两种情况。假如现在有一个这样的链表：A-\u0026gt;B-\u0026gt;C，C的le_prev指向B的le_next，而B的le_next又指向C，所以C的le_prev实际指向C自己，相对于一般的链表设计，这样设计的好处是，删除节点的效率高一点。对于非操作系统级别的程序可能少见这种设计，但是对于内核或者驱动来说，性能是非常敏感的，能优化一点是一点。那么，这种设计是如何优化删除效率的：\n一般但链表设计中，要删除节点B，需要访问节点A，以便在移除B后建立A和C的连接：A-\u0026gt;C。 Qemu-List中，B的le_prev指向B自己，这样删除B时，不需要访问A，基于节点B就可以实现：A-\u0026gt;C，基本思路如下所示: 1 2 3 4 5 6 7 8 QLIST_REMOVE(B, entry) { // 步骤1：更新后继节点C的前驱指针 if (B.le_next != NULL) // C存在 C.le_prev = B.le_prev; // 即 C.le_prev = \u0026amp;A.le_next，也就是让C的le_prev指向A的le_next(原本指向B的le_prev) // 步骤2：通过前驱指针修改A的le_next *B.le_prev = B.le_next; // 相当于 A.le_next = C的地址 } 从上面代码可以看到，删除节点B时，整个过程不需要访问A。 下面再看一点代码，以便对于该链表的使用有一个初步了解：\n1 2 3 /* qemu-8.2.2/block.c */ static QLIST_HEAD(, BlockDriver) bdrv_drivers = QLIST_HEAD_INITIALIZER(bdrv_drivers); 上面是一个块设备驱动相关的链表，使用QLIST_HEAD宏函数创建，宏替换后如下：\n1 2 3 static struct { struct BlockDriver *lh_first; } bdrv_drivers = { NULL }; 2. 链表操作 2.1. 访问链表 1 2 3 #define QLIST_EMPTY(head) ((head)-\u0026gt;lh_first == NULL) #define QLIST_FIRST(head) ((head)-\u0026gt;lh_first) #define QLIST_NEXT(elm, field) ((elm)-\u0026gt;field.le_next) 2.2. 链表初始化 1 2 3 #define QLIST_INIT(head) do { \\ (head)-\u0026gt;lh_first = NULL; \\ } while (/*CONSTCOND*/0) 2.3. 插入操作 2.3.1. 链表头部插入新节点 1 2 3 4 5 6 #define QLIST_INSERT_HEAD(head, elm, field) do { \\ if (((elm)-\u0026gt;field.le_next = (head)-\u0026gt;lh_first) != NULL) \\ (head)-\u0026gt;lh_first-\u0026gt;field.le_prev = \u0026amp;(elm)-\u0026gt;field.le_next;\\ (head)-\u0026gt;lh_first = (elm); \\ (elm)-\u0026gt;field.le_prev = \u0026amp;(head)-\u0026gt;lh_first; \\ } while (/*CONSTCOND*/0) 解释：\nfield: 就是使用宏QLIST_ENTRY(type)创建的链表节点连接结构，是节点中的连接域字段，通过该字段访问后继节点。 elm: 要插入的节点。 代码逐行解释：\nif (((elm)-\u0026gt;field.le_next = (head)-\u0026gt;lh_first) != NULL)\n使elm的le_next字段指向原首元节点。 判断链表是否为空。 (head)-\u0026gt;lh_first-\u0026gt;field.le_prev = \u0026amp;(elm)-\u0026gt;field.le_next;\n如果链表非空，使原首元节点的le_prev字段指向新节点的le_next字段。 (head)-\u0026gt;lh_first = (elm);\n使链表头指向新节点。 (elm)-\u0026gt;field.le_prev = \u0026amp;(head)-\u0026gt;lh_first;\n使新节点的le_prev字段指向链表头的lh_first字段，也就是指向自己，这就是首元节点。 2.3.2. 指定节点后插入节点 1 2 3 4 5 6 7 #define QLIST_INSERT_AFTER(listelm, elm, field) do { \\ if (((elm)-\u0026gt;field.le_next = (listelm)-\u0026gt;field.le_next) != NULL) \\ (listelm)-\u0026gt;field.le_next-\u0026gt;field.le_prev = \\ \u0026amp;(elm)-\u0026gt;field.le_next; \\ (listelm)-\u0026gt;field.le_next = (elm); \\ (elm)-\u0026gt;field.le_prev = \u0026amp;(listelm)-\u0026gt;field.le_next; \\ } while (/*CONSTCOND*/0) elm： 要插入的节点 listelm： 插入到该节点后。 2.3.3. 指定节点前插入节点 1 2 3 4 5 6 #define QLIST_INSERT_BEFORE(listelm, elm, field) do { \\ (elm)-\u0026gt;field.le_prev = (listelm)-\u0026gt;field.le_prev; \\ (elm)-\u0026gt;field.le_next = (listelm); \\ *(listelm)-\u0026gt;field.le_prev = (elm); \\ (listelm)-\u0026gt;field.le_prev = \u0026amp;(elm)-\u0026gt;field.le_next; \\ } while (/*CONSTCOND*/0) 和QLIST_INSERT_AFTER差不多。\n2.4. 判断节点是否在链表中 1 #define QLIST_IS_INSERTED(elm, field) ((elm)-\u0026gt;field.le_prev != NULL) 2.5. 移除节点 2.5.1. 移除指定节点 1 2 3 4 5 6 7 8 #define QLIST_REMOVE(elm, field) do { \\ if ((elm)-\u0026gt;field.le_next != NULL) \\ (elm)-\u0026gt;field.le_next-\u0026gt;field.le_prev = \\ (elm)-\u0026gt;field.le_prev; \\ *(elm)-\u0026gt;field.le_prev = (elm)-\u0026gt;field.le_next; \\ (elm)-\u0026gt;field.le_next = NULL; \\ (elm)-\u0026gt;field.le_prev = NULL; \\ } while (/*CONSTCOND*/0) elm: 要移除的节点。 field: 节点连接域。\n2.5.2. 移除指定节点（安全版本） 1 2 3 4 5 6 7 8 9 10 #define QLIST_SAFE_REMOVE(elm, field) do { \\ if ((elm)-\u0026gt;field.le_prev != NULL) { \\ if ((elm)-\u0026gt;field.le_next != NULL) \\ (elm)-\u0026gt;field.le_next-\u0026gt;field.le_prev = \\ (elm)-\u0026gt;field.le_prev; \\ *(elm)-\u0026gt;field.le_prev = (elm)-\u0026gt;field.le_next; \\ (elm)-\u0026gt;field.le_next = NULL; \\ (elm)-\u0026gt;field.le_prev = NULL; \\ } \\ } while (/*CONSTCOND*/0) 安全性考虑： 先判断elm节点是否存在，再进行删除。 删除节点： 和QLIST_REMOVE() 一样。 2.6. 遍历链表 1. 一般遍历\n1 2 3 4 #define QLIST_FOREACH(var, head, field) \\ for ((var) = ((head)-\u0026gt;lh_first); \\ (var); \\ (var) = ((var)-\u0026gt;field.le_next)) 不需要删除节点时使用。 2. 安全遍历 1 2 3 4 #define QLIST_FOREACH_SAFE(var, head, field, next_var) \\ for ((var) = ((head)-\u0026gt;lh_first); \\ (var) \u0026amp;\u0026amp; ((next_var) = ((var)-\u0026gt;field.le_next), 1); \\ (var) = (next_var)) 安全性改进: 它支持在遍历过程中安全删除当前节点，在进入循环体之前，next_var 已保存下一个节点的指针，即使循环体内删除或修改了当前节点 var，next_var 仍指向下一个有效节点（不受 var 操作的影响），步进时直接使用 next_var，避免访问已释放的内存。 3. 使用宏遍历\n遍历宏只是实现了for循环的for(;;;)部分：\nQLIST_FOREACH：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 遍历所有注册的块设备驱动程序，找出最适合处理指定设备文件（如 /dev/cdrom）的驱动程序。 static BlockDriver *find_hdev_driver(const char *filename) { int score_max = 0, score; BlockDriver *drv = NULL, *d; GLOBAL_STATE_CODE(); QLIST_FOREACH(d, \u0026amp;bdrv_drivers, list) { if (d-\u0026gt;bdrv_probe_device) { score = d-\u0026gt;bdrv_probe_device(filename); if (score \u0026gt; score_max) { score_max = score; drv = d; } } } return drv; } QLIST_FOREACH_SAFE：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 从指定块设备状态（BlockDriverState）的操作阻塞列表中移除特定原因的阻塞项。 void bdrv_op_unblock(BlockDriverState *bs, BlockOpType op, Error *reason) { BdrvOpBlocker *blocker, *next; GLOBAL_STATE_CODE(); assert((int) op \u0026gt;= 0 \u0026amp;\u0026amp; op \u0026lt; BLOCK_OP_TYPE_MAX); QLIST_FOREACH_SAFE(blocker, \u0026amp;bs-\u0026gt;op_blockers[op], list, next) { if (blocker-\u0026gt;reason == reason) { QLIST_REMOVE(blocker, list); g_free(blocker); } } } 交换两个链表的全部节点 1 2 3 4 5 6 7 8 9 10 11 12 #define QLIST_SWAP(dstlist, srclist, field) do { \\ void *tmplist; \\ tmplist = (srclist)-\u0026gt;lh_first; \\ (srclist)-\u0026gt;lh_first = (dstlist)-\u0026gt;lh_first; \\ if ((srclist)-\u0026gt;lh_first != NULL) { \\ (srclist)-\u0026gt;lh_first-\u0026gt;field.le_prev = \u0026amp;(srclist)-\u0026gt;lh_first; \\ } \\ (dstlist)-\u0026gt;lh_first = tmplist; \\ if ((dstlist)-\u0026gt;lh_first != NULL) { \\ (dstlist)-\u0026gt;lh_first-\u0026gt;field.le_prev = \u0026amp;(dstlist)-\u0026gt;lh_first; \\ } \\ } while (/*CONSTCOND*/0) 我们以为两个非空链表为例： 3. 使用示例 3.1. 节点结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // thread-pool.h typedef struct ThreadPoolElement ThreadPoolElement; // thread-pool.c struct ThreadPoolElement { BlockAIOCB common; ThreadPool *pool; ThreadPoolFunc *func; void *arg; enum ThreadState state; int ret; QTAILQ_ENTRY(ThreadPoolElement) reqs; /* * 节点的连接区域，每个节点通过该域连接前后相邻节点。 */ QLIST_ENTRY(ThreadPoolElement) all; }; 3.2. 链表头结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 BlockAIOCB *thread_pool_submit_aio(ThreadPoolFunc *func, void *arg, BlockCompletionFunc *cb, void *opaque) { ThreadPoolElement *req; // ...... // 省略一堆代码 /* * 链表头部保存在pool实例中。 */ ThreadPool *pool = aio_get_thread_pool(ctx); // ..... QLIST_INSERT_HEAD(\u0026amp;pool-\u0026gt;head, req, all); // ...... } 下面我们来看这个ThreadPool *pool是如何保存头部的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // thread-pool.h typedef struct ThreadPool ThreadPool; // thread-pool.c struct ThreadPool { AioContext *ctx; QEMUBH *completion_bh; QemuMutex lock; QemuCond worker_stopped; QemuCond request_cond; QEMUBH *new_thread_bh; /* * 使用QLIST_HEAD宏创建一个链表，链表节点中所保存的元素类型为ThreadPoolElement。 */ QLIST_HEAD(, ThreadPoolElement) head; QTAILQ_HEAD(, ThreadPoolElement) request_list; int cur_threads; int idle_threads; int new_threads; int pending_threads; int min_threads; int max_threads; }; ","date":"2024-10-27T00:00:00Z","permalink":"https://zuoco.github.io/p/qemu-list-%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E5%8D%95%E9%93%BE%E8%A1%A8/","title":"Qemu - List 一种高效单链表"},{"content":" 1. 流式协议 2. 流的边界 3. 应用层协议设计 3.1. 报文设计 3.2. 解析器设计 1. 流式协议 TCP提供一种可靠传输方式，通过序列号和包重传确认机制保证数据包的有序，不会丢包或包乱序，并且数据一定被正确发到目的地。如果我们使用UDP协议，但又不能接受丢包，那就要在UDP的基础去现类似TCP的有序和可靠传输机制了（例如 RTP、RUDP）。TCP作为流式协议，它保证数据有序送达，但是数据流中，那个字节是开始，那个字节是结束，这就不关人家的事情了，也就是说，我们从传输层拿到数据后，要自行处理数据的边界。\n2. 流的边界 关于边界问题，有两种情况：粘包、半包。\n粘包： 多个包裹连接在一起，也可能不是整数个包。 半包： 只收到一个包的一部分。 无论是半包还是粘包问题，问题都出在流的边界上，常用的解决办法有3种：固定包长度、指定包结束标志、封装一套协议（协议头+数据）。对于数据包固定大小，当数据长度小于包长度时，需要使用特定字符填充，例如“\\0”，必须和正常数据区分开。当数据报长度大于包长度时，需要分包，发送端需要分包，接收端需要组包。对于指定包的结束标志，就是使用特定的符号或者符号组合作为包结束标志，例如FTP、SMTP协议，使用“\\r\\n”表示结束，接受端处理包时，遇到“\\r\\n”就认为获取到了一个包。\n3. 应用层协议设计 应用层协议设计要和网络传输层解耦，协议层提供读写报文的回调函数的声明，但是函数实现交给由业务层完成，业务层需要将设计好的读写函数注册给协议层。协议层需要读写数据时直接调用读写函数即可。但是要注意，协议的读写回调需要使用非阻塞方式实现。一般情况下，网络部分也是独立的模块，业务层通过网络模块接收网络数据并将数据保存到缓存区中，然后将缓存区的使用权移交给协议层，同样协议层需要发送数据时，也要将报文的缓存区使用权移交给网络模块。\n3.1. 报文设计 报文一般会分为控制报文和数据报文。控制报文用于处理设备连接/断开、配置管理、流控制等，数据报文用于传输各种数据，报文大概的结构如下：\n最基本的控制报文有：\n控制报文 功能 Hello报文 双方建立连接（TCP）后发送的第一个包是Hello报文，\n用于同步双方的信息，包括协议版本，软件版本等等，保证新版协议对于旧版本的兼容性 connect报文 客户端发送，建立用户协议的连接 disconnect报文 断开连接，双发都可以发送 其他 \u0026hellip; 3.2. 解析器设计 通常我们使用基于回调的状态机架构来设计解析器。协议解析器定义了一个完整的回调接口系统来处理协议的数据包解析和序列化。\n解析器的核心组成 数据收发器 一对儿回调函数，由用户提供，用于从网络接收数据，以及发送数据到网络 数据处理器 一套数据处理回调程序，由于用户提供。\n解析器收到完整报文并解析后将数据分发给对应的处理程序 报文构造器 由用户调用，用于构造报文并将数据添加到报文中，最后将报文添加到发送队列中 capabilities缓存 记录通讯双方的功能特性，用于兼容旧版协议 头部缓存 保存正在接收的头部（报文头部、类型头部），以及接收进度。\n头部决定了数据接收完成后，分发给那个处理程序 接收缓冲区 缓存接收到的数据，以及接收进度。\n数据接收完成后，解析器会将数据地址传递给对应的处理函数 发送队列 缓存等待发送的报文 锁 保存用户传入的互斥量，维护发送队列的线程安全 协议层的任务循环 协议层任务循环以读回调为入口，一旦读取到数据，解析器就进入解析流程，依次读取报文头部、类型头部、数据，直到读回调返回0。在读取报文头部后会检查头部字段是否合法，并获取报文长度，以便于确定当前报文的结束边界。 如果读回调返回0时，读取到的数据小于报文长度，此时会从解析流程返回，但是数据不会丢失，因为解析器已经缓存数据，等到新数据达到可以继续读取，直到读取到整个报文。读取一个完整报文后就将数据移交给处理器程序。 处理器需要在处理数据后发送响应报文，也就是将处理结果打包成对应的报文并添加到发送队列中。而解析器发送回调的任务就是将发送队列中报文缓存区移交给网络模块。也可以基于事件机制，网络模块收到数据后通知协议层读取数据，而协议层这边在发送队列有数据时通知网络模块。 ","date":"2024-10-23T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%80%BB%E7%BB%93/","title":"应用层协议设计的总结"},{"content":" 1. 多路复用器 2. 多路复用器任务 对于多路复用，DeskFlow设计了两个类型 — SocketMultiplexer、ISocketMultiplexerJob：\nSocketMultiplexer是套接字多路复用器的核心实现，借助poll来管理多个网络套接字（ISocket）的异步I/O。 ISocketMultiplexerJob是一个抽象类型，是套接字I/O任务的抽象。 多路复用器在其主线程的任务循环中检测套接字的状态，当状态发生变化时（可读、可写、出错），多路复用器就会调用套接字任务处理这些IO状态，而套接字的I/O被封装为“多路复用器事件”。\n1. 多路复用器设计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class SocketMultiplexer { public: SocketMultiplexer(); SocketMultiplexer(SocketMultiplexer const \u0026amp;) = delete; SocketMultiplexer(SocketMultiplexer \u0026amp;\u0026amp;) = delete; ~SocketMultiplexer(); SocketMultiplexer \u0026amp;operator=(SocketMultiplexer const \u0026amp;) = delete; SocketMultiplexer \u0026amp;operator=(SocketMultiplexer \u0026amp;\u0026amp;) = delete; /* 将ISocket对象与对应的IO任务对象添加到列表中（线程安全），更新m_update=true */ void addSocket(ISocket *, ISocketMultiplexerJob *); void removeSocket(ISocket *); // static SocketMultiplexer *getInstance(); // 多路复用器单例 private: /* 核心数据结构类型 */ using SocketJobs = std::list\u0026lt;ISocketMultiplexerJob *\u0026gt;; // 多路复用器任务列表，“任务”用于处理I/O，这些“任务”是与ISocket绑定的 using JobCursor = SocketJobs::iterator; // 任务列表迭代器 using SocketJobMap = std::map\u0026lt;ISocket *, JobCursor\u0026gt;; // ISocket和SocketJobs中任务的映射关系，方便通过IScoket对象查找对应的Job [[noreturn]] void serviceThread(void *); // 轮询所有注册的 socket，检测事件并调用回调（ISocketMultiplexerJob） /* * 任务列表的迭代器游标，用于防止多线程并发时的迭代器失效的问题。 * 不再使用使用begin和end迭代器遍历列表，而是使用newCursor()和nextCursor()返回的迭代器来遍历。 */ JobCursor newCursor(); // 将游标（m_cursorMark）插入列表开头，作为遍历的起点。 JobCursor nextCursor(JobCursor); // 在列表中找到一个有效的job，并返回。 void deleteCursor(JobCursor); // 移除游标。 /* 读写共享资源时，先调用lockJobListLock()，再调用lockJobList()，然后开始读写共享资源 */ void lockJobListLock(); // 获取 m_jobListLockLocked void lockJobList(); // 获取 m_jobListLock，获取成功后会释放m_jobListLockLocked void unlockJobList(); // 释放 m_jobListLock private: Mutex *m_mutex = nullptr; // 保护共享资源m_socketJobs、m_socketJobMap等 /* 多路复用器主线程，构造函数中启动 */ Thread *m_thread = nullptr; /* 任务列表更新标志 */ bool m_update = false; /* 通知服务线程有新 job 需要处理，由unlockJobList()更新 */ CondVar\u0026lt;bool\u0026gt; *m_jobsReady = nullptr; /* * 两个锁结合使用，防止死锁： * 使用时先锁lockJobListLock，成功后再锁m_jobListLock，然后开始读写共享资源。 */ CondVar\u0026lt;bool\u0026gt; *m_jobListLock = nullptr; // 这是m_socketJobs的锁 CondVar\u0026lt;bool\u0026gt; *m_jobListLockLocked = nullptr; // 这是m_jobListLock的锁 /* 两个锁的拥有者，用于检查拥有锁的是不是当前线程 */ Thread *m_jobListLocker = nullptr; Thread *m_jobListLockLocker = nullptr; SocketJobs m_socketJobs = {}; // 任务列表 SocketJobMap m_socketJobMap = {}; // 套接字与任务的对应关系 ISocketMultiplexerJob *m_cursorMark = nullptr; // }; 主线程实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 [[noreturn]] void SocketMultiplexer::serviceThread(void *) { std::vector\u0026lt;IArchNetwork::PollEntry\u0026gt; pfds; IArchNetwork::PollEntry pfd; for (;;) { Thread::testCancel(); // 检查是否需要取消线程 { // 等待，直到任务列表中有任务 Lock lock(m_mutex); while (!(bool)*m_jobsReady) { m_jobsReady-\u0026gt;wait(); } } // 有任务了，先上锁 lockJobListLock(); lockJobList(); // ... // 这里就是poll的逻辑代码，监控一组ISocket，有事件就执行对应的任务。 // ... // 解锁 unlockJobList(); } } 2. 多路复用器任务 这里重点关注一下m_method成员，这是多路复用器任务，他的返回值类型还是多路复用器任务类型，ISocketMultiplexerJob::run()函数会去执行这个任务，并且返回值类型也是ISocketMultiplexerJob， 也就是说，执行一个任务后返回一个任务，这种方式允许在运行时链式任务处理，例如在连接建立过程中从连接处理任务切换到数据传输任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* * 抽象基类: 定义了套接字多路复用器任务的核心功能。 * 该接口采用了事件驱动的设计模式，当套接字状态发生变化时（可读、可写、出错），多路复用器会调用 run() 方法处理这些事件。 */ class ISocketMultiplexerJob : public IInterface { public: virtual ISocketMultiplexerJob *run(bool readable, bool writable, bool error) = 0; virtual ArchSocket getSocket() const = 0; virtual bool isReadable() const = 0; virtual bool isWritable() const = 0; }; /* 派生类型 */ template \u0026lt;class T\u0026gt; class TSocketMultiplexerMethodJob : public ISocketMultiplexerJob { public: using Method = ISocketMultiplexerJob *(T::*)(ISocketMultiplexerJob *, bool, bool, bool); TSocketMultiplexerMethodJob(T *object, Method method, ArchSocket socket, bool readable, bool writeable); TSocketMultiplexerMethodJob(TSocketMultiplexerMethodJob const \u0026amp;) = delete; TSocketMultiplexerMethodJob(TSocketMultiplexerMethodJob \u0026amp;\u0026amp;) = delete; ~TSocketMultiplexerMethodJob() override; TSocketMultiplexerMethodJob \u0026amp;operator=(TSocketMultiplexerMethodJob const \u0026amp;) = delete; TSocketMultiplexerMethodJob \u0026amp;operator=(TSocketMultiplexerMethodJob \u0026amp;\u0026amp;) = delete; ISocketMultiplexerJob *run(bool readable, bool writable, bool error) override; ArchSocket getSocket() const override; bool isReadable() const override; // m_readable bool isWritable() const override; // m_writable private: T *m_object; // 任务的来源，事件驱动框架中 Method m_method; // 多路复用器任务函数 ArchSocket m_socket; // 任务对应的Socket bool m_readable; bool m_writable; void *m_arg; }; 虚函数实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* * 运行多路复用器任务，允许在运行时动态改变套接字的处理逻辑，例如在连接建立过程中从连接处理任务切换到数据传输任务。 * 返回自身： 继续使用当前任务处理后续事件 * 返回新任务： 替换当前任务，改变处理方式 * 返回 nullptr：停止处理该套接字事件 */ template \u0026lt;class T\u0026gt; inline ISocketMultiplexerJob *TSocketMultiplexerMethodJob\u0026lt;T\u0026gt;::run(bool read, bool write, bool error) { if (m_object != nullptr) { return (m_object-\u0026gt;*m_method)(this, read, write, error); } return nullptr; } ","date":"2024-10-20T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A303-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8%E8%AE%BE%E8%AE%A1/","title":"DeskFlow 异步网络接口（03） —  多路复用器设计"},{"content":" 1. 抽象工厂类 2. 工厂类的实现 3. 使用 1. 抽象工厂类 ISocketFactory网络接口类将socket的创建过与使用解耦合，通过工厂方法，允许客户端代码通过统一的接口创建不同类型的套接字，而无需直接依赖具体的实现类，但这是一个抽象类型，实际由TCPSocketFactory实现，只提供了TCP的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ISocketFactory : public IInterface { public: /* * family : 协议族，IPv4或者IPv6 * securityLevel : 安全级别，明文还是加密 */ virtual IDataSocket *create( IArchNetwork::EAddressFamily family = IArchNetwork::kINET, SecurityLevel securityLevel = SecurityLevel::PlainText ) const = 0; virtual IListenSocket *createListen( IArchNetwork::EAddressFamily family = IArchNetwork::kINET, SecurityLevel securityLevel = SecurityLevel::PlainText ) const = 0; }; 该工厂提供两种网络接口的创建：\nIDataSocket : 一般数据socket。 IListenSocket : 监听套接字。 2. 工厂类的实现 TCPSocketFactory 是 ISocketFactory 的具体实现类，负责创建 TCP 协议的套接字（IDataSocket 和 IListenSocket）。它通过多路复用器（SocketMultiplexer）实现完整的异步网络IO，通过事件队列（IEventQueue）也业务层交互。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class TCPSocketFactory : public ISocketFactory { public: TCPSocketFactory(IEventQueue *events, SocketMultiplexer *socketMultiplexer); ~TCPSocketFactory() override = default; /* 重写抽象类的虚函数 */ IDataSocket *create( IArchNetwork::EAddressFamily family = IArchNetwork::kINET, SecurityLevel securityLevel = SecurityLevel::PlainText ) const override; IListenSocket *createListen( IArchNetwork::EAddressFamily family = IArchNetwork::kINET, SecurityLevel securityLevel = SecurityLevel::PlainText ) const override; private: IEventQueue *m_events; // 指向事件队列的指针，用于异步通知连接状态、数据就绪等事件。 SocketMultiplexer *m_socketMultiplexer; // 套接字多路复用器，用于高效管理多个套接字的并发操作（如监听连接请求、读取数据）。 }; 我们稍微看一下实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 创建一个普通数据套接字 IDataSocket *TCPSocketFactory::create(IArchNetwork::EAddressFamily family, SecurityLevel securityLevel) const { if (securityLevel != SecurityLevel::PlainText) { // 加密套接字 auto *secureSocket = new SecureSocket(m_events, m_socketMultiplexer, family, securityLevel); secureSocket-\u0026gt;initSsl(false); return secureSocket; } else { // 普通套接字 return new TCPSocket(m_events, m_socketMultiplexer, family); } } // 监听套接字 IListenSocket *TCPSocketFactory::createListen(IArchNetwork::EAddressFamily family, SecurityLevel securityLevel) const { IListenSocket *socket = nullptr; if (securityLevel != SecurityLevel::PlainText) { socket = new SecureListenSocket(m_events, m_socketMultiplexer, family, securityLevel); } else { socket = new TCPListenSocket(m_events, m_socketMultiplexer, family); } return socket; } 3. 使用 以TCP服务端为例： 程序启动后首先创建一个ServerApp对象，ServerApp内部维护一个监听器，而监听器在启动时会通过工厂方法创建一个监听套接字用于监听客户端连接。对于ClientApp对象则是创建普通的数据要解字，并使用该套接字向服务端发起连接。\n业务层类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class ServerApp : public App { public: // ... // 省略一堆成员变量以及成员函数 bool startServer(); // 启动服务端业务程序： 创建监听器，并等待客户端链接 private: // ... ISocketFactory *getSocketFactory() const; // 创建一个网络接口工厂实例 // ... // ... ClientListener *m_listener = nullptr; // 监听器，内部包含一个工厂实例 }; 网络监听器类型 1 2 3 4 5 6 7 8 9 10 11 12 class ClientListener { // ... // 省略一堆成员 void start(); // 通过工厂方法创建一个监听套接字 private: // ... // ... IListenSocket *m_listen; // 监听Socket ISocketFactory *m_socketFactory; // 工厂实例 }; 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* 创建工厂实例 */ ISocketFactory *ServerApp::getSocketFactory() const { return new TCPSocketFactory(m_events, getSocketMultiplexer()); } /* 创建一个监听器 */ ClientListener *ServerApp::openClientListener(const NetworkAddress \u0026amp;address) { auto securityLevel = args().m_enableCrypto ? args().m_chkPeerCert ? SecurityLevel::PeerAuth : SecurityLevel::Encrypted : SecurityLevel::PlainText; // 这个监听器中包含一个网络接口工厂实例 auto *listen = new ClientListener(getAddress(address), getSocketFactory(), m_events, securityLevel); m_events-\u0026gt;adoptHandler( EventTypes::ClientListenerAccepted, listen, new TMethodEventJob\u0026lt;ServerApp\u0026gt;(this, \u0026amp;ServerApp::handleClientConnected, listen) ); return listen; } ","date":"2024-10-19T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A302-%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E5%8E%82%E7%B1%BB/","title":"DeskFlow 异步网络接口（02） — 网络接口的工厂类"},{"content":" 1. 整体设计 2. 类型设计 2.1. 监听Socket 2.1.1. TCP监听Socket实现 2.1.2. 加密监听Socket实现 2.2. 数据Socket 2.2.1. TCP数据Socket 2.2.2. 加密的TCP数据Socket 3. 网络地址 1. 整体设计 网络模块涉及到 4 个部分：\n网络地址： NetworkAddress，统一不同平台上网络地址的表示。 网络套接字： ISocket，规定了套接字类型的核心接口，分为监听Socket和数据Socket，依赖于ARCH层和多路复用器处理网络事件。 IDataSocket，数据Socket，实现异步数据I/O功能。 IListenSocket，监听Socekt，实现服务端功能。 多路复用器： SocketMultiplexer，监控网络I\\O，例如客户端连接、数据收发，也是基于ARCH层的。 多路复用器任务： ISocketMultiplexerJob，这是对于网络I/O的任务的封装。 工厂模式： 通过ISocketFactory创建不同的网络套接字。 事件机制： 接收的网络数据保存到缓冲区，然后通过事件通过业务层数据已到达。同时事件机制也要处理一些网络异常事件。 2. 类型设计 网络接口抽象如下，由派生类去实现不同类型的网络接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 网络接口的抽象基类 class ISocket : public IInterface { public: virtual void bind(const NetworkAddress \u0026amp;) = 0; virtual void close() = 0; /* * 返回this，用于事件驱动架构中标识事件源， * 与EventQueue配合实现事件分发，作为回调函数上下文参数传递对象指针。 */ virtual void *getEventTarget() const = 0; }; 2.1. 监听Socket 1 2 3 4 5 6 7 8 9 10 class IListenSocket : public ISocket { public: /* 向多路复用器中注册TcpServer任务 */ virtual std::unique_ptr\u0026lt;IDataSocket\u0026gt; accept() = 0; void bind(const NetworkAddress \u0026amp;) override = 0; void close() override = 0; void *getEventTarget() const override = 0; }; 2.1.1. TCP监听Socket实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class TCPListenSocket : public IListenSocket { public: TCPListenSocket(IEventQueue *events, SocketMultiplexer *socketMultiplexer, IArchNetwork::AddressFamily family); TCPListenSocket(TCPListenSocket const \u0026amp;) = delete; TCPListenSocket(TCPListenSocket \u0026amp;\u0026amp;) = delete; ~TCPListenSocket() override; TCPListenSocket \u0026amp;operator=(TCPListenSocket const \u0026amp;) = delete; TCPListenSocket \u0026amp;operator=(TCPListenSocket \u0026amp;\u0026amp;) = delete; // ISocket overrides void bind(const NetworkAddress \u0026amp;) override; // bind并且开始listen，也就是给多路复用器添加listen任务。 void close() override; void *getEventTarget() const override; /* * 启动TCPServer的监听服务。 * 内部调用了 setListeningJob() */ std::unique_ptr\u0026lt;IDataSocket\u0026gt; accept() override; ISocketMultiplexerJob *serviceListening(ISocketMultiplexerJob *, bool, bool, bool); protected: /* * 给多路复用器添加一个任务（accept任务），用于监听客户端的连接。 * 这个任务的任务函数就是serviceListening。 */ void setListeningJob(); IEventQueue *m_events; ArchSocket m_socket; // Socket实体 SocketMultiplexer *m_socketMultiplexer; // 关联的多路复用器 private: std::mutex m_mutex; }; 2.1.2. 加密监听Socket实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // SecurityLevel枚举类，用于控制客户端与服务器的通信安全策略。 enum class SecurityLevel { PlainText, // 不加密 Encrypted, // 启用TLS加密 PeerAuth // 双向认证加密 }; class SecureListenSocket : public TCPListenSocket { public: SecureListenSocket( IEventQueue *events, SocketMultiplexer *socketMultiplexer, IArchNetwork::AddressFamily family, SecurityLevel securityLevel = SecurityLevel::PlainText ); std::unique_ptr\u0026lt;IDataSocket\u0026gt; accept() override; private: const SecurityLevel m_securityLevel; }; 2.2. 数据Socket 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 数据Socket基类。 class IDataSocket : public ISocket, public deskflow::IStream { public: /* 连接失败事件的附加信息 */ class ConnectionFailedInfo { public: explicit ConnectionFailedInfo(const char *what) : m_what(what) { // do nothing } std::string m_what; }; explicit IDataSocket(const IEventQueue *events) { // do nothing } virtual void connect(const NetworkAddress \u0026amp;) = 0; void bind(const NetworkAddress \u0026amp;) override = 0; /* * 正常情况下这两货不会在这里重写，实际是在TCPSocket类型里重写。 * 但是，VC++6 对多重继承的支持存在缺陷，无法正确解析具有相同签名的方法。 * 在 VC++6 中，如果一个类从多个基类继承了相同签名的方法， 编译器会错误地认为这些方法是“未使用的局部变量”，并警告或移除它们。 * 所以这里通过提供非纯虚函数的默认实现，绕过编译器对多重继承的错误处理。 */ void close() override; void *getEventTarget() const override; /* 流操作 */ uint32_t read(void *buffer, uint32_t n) override = 0; void write(const void *buffer, uint32_t n) override = 0; void flush() override = 0; void shutdownInput() override = 0; void shutdownOutput() override = 0; bool isReady() const override = 0; uint32_t getSize() const override = 0; virtual bool isFatal() const = 0; }; 2.2.1. TCP数据Socket 实现了TCPSocket的异步的连接、I/O等等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 class TCPSocket : public IDataSocket { public: TCPSocket( IEventQueue *events, SocketMultiplexer *socketMultiplexer, IArchNetwork::AddressFamily family = IArchNetwork::AddressFamily::INet ); TCPSocket(IEventQueue *events, SocketMultiplexer *socketMultiplexer, ArchSocket socket); ~TCPSocket() override; // ... // ... uint32_t read(void *buffer, uint32_t n) override; // 从接收缓冲区读取n个字节到buffer中。 void write(const void *buffer, uint32_t n) override; // 将buffer中的字节写入发送缓冲区，并触发异步发送流程（发送事件） void flush() override; // 等待发送缓冲区刷新完成。 void shutdownInput() override; // 关闭Socket的接收端，清空发送缓冲区，并从多路复用器移除该Socket对应的任务。 void shutdownOutput() override; bool isReady() const override; // 接收缓冲区有数据 uint32_t getSize() const override; // 接收缓冲区字节数 // 发起连接，并向多路复用器注册读写任务。 void connect(const NetworkAddress \u0026amp;) override; /* * 创建并返回与套接字关联的异步I/O任务对象(多路复用器任务)。 * 如果suocket还没有建立连接，就创建连接建立任务，也就是serviceConnecting。 * 如果已经建立建立，那就创建读写任务，也就是serviceConnected。 */ virtual ISocketMultiplexerJob *newJob(); protected: /* 表示任务执行的结果，多路复用器是以 “任务链” 的形式运行任务 */ enum class JobResult { Break = -1, // 强制终止任务链，用于处理不可恢复错误（如断开连接） Retry, // 保持当前任务继续执行，适用于暂时性阻塞（如等待I/O） New // 需要创建新任务，上一个任务已经完成。 }; // ... /* * 非阻塞I/O，并处理网络断开情况，由serviceConnected调用。 * doRead(): 读取网络数据保存到接收缓冲区中，当输入缓冲区从空变为有数据时，通过事件队列通知上层有数据到达当输入缓冲区从空变为有数据时，通过事件队列通知上层有数据到达。 * doWrite()：将发送缓冲区中的数据发送出去。 */ virtual JobResult doRead(); virtual JobResult doWrite(); /* * 注册任务到多路复用器。 * 如果参数为nullptr，就移除多路复用器中与当前Socket绑定的任务。 * 如果不为nullptr，就注册该任务到多路复用器。 */ void setJob(ISocketMultiplexerJob *); // ... // 获取/设置状态的接口 // ... void sendEvent(EventTypes); /* 刷新发送缓冲区（从输出缓冲区移除已成功发送的字节数），并唤醒所有等待m_flushed的线程。*/ void discardWrittenData(int bytesWrote); IEventQueue *m_events; StreamBuffer m_inputBuffer; // 接收缓冲区 StreamBuffer m_outputBuffer; // 发送缓冲区 private: void init(); // 初始化TCP套接字的状态并配置网络参数，并且禁用禁用Nagle算法。 void sendConnectionFailedEvent(const char *); void onInputShutdown(); // 清空接收缓存区。 void onOutputShutdown(); void onConnected(); // 建立连接后更新Socekt状态。 void onDisconnected(); // 断开连接后更新Socket状态。 /* 多路复用器任务 */ ISocketMultiplexerJob *serviceConnecting(ISocketMultiplexerJob *, bool, bool, bool); ISocketMultiplexerJob *serviceConnected(ISocketMultiplexerJob *, bool, bool, bool); bool m_readable; // Socket是否可读 bool m_writable; bool m_connected; // 连接状态 Mutex m_mutex; ArchSocket m_socket; CondVar\u0026lt;bool\u0026gt; m_flushed; // 用于在多线程场景下同步TCP套接字的\u0026#34;数据刷新完成\u0026#34;状态。当发送缓冲区的数据被完全发送到网络后，通过 m_flushed 通知等待的线程继续执行。 SocketMultiplexer *m_socketMultiplexer; }; 2.2.2. 加密的TCP数据Socket 继承自TCPSocket，在TCPSocket基础上增加了SSL加密。\n1 2 3 4 class SecureSocket : public TCPSocket { // ... } 3. 网络地址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class NetworkAddress { public: NetworkAddress() = default; explicit NetworkAddress(int port); // port： 端口 NetworkAddress(const std::string \u0026amp;hostname, int port = 0); // 使用主机名，端口构造 NetworkAddress(const NetworkAddress \u0026amp;); ~NetworkAddress(); NetworkAddress \u0026amp;operator=(const NetworkAddress \u0026amp;); size_t resolve(size_t index = 0); // 将主机名解析为网络地址（IP地址 + 端口） bool operator==(const NetworkAddress \u0026amp;address) const; bool operator!=(const NetworkAddress \u0026amp;address) const; bool isValid() const; // m_address不为空时返回true const ArchNetAddress \u0026amp;getAddress() const; // 返回 m_address int getPort() const; // m_port std::string getHostname() const; // m_hostname private: void checkPort() const; // 端口是否有效，0 ~ 65535 private: ArchNetAddress m_address = nullptr; std::string m_hostname; int m_port = 0; }; ","date":"2024-10-13T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A301-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%B0%81%E8%A3%85/","title":"DeskFlow 异步网络接口（01） — 套接字封装"},{"content":" 1. 事件的基本结构 2. 事件队列的实现 2.1. 事件队列的上层实现 2.2. 事件队列的平台层实现 1. 事件的基本结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Event { public: using Flags = uint32_t; // 事件标志位，用于控制事件处理的行为模式 struct EventFlags { inline static const Flags NoFlags = 0x00; // 无任何特殊行为的标志位 inline static const Flags DeliverImmediately = 0x01; // 立即投递：事件将被立即处理并释放,用于需要即时响应的事件（如输入设备状态更新） inline static const Flags DontFreeData = 0x02; // 禁止释放数据：在事件销毁时不自动释放关联数据， 用于需要跨事件传递数据的场景（如剪贴板共享数据） }; Event() = default; /* * type： 事件类型。 * target: 事件的接收者。 * data: 事件的附加数据，必须是POD类型（不能包含构造函数/析构函数或依赖其他非POD类型的类型），若数据为复杂对象（如 std::string），需使用 setDataObject() 或其他构造函数。 * flags: 事件标志。 */ Event(EventTypes type, void *target = nullptr, void *data = nullptr, Flags flags = EventFlags::NoFlags); Event(EventTypes type, void *target, EventData *dataObject); // 在这里，EventData就是 static void deleteData(const Event \u0026amp;); // 释放m_data和m_dataObject void setDataObject(EventData *dataObject); // m_dataObject = dataObject; EventTypes getType() const; // m_type void *getTarget() const; // m_target void *getData() const; // m_data EventData *getDataObject() const; // m_dataObject Flags getFlags() const; // m_flags private: EventTypes m_type = EventTypes::Unknown; // 事件类型 void *m_target = nullptr; // 事件接受者 void *m_data = nullptr; // 附加数据，POD类型 Flags m_flags = EventFlags::NoFlags; // 事件处理策略 EventData *m_dataObject = nullptr; // 非POD类型附加数据 }; 76个事件类型\n定义了 76 个事件类型，涵盖以下核心功能领域：\n连接管理（ClientConnected、ClientDisconnected、DataSocketConnected 等） 输入设备控制（KeyStateKeyDown、PrimaryScreenMotionOnPrimary 等） 剪贴板同步（ClipboardGrabbed、ClipboardChanged） 安全与加密（ClientConnectionRefused、ClientConnectionFailed） 系统状态（ScreenSuspend、ScreenResume、OsxScreenConfirmSleep） 协议交互（ClientProxyReady、ClientProxyUnknownSuccess） 用户界面反馈（ServerScreenSwitched、ServerLockCursorToScreen） 1 2 3 4 enum class EventTypes : uint32_t { // ... }; 2. 事件队列的实现 2.1. 事件队列的上层实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class IEventQueue : public IInterface { public: // 事件处理逻辑 using EventHandler = std::function\u0026lt;void(const Event \u0026amp;)\u0026gt;; class TimerEvent { public: EventQueueTimer *m_timer; uint32_t m_count; }; // 1. 事件循环核心逻辑，处理挂起的事件，并通过dispatchEvent()分发事件。 virtual void loop() = 0; // 2. 事件订阅/移除，将handler添加到一个Hash表中。 virtual void addHandler(EventTypes type, void *target, const EventHandler \u0026amp;handler) = 0; virtual void removeHandler(EventTypes type, void *target) = 0; virtual void removeHandlers(void *target) = 0; // 3. 发布事件： 添加事件到事件缓冲区 virtual void addEvent(const Event \u0026amp;event) = 0; // 4. 事件分发，就是执行对应的handler virtual bool dispatchEvent(const Event \u0026amp;event) = 0; // 5. 动态切换底层事件缓冲区 virtual void adoptBuffer(IEventQueueBuffer *) = 0; virtual bool getEvent(Event \u0026amp;event, double timeout = -1.0) = 0; virtual EventQueueTimer *newTimer(double duration, void *target) = 0; virtual EventQueueTimer *newOneShotTimer(double duration, void *target) = 0; virtual void deleteTimer(EventQueueTimer *) = 0; virtual void waitForReady() const = 0; virtual bool isEmpty() const = 0; virtual void *getSystemTarget() = 0; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class EventQueue : public IEventQueue { public: EventQueue(); EventQueue(EventQueue const \u0026amp;) = delete; EventQueue(EventQueue \u0026amp;\u0026amp;) = delete; ~EventQueue() override; EventQueue \u0026amp;operator=(EventQueue const \u0026amp;) = delete; EventQueue \u0026amp;operator=(EventQueue \u0026amp;\u0026amp;) = delete; // IEventQueue overrides void loop() override; // 将事件队列设置为就绪状态，并唤醒等待线程， 把挂起的事件添加到事件缓冲区等待处理。 然后分发事件缓冲区中的事件。 void adoptBuffer(IEventQueueBuffer *) override; // 采用一个新的事件队列缓冲区，替换当前正在使用的缓冲区。 bool getEvent(Event \u0026amp;event, double timeout = -1.0) override; bool dispatchEvent(const Event \u0026amp;event) override; // 分发事件，就是运行对应的事件处理器。 void addEvent(const Event \u0026amp;event) override; // 将事件添加到事件缓冲区： 如果是立即事件就立即执行，如果缓冲区未就绪就添加到挂起队列中。 EventQueueTimer *newTimer(double duration, void *target) override; // 创建定时器，并将添加到定时器管理结构中。 EventQueueTimer *newOneShotTimer(double duration, void *target) override; // 创建一次性定时器，并将添加到定时器管理结构中。 void deleteTimer(EventQueueTimer *) override; void addHandler(EventTypes type, void *target, const EventHandler \u0026amp;handler) override; // 向处理器表中添加事件处理器。 void removeHandler(EventTypes type, void *target) override; void removeHandlers(void *target) override; bool isEmpty() const override; // 事件队列是否为空（事件缓冲区为空 \u0026amp; 定时器队列为空）。 void *getSystemTarget() override; // 返回 m_systemTarget。 void waitForReady() const override; // 等待事件队列就绪。 private: const EventHandler *getHandler(EventTypes type, void *target) const; uint32_t saveEvent(const Event \u0026amp;event); // 将事件存储到m_events中。 Event removeEvent(uint32_t eventID); // 将事件从m_events中移除。 bool hasTimerExpired(Event \u0026amp;event); // 检测并处理到期的定时器事件，如果有到期的定时器就将信息填充到event。 double getNextTimerTimeout() const; // 查询定时器件超时时间。 void addEventToBuffer(const Event \u0026amp;event); // 将事件添加到事件缓冲区。 bool processEvent(Event \u0026amp;event, double timeout, Stopwatch \u0026amp;timer); private: class Timer // EventQueueTimer 本身只作为类型标识符存在，实际的定时器功能完全由 EventQueue::Timer 类承担。 { public: Timer(EventQueueTimer *, double timeout, double initialTime, void *target, bool oneShot); ~Timer() = default; void reset(); // m_time = m_timeout; 重新开始计时 Timer \u0026amp;operator-=(double); // 定时器时间递减dt operator double() const; // 查看当前时间，m_time bool isOneShot() const; // 定时器是否为单次触发模式 EventQueueTimer *getTimer() const; // return m_timer; void *getTarget() const; // return m_target; void fillEvent(TimerEvent \u0026amp;) const; // 将当前定时器状态记录到记录到的定时器事件中，包括事件队列关联的定时器对象，以及触发次数。 private: EventQueueTimer *m_timer; // 事件队列关联的定时器对象 double m_timeout; void *m_target; // 事件的目标对象 bool m_oneShot; // 单次触发标志 double m_time; // 当前时间 }; using Timers = std::set\u0026lt;EventQueueTimer *\u0026gt;; using TimerQueue = PriorityQueue\u0026lt;Timer\u0026gt;; using EventTable = std::map\u0026lt;uint32_t, Event\u0026gt;; using EventIDList = std::vector\u0026lt;uint32_t\u0026gt;; using TypeHandlerTable = std::map\u0026lt;EventTypes, EventHandler\u0026gt;; using HandlerTable = std::map\u0026lt;void *, TypeHandlerTable\u0026gt;; int m_systemTarget = 0; // 标识系统事件，将区分系统事件和用户事件。 mutable std::mutex m_mutex; // 事件缓存区 std::unique_ptr\u0026lt;IEventQueueBuffer\u0026gt; m_buffer; // 事件队列缓冲区，负责事件队列不同平台上的实际操作 // 事件的存储与索引 EventTable m_events; EventIDList m_oldEventIDs; // 定时器 Stopwatch m_time; // 测试时间间隔，用于文件传输等等。 Timers m_timers; // 存储和管理当前活跃的计时器。 TimerQueue m_timerQueue; // 管理定时器（Timer）的优先队列，确保定时器事件能够按照正确的时间顺序被处理。 TimerEvent m_timerEvent; // 用来记录定时器事件。 // 管理事件处理器 HandlerTable m_handlers; Mutex *m_readyMutex = nullptr; // m_readyCondVar的守护者。 CondVar\u0026lt;bool\u0026gt; *m_readyCondVar = nullptr; // 事件队列是否就绪。 std::queue\u0026lt;Event\u0026gt; m_pending; // 管理挂起的事件。 }; 2.2. 事件队列的平台层实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class IEventQueueBuffer : public IInterface { public: enum class Type : uint8_t { Unknown, System, // 系统事件 User // 用户事件 }; virtual void init() = 0; // 阻塞等待事件，最多等待 timeout 秒。 virtual void waitForEvent(double timeout) = 0; // 从缓冲区取出事件，填充 event 和 dataID。 virtual Type getEvent(Event \u0026amp;event, uint32_t \u0026amp;dataID) = 0; // 将用户事件添加到缓冲区，并通知等待线程。 virtual bool addEvent(uint32_t dataID) = 0; virtual bool isEmpty() const = 0; virtual EventQueueTimer *newTimer(double duration, bool oneShot) const = 0; virtual void deleteTimer(EventQueueTimer *) const = 0; }; 针对Win、Linux(WayLand、X11)、Mac都有对应的派生类实现，以Linux(Wayland)平台为例，简单看一下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class EiEventQueueBuffer : public IEventQueueBuffer { public: EiEventQueueBuffer(const EiScreen *screen, ei *ei, IEventQueue *events); ~EiEventQueueBuffer() override; // IEventQueueBuffer overrides void init() override { /* do nothing */ } void waitForEvent(double timeout_in_ms) override; Type getEvent(Event \u0026amp;event, uint32_t \u0026amp;dataID) override; bool addEvent(uint32_t dataID) override; bool isEmpty() const override; EventQueueTimer *newTimer(double duration, bool oneShot) const override; void deleteTimer(EventQueueTimer *) const override; private: ei *m_ei; // EI事件，libei，WayLand环境下输入设备模拟。 IEventQueue *m_events; // 指向关联的事件队列。 std::queue\u0026lt;std::pair\u0026lt;bool, uint32_t\u0026gt;\u0026gt; m_queue; // 内部事件队列，存储事件对（第一个元素表示是否为系统事件，第二个元素为数据ID）。 // 非阻塞管道，构造函数中创建。 int m_pipeWrite; // 写端 int m_pipeRead; // 读端 mutable std::mutex m_mutex; }; 这里需要关注的是m_pipeWrite和m_pipeRead两个成员变量，这两货分别是管道的写端和读端，但这个管道不是用来发送数据的，而是用来实现线程间同步机制的：\n创建管道用于线程通信：在构造函数中，使用pipe2()系统调用创建一个非阻塞的管道，m_pipeRead作为读端，m_pipeWrite作为写端。 事件等待监听：在waitForEvent()方法中，使用poll()同时监听两个文件描述符：libei的事件文件描述符和管道的读端m_pipeRead。 唤醒等待线程：当有新事件通过addEvent()方法添加到队列时，会向管道的写端m_pipeWrite写入数据来唤醒可能正在waitForEvent()中阻塞等待的线程。 清理管道数据：当管道有数据可读时，会读取并丢弃这些数据，因为数据本身并不重要，重要的是唤醒动作。 这是一个典型的生产者-消费者模式中的唤醒机制。管道的作用仅仅是作为信号传递工具。当有线程调用addEvent()添加事件时，除了将事件加入队列外，还会通过管道唤醒可能正在等待的事件处理线程，确保事件能够及时被处理。\n","date":"2024-10-12T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E4%BA%8B%E4%BB%B6%E6%A1%86%E6%9E%B602-%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A/","title":"DeskFlow 事件框架（02） — 代码解释"},{"content":" 1. Linux Bridge 2. Linux Bond 3. Linux VLAN 3.1. linux中VLAN的实现方式 1. Linux Bridge Bridge，就是桥接，是一种连接网络设备的方式，把一台机器上的若干网络接口“连接”起来，当其中一个网口收到报文，会被复制到其他网口并发送出去，这样网口之间的报文就能够相互转发。看起来像是“交换机”，但是有所不同，例如linux内核就支持网口的桥接，交换机只会也只需要转发与丢弃，而Linux内核本身就是一台机器，它也是要接收网络报文的，也就是转发，丢弃，接收。\nLinux内核通过虚拟的网桥设备实现桥接，这个“网桥”可以连接若干个以太网接口设备。在虚拟化平台上，我门当然要先创建“网桥”，然后连接一个物理网卡，在我们将创建虚拟机的时候，将虚拟机的网口连接到这个网桥上，就像是将多个PC设备连接到交换机，从而将它们桥接起来。\n2. Linux Bond 将多个物理网卡绑定为一个逻辑网卡，这样可以实现带宽倍增，提高吞吐量。\n3. Linux VLAN 将网络划分为多个逻辑网络，使得不同的VLAN可以在同一物理网段上实现隔离通信，是一种基于网络层的虚拟局域网技术，是通过内核的网络子系统实现的，当一个VLAN数据包进入系统时，内核会根据数据包中的VLAN标记信息，将数据包转发到相应的VLAN接口或者物理接口上。linux中有两种方法实现VLAN：内核模块、VLAN交换机，内核模块方式更加灵活，需要更多配置工作，VLAN更易于配置和管理，但是会带来硬件成本。\n3.1. linux中VLAN的实现方式 内核模块方式\n在内核中加载VLAN模块来实现，\nVLAN交换机 通过软件模拟交换机。\n","date":"2024-10-07T00:00:00Z","permalink":"https://zuoco.github.io/p/linux-%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C/","title":"Linux 虚拟网络"},{"content":" 1. 设计思路 2. 核心类型 2.1. 顶层接口 2.2. 平台层实现 3. 定时器 4. 线程安全 5. 事件处理器 6. 事件订阅 7. 事件发布 8. 事件循环 1. 设计思路 DeskFlow的事件框架实现了一个基于发布-订阅模式的异步事件系统。事件队列使用了三层设计： 接口层（IEventQueue）、平台缓冲层（IEventQueueBuffer）、平台实现层（各 OS 特定实现）。发布者和订阅者类型通过关联一个IEventQueue类型的成员与事件框架来发布或者订阅事件。\nIEventQueue，事件队列的顶层接口，供发布者和订阅者使用。 IEventQueueBuffer，队列的底层实现，封装实际的平台操作，这是一个抽象类，所以需要每种操作系统提供对应的派生类实现。 2. 核心类型 2.1. 顶层接口 类型 职能 Event 描述了事件的基本结构，包含事件类型、目标对象、数据和标志位。\n事件支持两种数据类型：POD（简单数据）和非POD对象（复杂C++对象） IEventQueue 接口类定义了事件队列的核心接口，包括事件的注册和移除、循环、分发等等，由派生类EventQueue提供具体实现 2.2. 平台层实现 IEventQueueBuffer为IEventQueue提供平台层的支持，它定义了事件的三种类型：无事件、系统事件和用户事件，并提供了等待事件、获取事件和添加事件的基本方法供EventQueue使用。\n类型 功能 IEventQueueBuffer 事件队列缓冲区抽象基类 EiEventQueueBuffer Linux-WayLand平台 继承自IEventQueueBuffer XWindowsEventQueueBuffer Linux-X11平台 继承自IEventQueueBuffer MSWindowsEventQueueBuffer Win平台 继承自IEventQueueBuffer OSXEventQueueBuffer Mac平台 继承自IEventQueueBuffer 5. 事件处理器 使用通用函数包装器封装可调用对象。\n1 2 3 4 5 class IEventQueue : public IInterface { public: using EventHandler = std::function\u0026lt;void(const Event \u0026amp;)\u0026gt;; }; 6. 事件订阅 通过 adoptHandler 方法将特定的事件类型与处理器进行绑定，建立事件到处理逻辑的映射关系，并添加到m_handler中。\n1 virtual void addHandler(EventTypes type, void *target, const EventHandler \u0026amp;handler) = 0; 7. 事件发布 发布事件 通过 addEvent 方法发布事件。该方法会根据事件标志决定是立即分发还是加入队列。 1 2 3 // 如果立即分发，就调用dispatchEvent(event); // 如果缓冲处理，就调用addEventToBuffer(event); virtual void addEvent(const Event \u0026amp;event) = 0; 事件分发 dispatchEvent 方法负责将事件路由到相应的处理器。它首先查找特定事件类型的处理器，如果找不到就使用未知事件类型的处理器。 1 virtual bool dispatchEvent(const Event \u0026amp;event) = 0; // 就是去执行event关联的事件处理器 8. 事件循环 主事件循环，持续处理队列中的事件直到接收到退出事件。\n1 virtual void loop() = 0; // 通过dispatchEvent分发事件 也是业务层的业务循环主要逻辑，我们以客户端为例：\n1 2 3 4 5 6 7 8 int ClientApp::mainLoop() { // ... m_events-\u0026gt;loop(); // 处理事件 // ... } 4. 线程安全 使用互斥锁和条件变量来确保多线程环境下的安全性。\n1 2 3 4 5 6 7 8 class EventQueue : public IEventQueue { // ... private: Mutex *m_readyMutex = nullptr; // 队列是否就绪 CondVar\u0026lt;bool\u0026gt; *m_readyCondVar = nullptr; // 等待队列就绪 }; 3. 定时器 定时器类型的定义内嵌到了EventQueue中，支持一次性和重复定时器。\n1 2 3 4 5 6 7 8 9 10 11 class EventQueue : public IEventQueue { // ... private: class Timer { // EventQueueTimer功能的实际实现 }; // ... }; 支持创建周期性或一次性的定时事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class IEventQueue : public IInterface { // ... public: // 定时器事件 class TimerEvent { public: EventQueueTimer *m_timer; //!\u0026lt; The timer uint32_t m_count; //!\u0026lt; Number of repeats }; // ... }; ","date":"2024-10-06T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E4%BA%8B%E4%BB%B6%E6%A1%86%E6%9E%B601-%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/","title":"DeskFlow 事件框架（01） — 整体设计"},{"content":" 1. 互斥量实体 2. 条件变量实体 3. 封装互斥量 4. 封装条件变量 类型 功能 ArchMutexImpl 互斥量实体，互斥量在不同平台上的表示 ArchCondImpl 条件变量实体，条件变量在不同平台上的表示 Mutex 封装互斥量操作 CondVarBase 封装条件变量操作 CondVar 类模板，包含额外数据，继承自CondVarBase 1. 互斥量实体 Linux平台：\n1 2 3 4 5 class ArchMutexImpl { public: pthread_mutex_t m_mutex; }; Windows平台：\n1 2 3 4 5 class ArchMutexImpl { public: CRITICAL_SECTION m_mutex; }; 其他类型定义时使用类型别名：\n1 using ArchMutex = ArchMutexImpl *; 2. 条件变量实体 Linux：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class ArchCondImpl { public: pthread_cond_t m_cond; }; Windows: ```cpp class ArchCondImpl { public: enum { kSignal = 0, // 唤醒一个等待的线程 kBroadcast // 唤醒所有等待的线程 }; HANDLE m_events[2]; mutable int m_waitCount; // 记录当前等待的线程数量 ArchMutex m_waitCountMutex; // 保护 m_waitCount 的访问，确保多线程环境下读写 m_waitCount 的线程安全 }; 其他类型定义时使用类型别名：\n1 using ArchCond = ArchCondImpl *; 3. 封装互斥量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Mutex { public: Mutex(); Mutex(const Mutex \u0026amp;); // 会创建一个新的互斥量并返回 ~Mutex(); Mutex \u0026amp;operator=(const Mutex \u0026amp;); // 没有赋值操作，只是直接返回*this // 互斥量操作 void lock() const; void unlock() const; private: friend class CondVarBase; // 允许 CondVarBase 访问 Mutex 的私有成员 ArchMutex m_mutex; }; 4. 封装条件变量 条件变量基类型，基于ARCH层封装了条件变量的基础操作（锁、解锁、信号通知、等待），与互斥锁（Mutex）绑定，确保线程安全。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class CondVarBase { public: explicit CondVarBase(Mutex *mutex); // 初始化m_cond，绑定互斥量 ~CondVarBase(); // 析构条件变量 /* 互斥量操作 */ void lock() const; void unlock() const; /* 条件变量操作 */ void signal(); // 唤醒一个等待线程 void broadcast(); // 广播唤醒所有等待m_cond的线程 /* */ bool wait(double timeout = -1.0) const; // 带超时机制的条件变量等待，内部调用wait() bool wait(Stopwatch \u0026amp;timer, double timeout) const; // 条件变量等待，内部设置了取消点 Mutex *getMutex() const; private: Mutex *m_mutex; // 与条件变量关联的互斥锁 ArchCond m_cond; // 条件变量 }; CondVar\n携带额外数据的派生类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template \u0026lt;class T\u0026gt; class CondVar : public CondVarBase { public: CondVar(Mutex *mutex, const T \u0026amp;value); CondVar(const CondVar \u0026amp;); ~CondVar(); CondVar \u0026amp;operator=(const CondVar \u0026amp;cv); CondVar \u0026amp;operator=(const T \u0026amp;v); operator const volatile T \u0026amp;() const; private: volatile T m_data; // 额外数据 }; 重载“\u0026amp;”运算符：\n1 2 3 4 5 template \u0026lt;class T\u0026gt; inline CondVar\u0026lt;T\u0026gt;::operator const volatile T \u0026amp;() const { return m_data; // 将m_data转换为 const volatile T\u0026amp; 类型的引用。 } 重载“\u0026amp;”运算符用于支持隐式转换：\n1 2 CondVar\u0026lt;int\u0026gt; cv; int val = cv; // 隐式调用 operator const volatile T \u0026amp;() ","date":"2024-10-05T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%86%E6%9E%B603-%E4%BA%92%E6%96%A5%E9%87%8F%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/","title":"DeskFlow 多线程框架（03） — 互斥量与条件变量"},{"content":" 1. 总体架构设计 2. 核心设计原则 3. 任务执行模型 3.1. Job模式 3.2. 异常安全的任务执行 4. 线程控制流设计 4.1. 异常驱动的控制流 4.2. 取消点机制 5. 资源管理设计 6. 线程同步和通信 7. 代码 7.1. Thread线程类设计 7.2. 不同平台上的线程实体 1. 总体架构设计 Thread类将平台无关的接口与平台相关的实现分离。Thread类作为高层接口，本身不包含任何平台特定的代码，所有具体操作都通过ARCH宏委托给具体的平台实现（如POSIX或Windows）。这个类本身只是一个线程句柄，删除Thread对象并不会终止线程本身。这种设计允许多个Thread对象引用同一个线程，提高了灵活性。\n1 2 3 4 5 6 7 class Thread { // ... // ... private: ArchThread m_thread = nullptr; }; Thread类的实际操作是通过ARCH宏委托给平台特定的实现，实现了跨平台兼容性：\n1 2 3 4 5 6 7 8 Thread::Thread(IJob *job) { m_thread = ARCH-\u0026gt;newThread(\u0026amp;Thread::threadFunc, job); // 委托给ARCH层（IArchMultithread）实现 if (m_thread == nullptr) { delete job; throw XMTThreadUnavailable(); } } 2. 核心设计原则 Handle语义设计： 上面也提到了，Thread类被设计为一个**句柄（Handle）**而不是线程对象本身。 他们这种设计允许：\n多个Thread对象引用同一个底层线程。 复制构造和赋值操作不会创建新线程。 RAII风格的资源管理。 禁止继承设计： hread类的注释中明确标注不允继承（可以使用final关键字），这是一个精心设计的决定，确保Thread类作为一个轻量级句柄，不会被扩展而导致复杂性增加。\n3. 任务执行模型 3.1. Job模式 Thread采用Job模式来封装要执行的任务。通过IJob接口，Thread可以执行任意类型的任务，看前面展示的构造函数就知道了，Thread的构造函数接受一个IJob*指针，并获得其所有权，这种设计带来了一些好处：\n解耦了线程管理和任务逻辑。 支持灵活的任务封装（函数、成员函数等）。 简化了线程的创建和使用。 3.2. 异常安全的任务执行 Thread类型通过threadFunc执行线程的“任务”，而这个threadFunc方法实现了完善的异常处理机制，能够正确处理各种异常情况并确保资源清理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 void *Thread::threadFunc(void *vjob) { // get this thread\u0026#39;s id for logging IArchMultithread::ThreadID id; { ArchThread thread = ARCH-\u0026gt;newCurrentThread(); id = ARCH-\u0026gt;getIDOfThread(thread); ARCH-\u0026gt;closeThread(thread); } auto *job = static_cast\u0026lt;IJob *\u0026gt;(vjob); // run job void *result = nullptr; try { // go LOG((CLOG_DEBUG1 \u0026#34;thread 0x%08x entry\u0026#34;, id)); job-\u0026gt;run(); LOG((CLOG_DEBUG1 \u0026#34;thread 0x%08x exit\u0026#34;, id)); } catch (XThreadCancel \u0026amp;) { // client called cancel() LOG((CLOG_DEBUG1 \u0026#34;caught cancel on thread 0x%08x\u0026#34;, id)); delete job; throw; } catch (XThreadExit \u0026amp;e) { // client called exit() result = e.m_result; LOG((CLOG_DEBUG1 \u0026#34;caught exit on thread 0x%08x, result %p\u0026#34;, id, result)); } catch (XBase \u0026amp;e) { LOG((CLOG_ERR \u0026#34;exception on thread 0x%08x: %s\u0026#34;, id, e.what())); delete job; throw; } catch (std::exception \u0026amp;e) { LOG((CLOG_ERR \u0026#34;standard exception on thread 0x%08x: %s\u0026#34;, id, e.what())); delete job; throw; } catch (...) { LOG((CLOG_ERR \u0026#34;non-exception throw on thread 0x%08x: \u0026lt;unknown\u0026gt;\u0026#34;, id)); delete job; throw; } delete job; return result; } 4. 线程控制流设计 4.1. 异常驱动的控制流 Thread类使用异常来实现线程的控制流，而不是传统的返回值方式，有两种情况：\n线程退出：通过抛出XThreadExit异常。 线程取消：通过XThreadCancel异常实现。 这种设计确保了栈展开（stack unwinding）和自动对象的正确析构，是C++中实现线程安全退出的优雅方式。\n4.2. 取消点机制 Thread实现了**取消点（Cancellation Point）**机制，允许线程在特定点检查并响应取消请求。Thread也是通过ARCH层实现多线程功能的，而ARCH代理了平台层实现，在平台层的实现类中会有m_cancelling和m_cancell两个成员变量，testCancel()就是根据这两个成员变量值决定是否取消线程：\n1 static void testCancel(); // 通过抛出XThreadCancel异常 这种设计确保线程能够在安全的时机响应取消请求，避免资源泄漏。\n5. 资源管理设计（RAII） Thread类严格遵循RAII原则：\n构造函数获取资源（创建底层线程）。\n析构函数释放资源。\n拷贝构造和赋值操作正确管理引用计数，实现了类似智能指针的引用计数管理。\n析构函数，释放当前线程句柄资源，对应的线程实体引用计数-1，如果引用计数为0，就释放线程实体资源。\n1 2 3 4 Thread::~Thread() { ARCH-\u0026gt;closeThread(m_thread); // 处理引用计数，销毁当前线程句柄资源（Thread类本身只是一个线程句柄） } 拷贝构造，当前引用了thread的线程实体，这个线程实体的因不用计数+1。 1 2 3 4 Thread::Thread(const Thread \u0026amp;thread) : m_thread{ARCH-\u0026gt;copyThread(thread.m_thread)} { // do nothing } 赋值操作，和拷贝构造一样。 1 2 3 4 5 6 7 8 9 10 11 Thread \u0026amp;Thread::operator=(const Thread \u0026amp;thread) { // copy given thread and release ours ArchThread copy = ARCH-\u0026gt;copyThread(thread.m_thread); ARCH-\u0026gt;closeThread(m_thread); // cut over m_thread = copy; return *this; } 6. 线程同步和通信 Thread类提供了基本的线程同步操作：\n等待线程终止： wait()方法等待线程退出，支持超时。 1 2 3 4 bool Thread::wait(double timeout) const { return ARCH-\u0026gt;wait(m_thread, timeout); } 获取执行结果： getResult()方法获取线程退出值。 1 2 3 4 5 6 7 void *Thread::getResult() const { if (wait()) // 阻塞等待线程退出 return ARCH-\u0026gt;getResultOfThread(m_thread); else return nullptr; } 7. 代码 7.1. Thread线程类设计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Thread { public: explicit Thread(IJob *adoptedJob); // 构造新线程，传入IJob任务对象 ~Thread(); Thread \u0026amp;operator=(const Thread \u0026amp;); static void exit(void *); // 安全退出线程 void cancel(); // 设置线程取消点 void setPriority(int n); // 线程优先级控制，没有实现 void unblockPollSocket(); static Thread getCurrentThread(); // 获取当前线程的线程实体 bool wait(double timeout = -1.0) const; // 阻塞等待线程退出 static void testCancel(); // 检查当前线程是否被通知取消 void *getResult() const; // 阻塞获取线程执行结果 IArchMultithread::ThreadID getID() const; bool operator==(const Thread \u0026amp;) const; bool operator!=(const Thread \u0026amp;) const; private: static void *threadFunc(void *); // 任务函数，Arch层会在子线程中执行该函数，而该函数又负责执行“任务” — IJob private: ArchThread m_thread = nullptr; // 所管理的线程实体 }; 7.2. 不同平台上的线程实体 Windows平台：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 线程实体 */ class ArchThreadImpl { public: ArchThreadImpl(); ~ArchThreadImpl(); public: int m_refCount; // 引用计数管理，防止线程对象在使用过程中被意外销毁。 HANDLE m_thread; // Win平台的线程句柄，表示线程的内核对象 DWORD m_id; // 线程标识符 IArchMultithread::ThreadFunc m_func; // 线程任务 void *m_userData; // 用户参数 HANDLE m_cancel; // 线程取消事件，线程被取消时触发 bool m_cancelling; // 线程是否正在取消 HANDLE m_exit; // exit事件，线程退出时触发 void *m_result; // 存储线程执行结果 void *m_networkData; // 异步任务中的网络数据 }; Linux平台：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* Unix平台线程实体，和Win的差不多 */ class ArchThreadImpl { public: ArchThreadImpl() = default; public: int m_refCount = 1; IArchMultithread::ThreadID m_id = 0; pthread_t m_thread; // Posix标准下的线程句柄 IArchMultithread::ThreadFunc m_func = nullptr; void *m_userData = nullptr; bool m_cancel = false; bool m_cancelling = false; bool m_exited = false; void *m_result = nullptr; void *m_networkData = nullptr; }; ","date":"2024-09-29T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%86%E6%9E%B602-%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/","title":"DeskFlow 多线程框架（02） — 线程对象管理"},{"content":" 1. 核心接口设计 2. 具体实现类型 2.1. 函数包装器 (FunctionJob) 2.2. 方法包装器 (TMethodJob) 3. 其他任务类型 1. 核心接口设计 IJob是一个纯虚接口，继承自IInterface基类，该接口只定义了一个核心方法，用于执行任务逻辑。这种简洁的设计使得任何需要执行特定功能的代码都可以通过实现这个接口来统一处理。\n1 2 3 4 5 class IJob : public IInterface { public: virtual void run() = 0; // 执行任务 }; 类型 功能 IJob 所有任务类型的基础接口 FunctionJob 继承自IJob，函数包装器，用于将普通的C函数包装成任务 TMethodJob 继承自IJob，方法包装器，是一个模板类，用于将类的成员函数包装成任务 这些任务类型主要用于线程执行，Thread类接受IJob接口的实现作为构造参数。当Thread类使用IJob来在新线程中执行任务。线程会接管Job的所有权并在执行完成后删除它。这种设计模式提供了一个统一的任务执行框架，允许以统一的方式处理不同类型的可执行任务（普通函数和类成员函数），适用于多线程环境中的任务调度和执行。\n2. 具体实现类型 2.1. 函数包装器 (FunctionJob) FunctionJob类允许将C风格的函数指针包装成Job对象。它存储函数指针和参数，在run()方法中调用该函数。实际执行时，如果函数指针不为空，就会调用该函数并传递参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 类定义 */ class FunctionJob : public IJob { public: FunctionJob(void (*func)(void *), void *arg = nullptr); ~FunctionJob() override = default; void run() override; private: void (*m_func)(void *); // 任务函数 void *m_arg; // 任务函数的参数列表 }; /* 实现 */ void FunctionJob::run() { if (m_func != nullptr) { m_func(m_arg); } } 2.2. 方法包装器 (TMethodJob) TMethodJob是一个模板类，用于包装类的成员方法。它存储对象指针、方法指针和参数，并在run()方法中调用对象的成员方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* 类定义 */ template \u0026lt;class T\u0026gt; class TMethodJob : public IJob { public: TMethodJob(T *object, void (T::*method)(void *), void *arg = nullptr); ~TMethodJob() override = default; void run() override; private: T *m_object; // 任务的来源，事件驱动框架下 void (T::*m_method)(void *); // 任务函数，T的成员函数 void *m_arg; // 任务函数的参数 }; /* 实现 */ template \u0026lt;class T\u0026gt; inline void TMethodJob\u0026lt;T\u0026gt;::run() { if (m_object != nullptr) { (m_object-\u0026gt;*m_method)(m_arg); } } 3. 其他任务类型 还有ISocketMultiplexerJob，我们放到网络IO部分讲解。\n","date":"2024-09-28T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%86%E6%9E%B601-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%B0%81%E8%A3%85/","title":"DeskFlow 多线程框架（01） — 异步任务的封装"},{"content":"功能概述 ArchString 主要负责提供跨平台的字符编码功能，ArchString的核心功能包括：\n字符编码转换： 提供多字节字符串编码和宽字节字符串编码之间的双向转换。 多种宽字符编码支持：支持UCS2、UCS4、UTF16、UTF32等多种宽字符编码格式。 平台相关的编码识别：每个平台可以报告其原生的宽字符编码格式。 ArchString将抽象接口和具体实现分离，由ArchStringUnix和ArchStringWindows分别负责Linux和Windows上的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class ArchString : public IInterface { public: ArchString() = default; ArchString(const ArchString \u0026amp;) = delete; ArchString(ArchString \u0026amp;\u0026amp;) = delete; ~ArchString() override = default; ArchString \u0026amp;operator=(const ArchString \u0026amp;) = delete; ArchString \u0026amp;operator=(ArchString \u0026amp;\u0026amp;) = delete enum class EWideCharEncoding : uint8_t { kUCS2, //!\u0026lt; The UCS-2 encoding kUCS4, //!\u0026lt; The UCS-4 encoding kUTF16, //!\u0026lt; The UTF-16 encoding kUTF32, //!\u0026lt; The UTF-32 encoding kPlatformDetermined }; /* * dst： 目标字符缓冲区，如果为NULL则只计算长度 * src： 源宽字符字符串 * n： 要转换的字符数量 * errors： 错误标志指针，用于指示转换过程中是否发生错误 * * 该函数将宽字符（wchar_t*）字符串转换为多字节字符串（char*），函数返回转换后的字节数。 * 函数会检测转换过程中的错误，当遇到无法转换的字符时，会设置错误标志并用问号（\u0026#39;?\u0026#39;）替代无效字符。 */ int convStringMBToWC(wchar_t *, const char *, uint32_t n, bool *errors) const; int convStringWCToMB(char *, const wchar_t *, uint32_t n, bool *errors) const; // 查看当前平台的宽字符编码方式，Unix平台使用UCS4编码，Windows平台使用UTF16编码 EWideCharEncoding getWideCharEncoding() const; }; ","date":"2024-09-22T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%BD%E8%B1%A1%E5%B1%8207-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/","title":"DeskFlow 跨平台抽象层（07） — 字符编码"},{"content":" 1. RCU 的核心概念 2. RCU 的工作机制 2.1. 读者访问流程 2.2. 写者更新流程 2.3. 宽限期管理 3. RCU 的优缺点 3.1. 优点 3.2. 缺点 4. RCU 的典型应用场景 5. RCU 与传统同步机制的对比 6. RCU 的变种与扩展 7. RCU 的注意事项 8. 总结 在 Linux 内核中，RCU（Read-Copy-Update） 是一种高效的并发同步机制，旨在优化读多写少的场景。它的核心目标是减少读者的同步开销，同时确保写者的操作不会阻塞读者。以下是关于 RCU 环境 的详细解析：\n1. RCU 的核心概念 读者（Reader）：\n可以并发访问被 RCU 保护的数据，无需加锁。 读者在访问期间不能发生上下文切换（即不能进入睡眠状态），否则可能破坏 RCU 的一致性。 读者的访问是原子的，且能看到完整的数据结构（旧版本或新版本）。 写者（Writer）：\n修改数据时需遵循以下步骤： 拷贝副本：复制当前数据的副本。 修改副本：对副本进行修改。 原子替换：将指针指向新副本。 延迟释放：通过 宽限期（Grace Period） 确保所有读者完成访问后，再释放旧数据。 写者之间需要互斥（如通过自旋锁）以避免冲突。 宽限期（Grace Period）：\n所有 CPU 都经历一次静止状态（Quiescent State）（如上下文切换、空闲循环）所需的时间。 一旦宽限期结束，写者可以安全地释放旧数据。 静止状态（Quiescent State）：\n表示某个 CPU 已经完成了所有 RCU 读端临界区的访问。 常见的静止状态包括：进程上下文切换、进入空闲循环等。 2. RCU 的工作机制 2.1. 读者访问流程 读者通过 rcu_read_lock() 和 rcu_read_unlock() 声明 RCU 读端临界区。 在读端临界区内，读者可以安全地访问被 RCU 保护的数据。 读者访问的是稳定版本的数据（旧版本或新版本），不会看到中间状态。 2.2. 写者更新流程 拷贝数据： 1 2 struct my_data *new = kmalloc(...); // 拷贝副本 *new = *old; 修改副本： 1 new-\u0026gt;value = new_value; // 修改副本 原子替换： 1 rcu_assign_pointer(gbl_data, new); // 原子更新指针 延迟释放： 1 call_rcu(\u0026amp;old-\u0026gt;rcu_head, free_data); // 注册回调函数 call_rcu 会在宽限期结束后调用 free_data 释放旧数据。 2.3. 宽限期管理 检测静止状态： 内核通过跟踪每个 CPU 的静止状态（如进程调度、中断处理）来判断是否满足宽限期。 触发回收： 一旦所有 CPU 都进入静止状态，RCU 的垃圾回收器会调用写者注册的回调函数（如 free_data）释放旧数据。 3. RCU 的优缺点 3.1. 优点 读者零开销： 读者无需加锁，访问效率极高，特别适合读多写少的场景（如文件系统目录遍历）。 避免死锁： RCU 不涉及锁竞争，不存在死锁风险。 优先级无倒置： 读者不会阻塞写者，也不会因优先级问题导致低优先级任务阻塞高优先级任务。 适用场景广泛： 常用于网络协议栈、文件系统、内存管理等高性能场景。 3.2. 缺点 写者开销较高： 写者需要拷贝数据副本，增加了内存和时间开销。 延迟释放： 旧数据的释放需要等待宽限期，可能导致内存占用短暂增加。 复杂性： 实现和调试 RCU 代码需要对同步机制有较深的理解。 4. RCU 的典型应用场景 网络协议栈： 在 Linux 内核中，RCU 用于管理路由表、ARP 缓存等频繁读取但较少修改的数据结构。 文件系统： 用于目录项（dentry）和 inode 缓存的管理。 内存管理： 在页表更新中，RCU 用于避免 TLB 刷新的开销。 缓存系统： 在高速缓存（如 Slab 分配器）中，RCU 用于管理对象池。 5. RCU 与传统同步机制的对比 特性 RCU 读写锁（Read-Write Lock） 读者开销 零开销（无需加锁） 读者需要加锁，开销较高 写者开销 较高（需拷贝副本） 写者独占，开销较低 读者阻塞 不阻塞 写者会阻塞读者 适用场景 读多写少 读写均衡 内存占用 短暂增加（延迟释放） 无额外内存占用 复杂性 较高（需管理宽限期） 较低（直接加锁即可） 6. RCU 的变种与扩展 抢占式 RCU（Preemptible RCU）： 允许读者在 RCU 临界区内进行上下文切换，但需保证内核抢占不会破坏 RCU 的一致性。 可睡眠 RCU（SRCU）： 允许读者在 RCU 临界区内睡眠，适用于用户空间线程或复杂场景。 分层 RCU（Hierarchical RCU）： 将 RCU 分为多个层级，优化大规模多核系统的性能。 7. RCU 的注意事项 读者不能睡眠： 在 RCU 读端临界区内，读者不能调用可能睡眠的函数（如 kmalloc(GFP_KERNEL)）。 写者的互斥： 多个写者之间需要通过锁（如自旋锁）互斥访问，避免并发修改。 内存屏障： 使用 rcu_read_lock() 和 rcu_read_unlock() 时需配合内存屏障（Memory Barrier）确保可见性。 宽限期的管理： 写者需确保宽限期结束后再释放资源，避免读者访问已释放的数据。 8. 总结 RCU 环境 是 Linux 内核中一种高效的并发同步机制，通过无锁读取和延迟释放的策略，显著提升了读多写少场景下的性能。其核心思想是：读者无需等待写者完成，而写者通过拷贝和原子替换避免阻塞读者。尽管 RCU 的实现较为复杂，但在网络协议栈、文件系统等高性能场景中，它是不可或缺的工具。\n","date":"2024-09-19T00:00:00Z","permalink":"https://zuoco.github.io/p/rcu%E4%B8%80%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/","title":"RCU，一种高效的并发同步机制"},{"content":" 1. 守护进程设计 2. 接口主要功能 2.1. 守护进程安装与卸载 2.2. 守护进程化操作 2.3. 状态查询功能 3. IArchDaemon代码解释 4. 平台特定功能 4.1. Windows平台特性 4.2. Unix平台特性 4.3. 不支持守护进程的平台 1. 守护进程设计 IArchDaemon是Deskflow中平台抽象层的核心接口之一，专门负责提供跨平台的守护进程功能，为不同操作系统平台的守护进程操作提供统一的编程接口。IArchDaemon接口继承自IInterface，该接口使用函数类型别名DaemonFunc来定义守护进程的主函数签名。\n2. 接口主要功能 2.1. 守护进程安装与卸载 1 2 3 4 5 6 7 // 安装与卸载 virtual void installDaemon(const char *name, const char *description, const char *pathname, const char *commandLine, const char *dependencies) = 0; virtual void uninstallDaemon(const char *name) = 0; // 默认安装与卸载 virtual void installDaemon() = 0; virtual void uninstallDaemon() = 0; 2.2. 守护进程化操作 1 2 // 将当前进程转换为守护进程 virtual int daemonize(const char *name, DaemonFunc const \u0026amp;func) = 0; 2.3. 状态查询功能 1 2 3 4 // 检查用户是否有权限安装守护进程 virtual bool canInstallDaemon(const char *name) = 0; // 检查守护进程是否已安装 virtual bool isDaemonInstalled(const char *name) = 0; 3. IArchDaemon代码解释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class IArchDaemon : public IInterface { public: // 守护进程的主逻辑函数类型 using DaemonFunc = std::function\u0026lt;int(int, const char **)\u0026gt;; // 安装指定名称的守护进程 virtual void installDaemon( const char *name, const char *description, const char *pathname, const char *commandLine, const char *dependencies ) = 0; // 卸载指定名称的守护进程 virtual void uninstallDaemon(const char *name) = 0; // 安装默认守护进程 virtual void installDaemon() = 0; virtual void uninstallDaemon() = 0; // 将当前进程转化为守护进程。 virtual int daemonize(const char *name, DaemonFunc const \u0026amp;func) = 0; // 检查当前用户是否有权限安装/卸载守护进程。 virtual bool canInstallDaemon(const char *name) = 0; // 检查指定守护进程是否已安装。 virtual bool isDaemonInstalled(const char *name) = 0; // 获取当前进程的启动命令行。 virtual std::string commandLine() const = 0; }; 4. 平台特定功能 4.1. Windows平台特性 Win平台的守护进程实现比较复杂。\n静态方法 runDaemon() 用于运行守护进程主循环。 daemonRunning() 和 daemonFailed() 方法用于状态管理。 getDaemonQuitMessage() 处理Windows服务控制消息。 4.2. Unix平台特性 Unix实现相对简单，主要专注于进程的守护进程化操作。\n1 2 3 4 5 6 7 8 9 10 11 #define ARCH_DAEMON ArchDaemonUnix class ArchDaemonUnix : public ArchDaemonNone { public: ArchDaemonUnix() = default; ~ArchDaemonUnix() override = default; // IArchDaemon overrides int daemonize(const char *name, DaemonFunc const \u0026amp;func) override; // 进程守护进程化 }; 4.3. 不支持守护进程的平台 ArchDaemonNone提供了一个\u0026quot;空\u0026quot;实现，适用于不支持守护进程概念的平台，其中安装和卸载函数什么都不做，查询函数返回false。\n","date":"2024-09-15T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%BD%E8%B1%A1%E5%B1%82%E4%B9%8B05-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/","title":"DeskFlow 跨平台抽象层之（05） — 守护进程"},{"content":" 1. 设计思路 2. 代码设计 2.1. 纯虚接口设计 2.2. 平台实现 1. 设计思路 IArchNetwork 采用纯虚接口设计，定义了所有网络操作的统一接口。该接口包含了完整的网络功能集合，包括socket创建、连接、数据传输、地址解析等操作。该设计采用了两个平台特定的实现：\nArchNetworkBSD: 用于Unix/BSD系统的实现，ArchNetworkBSD.h。 ArchNetworkWinsock: 用于Windows系统的实现，ArchNetworkWinsock.h。 设计关键点：\n每个实现都继承自 IArchNetwork 接口并重写所有虚函数，提供平台特定的网络功能。通过 Arch 单例类提供全局访问点。业务层代码通过 ARCH 宏来访问网络功能。 IArchNetwork 被高层组件如 TCPSocketFactory 使用，通过工厂模式创建不同类型的socket。例如，在创建TCP socket时，工厂会调用 ARCH-\u0026gt;newSocket() 来创建底层的网络socket。 设计中包含了完善的异常处理机制，所有网络操作都通过捕获 XArchNetwork 异常来处理错误情况。 IArchNetwork 的设计体现了良好的软件架构原则：通过接口隔离了平台差异、使用工厂模式简化了对象创建、采用单例模式提供了全局访问点，并且通过异常机制确保了错误处理的一致性。这种设计使得 Deskflow 能够在不同平台上提供统一的网络功能，同时保持代码的可维护性和可扩展性。\n2. 代码设计 2.1. 纯虚接口设计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // 网络地址实体，就是不同平台上网络地址的实现 using ArchNetAddress = ArchNetAddressImpl *; // class IArchNetwork : public IInterface { public: // 地址族，需要在创建Socket时指定 enum EAddressFamily { kUNKNOWN, kINET, // IPV4 kINET6, // IPV6 }; // 协议类型 enum ESocketType { kDGRAM, // UDP kSTREAM // TCP }; // 异步I/O —— poll事件 enum { kPOLLIN = 1, // Socket 接收缓存区有数据可读。 kPOLLOUT = 2, // Socket 发送缓存区为空，可以发送数据。 kPOLLERR = 4, // 错误状态 kPOLLNVAL = 8 // 无效socket }; // 异步I/O ——　用于套接字事件轮询，监控多个套接字的状态变化。 class PollEntry { public: ArchSocket m_socket; // 要监听的套接字 unsigned short m_events; // 要监听的事件 unsigned short m_revents; // 实际监听到的事件 }; // 下面都是socket操作 virtual ArchSocket newSocket(EAddressFamily, ESocketType) = 0; // 创建socket virtual ArchSocket copySocket(ArchSocket s) = 0; virtual void closeSocket(ArchSocket s) = 0; // 关闭sokcet virtual void closeSocketForRead(ArchSocket s) = 0; // 关闭读通道 virtual void closeSocketForWrite(ArchSocket s) = 0; // 关闭写通道 // 连接网络 virtual void bindSocket(ArchSocket s, ArchNetAddress addr) = 0; // 绑定地址，服务端 virtual void listenOnSocket(ArchSocket s) = 0; // 监听客户端连接，服务端 virtual ArchSocket acceptSocket(ArchSocket s, ArchNetAddress *addr) = 0; // 接收客户端连接，服务端 virtual bool connectSocket(ArchSocket s, ArchNetAddress addr) = 0; // 向服务端发起连接，客户端 // 异步I/O virtual int pollSocket(PollEntry[], int num, double timeout) = 0; // 使用poll轮训socket virtual void unblockPollSocket(ArchThread thread) = 0; // 解除轮询阻塞 virtual size_t readSocket(ArchSocket s, void *buf, size_t len) = 0; // 读socket virtual size_t writeSocket(ArchSocket s, const void *buf, size_t len) = 0; // 写socket virtual void throwErrorOnSocket(ArchSocket s) = 0; virtual bool setNoDelayOnSocket(ArchSocket, bool noDelay) = 0; // 启用/禁用Nagle算法 virtual bool setReuseAddrOnSocket(ArchSocket, bool reuse) = 0; // 地址重用选项 virtual std::string getHostName() = 0; virtual ArchNetAddress newAnyAddr(EAddressFamily) = 0; // 创建通配地址 virtual ArchNetAddress copyAddr(ArchNetAddress) = 0; virtual std::vector\u0026lt;ArchNetAddress\u0026gt; nameToAddr(const std::string \u0026amp;) = 0; // 域名解析 virtual void closeAddr(ArchNetAddress) = 0; virtual std::string addrToName(ArchNetAddress) = 0; virtual std::string addrToString(ArchNetAddress) = 0; virtual EAddressFamily getAddrFamily(ArchNetAddress) = 0; virtual void setAddrPort(ArchNetAddress, int port) = 0; // 设置端口 virtual int getAddrPort(ArchNetAddress) = 0; virtual bool isEqualAddr(ArchNetAddress, ArchNetAddress) = 0; // 地址比较 virtual bool isAnyAddr(ArchNetAddress addr) = 0; virtual void init() = 0; }; 2.2. 平台实现 提供了Unix和Windows平台上的实现，就是将平台的系统调用封装了一下。\nWindows平台\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define ARCH_NETWORK ArchNetworkWinsock /* 1. 网络地址实体 */ class ArchNetAddressImpl { public: static ArchNetAddressImpl *alloc(size_t); public: int m_len; struct sockaddr_storage m_addr; // 通用地址表示，IPv4、IPv6 }; /* 2. 网络设备句柄实现 */ class ArchSocketImpl { public: SOCKET m_socket; int m_refCount; WSAEVENT m_event; bool m_pollWrite; }; /* 3. 网络接口实现 */ class ArchNetworkWinsock : public IArchNetwork { // override 父类的纯虚函数 }; Unix平台\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #define ARCH_NETWORK ArchNetworkBSD /* 1. 网络地址实现 */ class ArchNetAddressImpl // 网络句柄 { public: ArchNetAddressImpl() : m_len(sizeof(m_addr)) { /* do nothing */ } public: struct sockaddr_storage m_addr; socklen_t m_len; }; /* 2. 网络设备句柄实现 */ class ArchSocketImpl { public: int m_fd; int m_refCount; }; /* 3. 网络接口操作实现 */ class ArchNetworkBSD : public IArchNetwork { // override 父类的纯虚函数 }; ","date":"2024-09-14T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%BD%E8%B1%A1%E5%B1%8203-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97/","title":"DeskFlow 跨平台抽象层（03） — 网络模块"},{"content":" 1. 多线程框架设计思路 2. 不透明类型设计 3. 平台实现 3.1. Posix 3.2. Win 4. IArchMultithread抽象基类的实现 1. 多线程框架设计思路 IArchMultithread是Deskflow中多线程功能的核心抽象接口，IArchMultithread是一个纯虚拟接口，承自IInterface，提供了线程管理、互斥锁、条件变量和信号处理等核心功能。\n2. 不透明类型设计 ArchThread：表示线程的不透明类型。 ArchMutex：表示互斥锁的不透明类型。 ArchCond：表示条件变量的不透明类型。 这些类型隐藏了平台特定的实现细节，它们实际上是指向具体实现类的指针，而具体实现位于对应平台的源码文件中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // IArchMultithread.h #pragma once #include \u0026#34;common/IInterface.h\u0026#34; // 前向声明，不实现 class ArchCondImpl; using ArchCond = ArchCondImpl *; class ArchMutexImpl; using ArchMutex = ArchMutexImpl *; class ArchThreadImpl; using ArchThread = ArchThreadImpl *; // 线程接口 class IArchMultithread : public IInterface { // ... }; 3. 平台实现 3.1. Posix 在UNIX/POSIX系统上，ArchMultithreadPosix类实现了该接口（ArchMultithreadPosix.h），具体的实现类使用pthread库：\nArchCondImpl包含pthread_cond_t。 ArchMutexImpl包含pthread_mutex_t。 ArchThreadImpl包含pthread_t。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;pthread.h\u0026gt; #define ARCH_MULTITHREAD ArchMultithreadPosix class ArchCondImpl { public: pthread_cond_t m_cond; }; class ArchMutexImpl { public: pthread_mutex_t m_mutex; }; class ArchThreadImpl { public: ArchThreadImpl() = default; public: int m_refCount = 1; IArchMultithread::ThreadID m_id = 0; pthread_t m_thread; // Posix线程句柄 IArchMultithread::ThreadFunc m_func = nullptr; void *m_userData = nullptr; bool m_cancel = false; bool m_cancelling = false; bool m_exited = false; void *m_result = nullptr; void *m_networkData = nullptr; }; // IArchMultithread 的 Posix 实现 class ArchMultithreadPosix : public IArchMultithread { // ... }; 3.2. Win 在Windows系统上，ArchMultithreadWindows类提供实现，ArchMultithreadWindows.h。\nArchCondImpl 使用Windows事件对象HANDLE m_events[2]。 ArchMutexImpl 使用CRITICAL_SECTION。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // ArchMultithreadWindows.h #include \u0026lt;Windows.h\u0026gt; #define ARCH_MULTITHREAD ArchMultithreadWindows // 条件变量实体 class ArchCondImpl { public: enum { kSignal = 0, kBroadcast }; HANDLE m_events[2]; // mutable int m_waitCount; ArchMutex m_waitCountMutex; }; // 互斥量实体 class ArchMutexImpl { public: CRITICAL_SECTION m_mutex; }; // 线程句柄实体 class ArchThreadImpl { public: ArchThreadImpl(); ~ArchThreadImpl(); public: int m_refCount; HANDLE m_thread; // 线程句柄 DWORD m_id; IArchMultithread::ThreadFunc m_func; void *m_userData; HANDLE m_cancel; bool m_cancelling; HANDLE m_exit; void *m_result; void *m_networkData; }; // IArchMultithread 的 Windows 实现 class ArchMultithreadWindows : public IArchMultithread { // ... }; 4. IArchMultithread抽象基类的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 /* 1. 线程实体 */ using class ArchThreadImpl = ArchThreadImpl *; /* 2. 操作线程实体的接口，通过操作ArchThreadImpl对象来实现线程功能 */ class IArchMultithread : public IInterface { public: // 线程任务函数类型 using ThreadFunc = void *(*)(void *); // 线程 ID 类型 using ThreadID = unsigned int; // 信号类型 enum ESignal { kINTERRUPT, // Ctrl+C kTERMINATE, // Ctrl+Break kHANGUP, // SIGHUP kUSER, // SIGUSR2 kNUM_SIGNALS }; // 信号处理函数的类型 using SignalFunc = void (*)(ESignal, void *userData); // 条件变量 virtual ArchCond newCondVar() = 0; // 创建条件变量 virtual void closeCondVar(ArchCond) = 0; // 销毁条件变量 virtual void signalCondVar(ArchCond) = 0; // 唤醒单个等待线程 virtual void broadcastCondVar(ArchCond) = 0; // 唤醒单个等待线程 virtual bool waitCondVar(ArchCond, ArchMutex, double timeout) = 0; // 带超时的条件等待 (取消点) // 互斥锁 virtual ArchMutex newMutex() = 0; // 创建互斥锁 virtual void closeMutex(ArchMutex) = 0; // 销毁互斥锁 virtual void lockMutex(ArchMutex) = 0; // 加锁 virtual void unlockMutex(ArchMutex) = 0; // 解锁 // 线程对象操作 virtual ArchThread newThread(ThreadFunc func, void *userData) = 0; // 创建新线程 virtual ArchThread newCurrentThread() = 0; // 返回一个表示当前（即调用）线程的对象的引用 virtual ArchThread copyThread(ArchThread thread) = 0; // 复制线程对象 virtual void closeThread(ArchThread) = 0; // 释放线程引用 virtual void cancelThread(ArchThread thread) = 0; // 请求线程取消 virtual void setPriorityOfThread(ArchThread, int n) = 0; // 设置线程优先级 virtual void testCancelThread() = 0; // 显式取消点，应该是用于测试的 virtual bool wait(ArchThread thread, double timeout) = 0; // 等待线程结束 (取消点) virtual bool isSameThread(ArchThread, ArchThread) = 0; // 线程对象比较 virtual bool isExitedThread(ArchThread thread) = 0; // 检查线程是否退出 virtual void *getResultOfThread(ArchThread thread) = 0; // 获取线程退出码 (取消点) virtual ThreadID getIDOfThread(ArchThread thread) = 0; // 获取线程ID（日志用） // 信号处理 virtual void setSignalHandler(ESignal, SignalFunc func, void *userData) = 0; // 设置信号处理函数 virtual void raiseSignal(ESignal signal) = 0; // 触发信号处理 }; ","date":"2024-09-14T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%BD%E8%B1%A1%E5%B1%8204-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97/","title":"DeskFlow 跨平台抽象层（04） — 线程模块"},{"content":" 1. Arch类的定义 2. Arch类的实现 3. 跨平台实现 4. 使用 1. Arch类的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #define ARCH (Arch::getInstance()) // 提供一个宏，用于单例的全局访问 class Arch : public ARCH_DAEMON, public ARCH_LOG, public ARCH_MULTITHREAD, public ARCH_NETWORK, public ARCH_SLEEP, public ArchString, public ARCH_TIME { public: Arch(); // 构造使用了assert强制保证只能创建的唯一实例。 explicit Arch(Arch *arch); // 支持外部注入 ~Arch() override = default; // 可以禁用拷贝构造、赋值操作符等等。 // 创建单例后调用 void init() override; // 初始化需要的接口 static Arch *getInstance(); private: // 静态私有实例，由该类自行实例化，并向系统提供这个实例。 static Arch *s_instance; }; 单例模式好像是有什么饿汉、懒汉的说法，但是该项目实现应该是属于一种懒汉模式，但不是在get时初始化，而是在main函数中通过构造函数手动创建，其实这也符合该项目自身的需求，这个项目设计该单例主要为了给业务层提供无关平台的系统调用接口，整个程序共享该单例，在进入main后马上就创建并初始化单例对象，并且通过assert确保只有一个静态实例。\n2. Arch类的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026#34;arch/Arch.h\u0026#34; #if SYSAPI_WIN32 #include \u0026#34;arch/win32/ArchMiscWindows.h\u0026#34; #endif Arch *Arch::s_instance = nullptr; // 虽然构造函数在定义中没有私有，但是这里使用了assert(s_instance == nullptr)也能保证只有一个实例存在。 Arch::Arch() { assert(s_instance == nullptr); s_instance = this; } // 初始化Arch中的模块，这里只初始化了网络模块，根据实际需求初始化对应的模块。 void Arch::init() { ARCH_NETWORK::init(); #if SYSAPI_WIN32 ArchMiscWindows::init(); #endif } // 访问单例 Arch *Arch::getInstance() { assert(s_instance != nullptr); return s_instance; } 3. 跨平台实现 上面的Arch类继承了多个基类（如ARCH_DAEMON、ARCH_LOG等等），这些也都是抽象基类，它们分别提供了不同的功能模块（如守护进程、日志记录、多线程支持等）。每一个宏就是一个模块类型，定义在特定头文件中，在编译时，根据平台的不同来包含不同的头文件，并进行宏替换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #if SYSAPI_WIN32 // Win平台实现代码 #include \u0026#34;arch/win32/ArchDaemonWindows.h\u0026#34; #include \u0026#34;arch/win32/ArchLogWindows.h\u0026#34; #include \u0026#34;arch/win32/ArchMultithreadWindows.h\u0026#34; #include \u0026#34;arch/win32/ArchNetworkWinsock.h\u0026#34; #include \u0026#34;arch/win32/ArchSleepWindows.h\u0026#34; #include \u0026#34;arch/win32/ArchTimeWindows.h\u0026#34; #elif SYSAPI_UNIX // Unix平台实现 #include \u0026#34;arch/unix/ArchDaemonUnix.h\u0026#34; #include \u0026#34;arch/unix/ArchLogUnix.h\u0026#34; #include \u0026#34;arch/unix/ArchNetworkBSD.h\u0026#34; #include \u0026#34;arch/unix/ArchSleepUnix.h\u0026#34; #include \u0026#34;arch/unix/ArchTimeUnix.h\u0026#34; #if HAVE_PTHREAD // Posix #include \u0026#34;arch/unix/ArchMultithreadPosix.h\u0026#34; #endif #endif 就拿ARCH_NetWork来说， 在Windows平台下构建，预处理后ArchNetworkWinsock.h头文件被包含到：\n1 #define ARCH_NETWORK ArchNetworkWinsock // 此时Arch类实际继承了ArchNetworkWinsock，也就是继承了Win平台的实现 在Unix系统下构建，预处理后ArchNetWorkBSD.h头文件被包含：\n1 #define ARCH_NETWORK ArchNetworkBSD // 此时Arch类实际继承了ArchNetworkBSD，也就是继承了Unix平台的实现 对于每一个功能模块，后续会以单独的章节介绍。\n4. 使用 这个单例封装了系统调用，在程序启动时就要创建，以便于程序使用。\n1 2 3 4 5 6 7 int main(int argc, char **argv) { // ... Arch arch; arch.init(); // ... } 在程序中，使用ARCH宏访问单例对象。\n","date":"2024-09-08T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%BD%E8%B1%A1%E5%B1%8202-arch%E5%8D%95%E4%BE%8B%E7%B1%BB/","title":"DeskFlow 跨平台抽象层（02） — Arch单例类"},{"content":" 1. 跨平台框架 2. 跨平台接口基类 3. 跨平台接口集成 4. 核心抽象类 5. 平台层实现类 6. 宏定义映射系统 1. 跨平台框架 2. 跨平台接口基类 IInterface可以看做是该项目整个软件框架的根类型。\n1 2 3 4 5 class IInterface { public: virtual ~IInterface() = default; }; 3. 跨平台接口集成 跨平台抽象层中的Arch类使用多重继承模式，将所有平台特定的功能组合到一个统一的接口中，Arah类作为单例模式提供全局访问。\n1 2 3 4 5 6 class Arch : public ARCH_DAEMON, public ARCH_LOG, public ARCH_MULTITHREAD, public ARCH_NETWORK, public ArchString {/* ... */}; 这些模块都继承自IInterface根类型，他们没有使用虚继承，但也是能编译的，因为这个公共基类没有成员，不会引发二义性。\n4. 核心抽象类 系统定义了多个IArch*接口，这些接口定义了各个功能模块必须实现的功能，它们每一个都是单例。\n功能 核心抽象类型 网络功能抽象 IArchNetwork 多线程功能抽象 IArchMultithread 守护进程功能抽象 IArchDaemon 日志功能抽象 IArchLog 字符编码转换 ArchString 5. 平台层实现类 功能模块 Unix平台实现类 Windows平台实现类 抽象基类 网络 ArchNetworkBSD ArchNetworkWinsock IArchNetwork 多线程 ArchMultithreadPosix ArchMultithreadWindows IArchMultithread 守护进程 ArchDaemonNone ArchDaemonWindows IArchDaemon 日志 ArchLogUnix ArchLogWindows IArchLog 字符编码 ArchString ArchString ArchString 具体实现类（Arch*）提供不同平台的实现，对于每个模块，后面会有单独的篇章讲解。\n6. 宏定义映射系统 例如Windows平台上，我们以ARCH_MULTITHREAD为例。 Arch.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #pragma once #include \u0026#34;arch/ArchString.h\u0026#34; #include \u0026#34;common/Common.h\u0026#34; #if SYSAPI_WIN32 // Win平台，预处理时引入Win实现的头文件 #include \u0026#34;arch/win32/ArchDaemonWindows.h\u0026#34; #include \u0026#34;arch/win32/ArchLogWindows.h\u0026#34; #include \u0026#34;arch/win32/ArchMultithreadWindows.h\u0026#34; // 多线程在Windows上的实现，也就是ArchMultithreadWindows类的定义 #include \u0026#34;arch/win32/ArchNetworkWinsock.h\u0026#34; #elif SYSAPI_UNIX #include \u0026#34;arch/unix/ArchDaemonUnix.h\u0026#34; #include \u0026#34;arch/unix/ArchLogUnix.h\u0026#34; #include \u0026#34;arch/unix/ArchMultithreadPosix.h\u0026#34; #include \u0026#34;arch/unix/ArchNetworkBSD.h\u0026#34; #endif ArchMultithreadWindows.h\n1 2 3 4 5 6 #define ARCH_MULTITHREAD ArchMultithreadWindows class ArchMultithreadWindows : public IArchMultithread { // ... }; ","date":"2024-09-07T00:00:00Z","permalink":"https://zuoco.github.io/p/deskflow-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%BD%E8%B1%A1%E5%B1%8201-%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/","title":"DeskFlow 跨平台抽象层（01） — 整体设计"},{"content":" 1. alignas 与 alignof 2. #pragma pack 3. 获取对齐的内存 3.1. std::aligned_storage_t 3.2. std::aligned_alloc 1. alignas 与 alignof alignof 用于在编译期查询类型或对象的对齐要求，返回一个 std::size_t 类型的值，也就是该类型在内存中对齐的字节数。\nalignas 用于控制变量或类型的内存对齐方式，例如：\n1 alignas(16) char buffer[256]; // buffer的起始地址是16的倍数 如果alignas修饰一个类型，它指定的是这个类型整体的对齐，不干扰类中的成员变量对齐，类型或者结构体的成员变量默认按照自身对齐，例如：\n1 2 3 4 5 struct alignas(8) MyStruct { char a; int b; double c; }; 如果创建一个MyStruct对象，那么对象起始地址是8的倍数。但是其中的成员变量不一定是8的倍数，实际上上面的结构体占用的空间是16字节。\nchar a（1字节）：对齐要求为1字节，无需填充。\nint b（4字节）：需要4字节对齐。由于a后紧跟b，a的地址是0，b的地址是1，但1不是4的倍数。因此，编译器会在a后插入3字节填充，使b的地址对齐到4字节（地址为4）。\ndouble c（8字节）：需要8字节对齐。b的地址是4，b之后是地址8。但c的地址需要是8的倍数，因此b后的地址8已经满足要求，无需额外填充。\nalignas 与 alignof通常一起使用： alignas( alignof(T) ) T num[256];。而且 alignas 和 alignof 都是编译期运行的特性，它们的处理完全由编译器在编译阶段完成。 另外，声明和定义时必须使用相同的对齐值：\n1 2 3 4 5 6 7 struct alignas(8) MyStruct { char a; int b; double c; }; struct alignas(16) MyStruct my_struct; // 错误 2. #pragma pack #pragma pack 是一个编译器指令，\n1 2 3 #pragma pack(n) // 设置对齐边界为 n 字节 #pragma pack(push, n) // 保存当前对齐状态并设置为 n 字节 #pragma pack(pop) // 恢复最近一次保存的对齐状态 n： 对齐边界，可以是 1, 2, 4, 8, 16 等。编译器会根据 n 和成员变量的大小，选择较小的值进行对齐。 push： 将当前对齐状态压入编译器的堆栈，以便后续恢复。 pop： 从堆栈中弹出最近保存的对齐状态，并恢复为该状态。\n1 2 3 4 5 6 7 #pragma pack(1) // 强制所有成员按 1 字节对齐 struct MyStruct { char a; int b; short c; }; #pragma pack() // 恢复默认对齐 所有成员按 1 字节对齐，无需填充，总大小：1 + 4 + 2 = 7 bytes。\n使用 push 和 pop：\n1 2 3 4 5 6 #pragma pack(push, 1) // 保存当前对齐状态并设置为 1 字节 struct PackedStruct { char a; int b; }; #pragma pack(pop) // 恢复之前的对齐状态 push 和 pop 可以避免影响其他代码的对齐设置，只作用于当前结构体。\n3. 获取对齐的内存 3.1. std::aligned_storage_t 提供一个未初始化的，满足特定对齐的要求内存块，常用于 placement new。\n1 std::aligned_storage_t\u0026lt;sizeof(T), alignof(T)\u0026gt; storage[10]; storage中的每一个成员的地址都是 T 的整数倍。\n3.2. std::aligned_alloc 动态分配一个满足特定对齐要求的内存块。\n1 void* std::aligned_alloc(std::size_t alignment, std::size_t size); alignment: 内存对齐的边界（以字节为单位），必须是 2 的幂。 size： 要分配的字节数，必须是 alignment 的整数倍，否则分配失败。\n成功时，返回指向对齐内存的指针。失败时，返回 nullptr。\n","date":"2024-08-21T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/","title":"内存对齐"},{"content":" 1. EPOLL原理介绍 2. EPOLL使用 2.1. 创建EPOLL对象 2.2. 操作内核事件表 2.3. 等待事件 3. ET和LT模式对比 3.1. 问题 4. EPOLLONESHOT事件 5. 其他小代码 1. EPOLL原理介绍 EPOLL是Linux内核提供的的I/O复用函数，简单地说就说使用一个文件描述符来监控多个文件描述符上的事件，当文件描述符上的事件发生时，会通知用户。如果没有这种多路复用机制，那么，面对多个Socket同时通信的场景可能就需要多线程了，但是每个SOcket上并不是一直都有数据，使用多线程多浪费资源呀。\nEpoll把用户关心的“文件描述符”放在内核里面一个事件表中，此时就需要一个单独“文件描述符”来标识内核中的这个事件表。另外EPOLL有两种工作模式：水平触发(Level Triggered，LT)和边缘触发(Edge Triggered，ET)，LT模式是EPOLL默认的工作模式，EPOLL和异步，非阻塞结合使用。\n简单讲一下原理，Epoll的核心是两个数据结构： 红黑树 和 就绪链表（双向链表）。然后结合内核回调机制，实现了高性能的事件管理。红黑树存储所有通过epoll_ctl()添加的文件句柄，树中的每个节点会关联一个结构体（保存了这个文件描述符的上需要监控的事件）。就绪的事件会被保存到储在就绪链表中，当就绪链表不为空时，内核会通知用户，用户可以通过epoll_wait()函数获取就绪事件。\n2. EPOLL使用 2.1. 创建EPOLL对象 1 2 #include \u0026lt;sys/epoll.h\u0026gt; int epoll_create(int size); // size参数没有意义。 返回一个文件描述符，代表内核事件表。\n2.2. 操作内核事件表 1 2 #include \u0026lt;sys/epoll.h\u0026gt; int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); //成功返回0，失败返回-1，并设置errno。 epfd：内核事件表文件描述符。\nop：操作类型。\nfd：要操作的文件描述符。\nevent：指向 epoll_event 结构体的指针，用于指定要添加、修改或删除的事件。\n其中，op(操作类型)有三种：\nEPOLL_CTL_ADD：往内核事件表中添加事件。 EPOLL_CTL_MOD：修改事件。 EPOLL_CTL_DEL：删除事件。 其中，event(关心的事件)的类型是struct epoll_event，结构体定义如下：\n1 2 3 4 struct epoll_event { __uint32_t events; // 事件 epoll_data_t data; // 事件携带的用户数据 } events 是一个位图，有EPOLLIN、EPOLLOUT、EPOLLET、EPOLLONESHOT。\ndata 是epoll_data_t类型，它是一个联合体，定义如下：\n1 2 3 4 5 6 typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; 由于这是一个联合体，所以这四个成员，我们只能使用其中的一个。\n2.3. 等待事件 1 2 #include \u0026lt;sys/epoll.h\u0026gt; int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); epoll_wait在一段超时时间内，等待一组文件描述符上的事件，返回就绪的文件描述符的数量。\ntimeout: 参数指定等待的时间，单位是毫秒。如果timeout为-1，则表示无限等待。 maxevents: 参数指定最多等待的事件数，必须大于0。 epoll_wait检测到事件，就会将所有的就绪事件从内核事件表拷贝到events数组中，并返回就绪事件的数量，也就是说event中的事件都是就绪的。\n3. ET和LT模式对比 对于Socket读事件，只要Socket上的数据没有读完，就会一直触发EPOLL事件，而对于ET模式，Socket上每来一次数据就会触发一次EPOLLIN事件，如果上一次触发后，未将 socket 上的数据读完，也不会再触发，除非再新来一次数据。对于 socket 写事件，如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件；而对于边缘模式，只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT事件。根据以上分析来看，如果采用ET模式就必须在收到事件后一次性将数据读取完，但如果采用默认模式，就可以根据业务每次收取固定的字节数，多次收取，显然相对于默认的LT模式，ET模式能够减少同一个事件被触发的次数，效率比LT模式高。\n3.1. 问题 多线程场景下，我们使用ET模式监听一个Socket上的读事件，当数据到达时触发EPOLLIN事件，我们在一个独立线程(或进程)中读取该Socket上的数据，但是我们还没有读取完，该Socket又有新数据到达，此时另一个线程(或进程)被唤醒来读取该Socket上的数据，那么就有两个线程(进程)同时操作同一个Socket，这样好吗，这样不好，但是如何解决呢？此时就该EPOLLONESHOT出场了。\n4. EPOLLONESHOT事件 显然，一次性事件，就是触发以后，需要手动重新注册，给文件描述符注册EPOLLONESHOT事件，就可以保证同一时间只有一个人在使用。\n1 2 3 4 5 6 7 8 // 重新注册EPOLLONESHOT事件 void reset_oneshot(int epollfd, int fd) { epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET | EPOLLONESHOT; epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, \u0026amp;event); } 注意： listening socket是不能使用EPOLLONESHOT的，否则后续的客户段连接请求就不会再触发listening socket的EPOLLIN事件了。\n5. 其他小代码 1. 将文件描述符设置为非阻塞\n1 2 3 4 5 6 7 int setnonblocking(int fd) { int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); return old_option; } 2. 事件注册\n1 2 3 4 5 6 7 8 9 10 11 12 void addfd(int epollfd, int fd, bool enable_et) { epoll_event event; event.data.fd = fd; event.events = EPOLLIN; if(enable_et) { event.events |= EPOLLET; //启用ET模式 } epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, \u0026amp;event); setnonblocking(fd); } 3. 判断数据是否读取完了\n1 2 3 4 5 // 非阻塞模式 if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) { // 数据读取完了 } ","date":"2024-08-12T00:00:00Z","permalink":"https://zuoco.github.io/p/linux%E5%BC%82%E6%AD%A5io01-epoll/","title":"Linux异步IO（01） — EPOLL"},{"content":"Unix Socket（Unix域套接字）是一种用于 本地进程间通信的机制。它与网络 Socket 不同，不需要通过网络协议栈，而是通过文件系统实现进程间的通信。和网络Socket一样，也提供流式套接字和数据报套接字。API接口的网络套接字是一样的，\n1. 服务器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/un.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define SOCKET_PATH \u0026#34;/tmp/mysocket\u0026#34; // socket绑定到文件系统 int main() { int server_fd, client_fd; struct sockaddr_un addr; // Unix-Socket地址 socklen_t len; // 1. 创建 Socket server_fd = socket(AF_UNIX, SOCK_STREAM, 0); // AF_UNIX 或 PF_UNIX，表示使用本地文件系统作为通信地址 if (server_fd == -1) { perror(\u0026#34;socket\u0026#34;); return 1; } // 2. 绑定地址 addr.sun_family = AF_UNIX; strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1); unlink(SOCKET_PATH); // 如果文件已存在，删除它 if (bind(server_fd, (struct sockaddr *)\u0026amp;addr, sizeof(addr)) == -1) { perror(\u0026#34;bind\u0026#34;); close(server_fd); return 1; } // 后面和网络套接字一样了。 unlink(SOCKET_PATH); // 删除 Socket 文件 return 0; } 2. 客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/un.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define SOCKET_PATH \u0026#34;/tmp/mysocket\u0026#34; int main() { int client_fd; struct sockaddr_un addr; // 1. 创建 Socket client_fd = socket(AF_UNIX, SOCK_STREAM, 0); if (client_fd == -1) { perror(\u0026#34;socket\u0026#34;); return 1; } // 2. 连接服务器 addr.sun_family = AF_UNIX; strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1); if (connect(client_fd, (struct sockaddr *)\u0026amp;addr, sizeof(addr)) == -1) { perror(\u0026#34;connect\u0026#34;); close(client_fd); return 1; } // 3. 读写数据 // ...... // 4. 关闭 Socket close(client_fd); return 0; } ","date":"2024-08-10T00:00:00Z","permalink":"https://zuoco.github.io/p/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A102-unix-socket/","title":"Linux进程间通信（02） — Unix-Socket"},{"content":" 1. vcpkg 2. 安装 3. 使用 3.1. 安装软件包 3.2. 查看软件包信息 4. 使用清单 4.0.1. 手动安装每个依赖 4.1. CMake构建 1. vcpkg Vcpkg 由 Microsoft 和 C++ 社区维护，可在 Windows、macOS 和 Linux 上运行，使用 C++ 和 CMake 脚本编写。\n2. 安装 我这里就安装到~/.APP/目录下： 1 2 3 4 5 cd ~/.app # clone vcpkg git clone https://github.com/microsoft/vcpkg.git # 初始化vcpkg cd vcpkg \u0026amp;\u0026amp; ./bootstrap-vcpkg.sh 设置软连接： 1 sudo ln -s /home/zcli/.app/vcpkg/vcpkg /usr/local/bin/vcpkg 3. 使用 3.1. 安装软件包 1 2 3 4 vcpkg install fmt vcpkg install fmt:x64-linux # 指定平台 vcpkg install fmt:x64-windows-static # 静态库 vcpkg install fmt:x64-windows # 动态库 3.2. 查看软件包信息 1 2 3 4 5 6 vcpkg list # 查找已经安装的软件包 vcpkg search # 查看所有软件包 vcpkg search opencv # 查看包含“opencv”关键词的软件包 vcpkg info opencv # 查看软件包信息 pvckg help triplet # 查看支持的平台 vcpkg search opencv --triplet x64-linux # 查找特定平台的包\t4. 使用清单 在项目根目录下： 1 vcpkg new --application 生成两个文件： 1 2 vcpkg-configuration.json vcpkg.json # 依赖清单 vcpkg-configuration.json文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;default-registry\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;git\u0026#34;, \u0026#34;baseline\u0026#34;: \u0026#34;89dc8be6dbcf18482a5a1bf86a2f4615c939b0fb\u0026#34;, \u0026#34;repository\u0026#34;: \u0026#34;https://github.com/microsoft/vcpkg\u0026#34; }, \u0026#34;registries\u0026#34;: [ { \u0026#34;kind\u0026#34;: \u0026#34;artifact\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;microsoft\u0026#34; } ] } vcpkg.json文件如下：\n1 {} 添加依赖 1 vcpkg add port opencv 添加结果如下：\n1 2 3 4 5 { \u0026#34;dependencies\u0026#34;: [ \u0026#34;opencv\u0026#34; ] } 也可以指定具体的版本。\n在准备好清单文件后： 1 vcpkg install # 自动读取当前目录的 vcpkg.json 文件 下载的二进制文件位于当前目录下的：vcpkg_installed目录。\n4.0.1. 手动安装每个依赖 安装软件包 1 vcpkg install zlib # 安装zlib 卸载软件包 1 vcpkg remove zlib 查找可用包 1 vcpkg remove zlib 4.1. CMake构建 1 2 3 4 5 cmake -B build -S . \\ -DCMAKE_TOOLCHAIN_FILE=/home/zcli/.APP/vcpkg/scripts/buildsystems/vcpkg.cmake \\ -DVCPKG_TARGET_TRIPLET=x64-linux \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_INSTALL_PREFIX=/usr/local ","date":"2024-07-31T00:00:00Z","permalink":"https://zuoco.github.io/p/c-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E4%B9%8Bvcpkg/","title":"C++包管理器之vcpkg"},{"content":" cpp insight： 将 C++ 代码转换为内部实现形式\nRGB颜色表\nWinsows开发文档\nHello-GitHub\nOpen-GitHub\nHuggingFace\n魔塔社区： 国产版的HuggingFace\nAutoDL云算力租用\ndeepwiki\nZread\nlibkdtree++: 一个用C++模板实现的k维树结构 One-KVM： 硬件级远控方案\nKVM-Over-IP: 硬件级远控方案\nlwip: 用户态协议栈\nChili3D： 基于OpenCASCADE、WebAssembly的WebCAD\n","date":"2024-07-28T00:00:00Z","permalink":"https://zuoco.github.io/p/%E8%B5%84%E6%BA%90/","title":"资源"},{"content":" 1. 虚拟内存 2. 页 2.1. 页表 2.2. 多级页表 2.3. 页表项 3. 映射关系 4. TLB 1. 虚拟内存 进程不会直接访问物理内存，进程能够看到的地址空间是虚拟地址空间，虚拟地址通过一定的规则关联到物理地址，简单理解为下图：\n2. 页 在虚拟内存中，内存以页为单位进行划分，以便于管理，地址转换也是以页为单位进行的，对于X86_64系统，页的大小为4KB。计算机物理内存也被划分为同样大小的块，称为物理页帧。\n2.1. 页表 操作系统以及MMU使用页表管理页，页表中存储着页表项，页表项记录着虚拟地址到物理地址的映射关系。每个进程都有自己独立的页表，这确保了进程地址空间的隔离性。当 CPU 切换到某个进程执行时，CR3 寄存器（在 x86 架构下）会被加载指向该进程的顶级页表的物理地址。\n2.2. 多级页表 现代系统地址空间巨大（如 64 位系统），不会使用一个巨大的单级页表来存储所有映射。因此，页表通常是多级的，实际工作中，MMU会根据当前进程的顶级页表基址，一层一层得遍历，在最后一级页表中找到目标虚拟页对应的页表项。\n2.3. 页表项 页表的内容：\n物理页帧号： 指示该虚拟页当前映射到的物理页帧的起始地址。 存在位： 表示该虚拟页当前是否在物理内存中。如果为 0，访问该页会触发缺页中断，进而终止程序。 读/写权限位： 控制该页是可读、可写还是只读。 用户/超级用户权限位： 控制用户态进程是否可以访问该页（内核页通常只能在内核态访问）。 访问位： 被硬件置位，表示该页最近被访问过（用于页面置换算法如 LRU）。 修改位： 被硬件置位，表示该页的内容被修改过（需要写回磁盘后才能释放其物理页帧）。 其他标志位： 如全局页、禁用缓存、NX（不可执行）位等。 当 CPU 执行指令访问一个虚拟地址时，MMU 自动查阅当前进程的页表，将该虚拟地址翻译成对应的物理地址。而且不同进程的页表项可以指向同一个物理页帧，用于共享，例如动态链接库。\n3. 映射关系 虚拟页不一定时刻都有物理页帧与之对应，也不一定连续地映射到物理内存上。一个虚拟页可以映射到一个物理页帧，也可以映射到磁盘上的交换空间，或者暂时没有映射（未分配）。\n4. TLB 现代系统使用多级页表（如 x86_64 的 4 级页表）。每次地址转换需多次访问内存（遍历每一级页表），可能需 4~5 次内存访问才能完成一次转换。内存访问速度远低于 CPU 速度，直接导致性能严重下降。考虑到程序的局部性原理，程序在短时间内倾向于集中访问少量内存页（如循环代码、连续数据），这些页的地址转换结果（映射关系）可被缓存复用。\nTLB 是一个硬件缓存（通常由 SRAM 实现），存储最近使用过的虚拟页号 → 物理页帧号的映射关系。每个条目相当于一个页表项的副本（含物理页号 + 权限位）。现代 CPU 通常包含多级 TLB（如 L1 TLB、L2 TLB），容量逐级增大但速度略慢。 如果我们把页表看作一本厚重的“电话簿”，TLB 就是手机“常用联系人列表”——你不需要每次都翻电话簿查号码，最近联系过的人名和号码会被快速缓存。\n","date":"2024-07-10T00:00:00Z","permalink":"https://zuoco.github.io/p/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","title":"虚拟内存"},{"content":"1. 基本命令选项 命令选项 用途 -i 指定网络接口 tcpdump -i eth0 -X （大写X）以 ASCII 和十六进制的形式输出捕获的数据包内容，减去链路层的包头信息 -XX （大写X）以 ASCII 和十六进制的形式输出捕获的数据包内容，包括链路层的包头信息 -n ip 不以别名的形式显示 -nn ip 和端口不以别名的形式显示 -S （大写S）以绝对值显示包的 ISN 号（包序列号），默认以上一包的偏移量显示 -vv 抓包的信息详细地显示 -vvv 抓包的信息更详细地显示 -w 抓包信息写入文件pcap，后面跟文件名 tcpdump -w test.pcap -r 读取文件pcap（就是-w保存的文件） 2. 过滤器 2.1. 指定协议类型 1 2 3 tcpdump tcp # 仅 TCP 流量 tcpdump udp # 仅 UDP 流量 tcpdump icmp # 仅 ICMP 流量（如 ping） 2.2. 指定IP地址 1 2 3 tcpdump host 192.168.1.100 # 抓取IP为 192.168.1.100 的数据包 tcpdump src 192.168.1.100 # 源 IP 为 192.168.1.100 tcpdump dst 192.168.1.100 # 目标 IP 为 192.168.1.100 2.3. 指定端口 1 2 3 4 tcpdump port 80 # HTTP 流量（端口 80） tcpdump portrange 8000-8080 # 端口范围 8000 到 8080 tcpdump src port 22 # 源端口为 22（SSH） tcpdump dst port 443 # 目标端口为 443（HTTPS） 2.4. 使用and组合过滤器 当有多个过滤条件时，推荐使用单因号。\n1 2 3 4 5 tcpdump \u0026#39;src 192.168.1.100 and dst 192.168.1.200\u0026#39; # IP组合 tcpdump \u0026#39;host 192.168.1.100 or host 192.168.1.200\u0026#39; tcpdump \u0026#39;host 192.168.1.100 and port 80\u0026#39; # IP-Port组合 tcpdump \u0026#39;host 192.168.1.100 and not port 22\u0026#39; # 排除 SSH 流量 tcpdump \u0026#39;src 192.168.1.100 and (dst port 80 or dst port 443)\u0026#39; # 嵌套过滤器，源 IP 为 192.168.1.100，目标端口为 80 或 443 2.5. 示例组合 1 2 tcpdump -i wlp4s0 \u0026#39;tcp and src 192.168.1.100 and (dst port 80 or dst port 443)\u0026#39; tcpdump -i wlp4s0 \u0026#39;src 192.168.1.100 and (dst port 80 or dst port 443) and (tcp or udp)\u0026#39; 3. 其他 tcpdump也可以过滤数据包的数据部分，例如过滤http的GET、POST请求等等。\n","date":"2024-07-05T00:00:00Z","permalink":"https://zuoco.github.io/p/linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%8603-tcpdump%E6%8A%93%E5%8C%85/","title":"Linux网络管理（03） — tcpdump抓包"},{"content":"1. sar -r命令 1 sar -r [interval] [count] interval：指定采样间隔。 count：指定采样次数。\n例如：\n1 2 3 4 5 6 7 8 zcli@MiBook:~$ sar -r 1 3 Linux 6.11.0-26-generic (MiBook) 2025年06月13日 _x86_64_\t(16 CPU) 14时40分09秒 kbmemfree kbavail kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty 14时40分10秒 18907448 25056588 6238488 19.39 459788 5979568 22043760 54.36 6992188 4599208 840 14时40分11秒 18954764 25103904 6191164 19.25 459788 5979568 22043568 54.36 6936048 4599208 8 14时40分12秒 18958924 25108068 6187000 19.23 459796 5979568 22043576 54.36 6930696 4599216 100 平均时间: 18940379 25089520 6205551 19.29 459791 5979568 22043635 54.36 6952977 4599211 316 kbmemfree： 对应于free命令的free。 kbavail： 对应 free 中的 available 字段。 kbmemused： 对应 free 中的 used 字段。 %memused： kbmemused字段所占百分比。 kbbuffers+kbcached: 对应free命令输出的buff/cache字段。 sar -S 1 2 3 4 5 6 zcli@MiBook:~$ sar -S 1 2 14时54分27秒 kbswpfree kbswpused %swpused kbswpcad %swpcad 14时54分28秒 8388604 0 0.00 0 0.00 14时54分29秒 8388604 0 0.00 0 0.00 平均时间: 8388604 0 0.00 0 0.00 参数选项： -S 显示swap空间使用情况。\n","date":"2024-06-17T00:00:00Z","permalink":"https://zuoco.github.io/p/sar-r%E5%91%BD%E4%BB%A4%E4%B8%8Esar-s%E5%91%BD%E4%BB%A4/","title":"sar -r命令与sar -S命令"},{"content":"1. Network-Manager网络管理工具 在Debian系统中，NetworkManager（NM） 是一个功能强大的网络管理工具，支持有线、无线、VPN、代理等多种网络连接方式。\n1.1. 安装NetworkManager 1 sudo apt install network-manager 1.2. 启动并启用 NetworkManager 服务 1 2 sudo systemctl start NetworkManager sudo systemctl enable NetworkManager 检查服务运行状态：\n1 sudo systemctl status NetworkManager 1.3. 配置NetworkManager 默认情况下，NetworkManager 可能不会管理某些接口（如以太网或无线接口）。需要修改配置文件以确保接口由 NetworkManager 管理。\n修改 /etc/NetworkManager/NetworkManager.conf:\n1 2 3 4 5 [main] plugins=ifupdown,keyfile [ifupdown] managed=true managed=true 表示 NetworkManager 会接管所有接口的配置。\nmanaged=false 表示 NetworkManager 不会管理接口（默认值）。\n修改完成后，重启 NetworkManager 服务：\n1 sudo systemctl restart NetworkManager 1.4. 使用 nmcli 命令行工具管理网络 nmcli 是 NetworkManager 的命令行工具，用于管理网络连接。 (1) 查看网络设备状态\n1 nmcli device status 命令输出(CONNECTION 列显示当前使用的连接配置)：\n(2) 扫描并列出可用的 WiFi 网络\n1 nmcli device wifi list 命令输出(IN-USE 标记 * 表示当前已连接的网络)：\n(3) 连接 WiFi 网络\n1 nmcli device wifi connect \u0026#34;SSID名称\u0026#34; password \u0026#34;WiFi密码\u0026#34; (4) 查看已保存的连接\n1 nmcli connection show (5) 修改密码\n1 nmcli connection modify \u0026#34;MyWiFi\u0026#34; wifi-sec.psk \u0026#34;新密码\u0026#34; (6) 删除连接\n1 nmcli connection delete \u0026#34;MyWiFi\u0026#34; 1.5. nmcli其他用法 nmcli还可以用于配置静态IP、配置代理服务器、配置多网卡（同时使用两个网卡，分别连接不同网络）等等，用到的时候再记录。\n","date":"2024-06-11T00:00:00Z","permalink":"https://zuoco.github.io/p/linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%8602-network-manager/","title":"Linux网络管理（02） — Network Manager"},{"content":"1. iproute2 ip命令全称iproute2，\n1. 查看所有网卡的状态\n1 ip a # ip addr show 的简写 命令输出：\n图中有三张网卡： lo（本地回环）、wlp3s0（无线网卡）、wlxc83a35e25ecc（usb有线网卡）。 state UP: 表示网卡已启用。 link/ether: 网卡的MAC地址。 inet 192.168.0.7/24: 网卡的ipv4-IP地址和子网掩码。 brd 192.168.0.255: 网卡的广播地址。 inet6 fe80::fac7::f96d::9e05::3cda/64: 网卡的ipv6-IP地址和子网掩码。 2.显示指定接口的信息\n1 ip addr show eth0 # ip a s eht0 3.显示接口的统计信息\n1 ip -s link show eth0 4.启用网卡\n1 2 sudo ip link set eth0 up # 启用接口， 将 \u0026#34;eth0\u0026#34; 替换为实际的网络接口名称 sudo ip link set eth0 down # 禁用接口 5.添加/删除 IP 地址\n1 2 sudo ip addr add 192.168.1.100/24 dev eth0 # 为 eth0 接口添加 IPv4 地址， 重启后失效 sudo ip addr del 192.168.1.100/24 dev eth0 # 删除 eth0 接口的指定 IP 地址 6.还是路由表、ARP表、VLAN相关功能 略\u0026hellip;\u0026hellip;\n2. netstat 查看网络连接状态, 先看一下命令的默认输出：\n默认情况下，对于一些有别名的 ip 地址和端口号 netstat 会显示别名，例如127.0.0.1显示localhost，80端口会显示成http，如果我们想要的是原始IP地址，可以使用-n参数。\n其他选项\n1 2 3 4 5 6 7 8 9 10 -a (all)显示所有选项，netstat 默认不显示 LISTEN 相关。 -t (tcp)仅显示 tcp 相关选项 -u (udp)仅显示 udp 相关选项 -n 不显示别名，能显示数字的全部转化成数字 -l 仅列出有在 Listen (监听) 的服務状态 -p 显示建立相关链接的程序名 -r 显示路由信息，路由表 -e 显示扩展信息，例如uid等 -s 按各个协议进行统计 (重要) -c 每隔一个固定时间，执行该 netstat 命令。 3. lsof list opened filedesciptor，在Linux系统中，所有的与资源句柄相关的东西都可以统一抽象成文件描述符。\n-p : 指定进程ID。 lsof 命令第一栏进程名在显示的时候，默认显示前 n 个字符, 可以使用 +c 20来指定显示的字符数。 如果需要仅显示系统的网络连接信息，可以-Pni。 4. nc netcat命令，常见的用法是模拟一个服务器程序被其他客户端连接，或者模拟一个客户端连接其他服务器，连接之后就可以进行数据收发。\n1.模拟一个服务器程序\n1 nc -v -l 192.168.0.5 6060 这样就在 6060 端口开启了一个服务器，我们可以通过192.168.0.5:6060来连接这个服务器。\n2.模拟一个客户端程序\n1 2 nc -v www.baidu.com 80 nc -v -p 6050 www.baidu.com 80 # 指定客户端使用6050端口连接服务器 3.发送数据\n服务端： 客户端： 发送数据: curl curl用于发送http请求。\n1.保存网页\n1 curl http://www.baidu.com \u0026gt; index.html 2.下载文件\n1 curl --fail --show-error --location --progress-bar \u0026#34;https://ollama.com/download/ollama-linux-${ARCH}.tgz${VER_PARAM}\u0026#34; 3.GET和POST请求\n没用过。\n","date":"2024-06-07T00:00:00Z","permalink":"https://zuoco.github.io/p/linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%8601-%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/","title":"Linux网络管理（01） — 常用网络命令"},{"content":"分支管理 master分支:\n用于生产环境的部署，不允许直接push分支，由release分支或者hotfix分支合并。\nhotfix分支:\n针对线上紧急问题进行修复的分支，以master分支为基线创建的，修复完成后合并到dev分支、master分支。\nrelease分支:\n预发布分支，UAT测试阶段使用，一般由test分支或hitfix分支合并。\ndev分支:\n开发分支，最新版本迭代代码，包括bug修复后的代码。\nfeature分支:\n基于dev分支在本地创建，每个开发人员的本地分支，针对各自的功能进行开发，开发完成合并到dev分支，并删除该fearure分支，feature是每个开发人员的本地分支，不可推送到远程，只能在本地合并到dev分支，然后推送dev分支。\n日常工作 一般是从远程仓库将dev分支拉取到本地，然后创建feature分支，开发完成后，将feature分支合并到dev分支，并删除feature分支，然后推送dev分支到远程仓库。 但是要注意，为避免与团队其他成员的代码冲突，定期将 dev 分支的最新代码合并到你的功能分支。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 git clone \u0026lt;远程仓库地址\u0026gt; cd \u0026lt;项目目录\u0026gt; git checkout dev # 切换到 dev 分支 git pull origin dev # 拉取最新的 dev 分支代码 git checkout -b feature/your-module-name # 创建并切换到功能分支 # 开始开发功能，提交代码 git add . # 添加所有修改 git commit -m \u0026#34;完成模块A的功能X\u0026#34; # 提交描述清晰 # 开发中，要定期同步 dev 分支的更新，如果合并时出现冲突，需要手动解决冲突后重新提交。 git checkout feature/your-module-name # 切换回功能分支 git pull origin dev # 合并 dev 分支的最新代码 # 如果发生冲突，就手动处理一下 git add \u0026lt;冲突文件\u0026gt; # 标记冲突已解决 git commit # 提交合并后的代码 # 解决完了冲突后，推送代码到远程仓库 git push -u origin feature/user-authentication # 后面还需要提PR，代码审查，修改，合并分支feature到dev，可能是merge，也可能是cherry-pick ","date":"2024-06-03T00:00:00Z","permalink":"https://zuoco.github.io/p/%E4%BD%BF%E7%94%A8git%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/","title":"使用Git管理软件开发以及冲突解决"},{"content":"iBMC服务器管理软件 iBMC智能管理系统（Intelligent Baseboard Management Controller，以下简称iBMC）是面向服务器全生命周期的服务器嵌入式管理系统。提供硬件状态监控、部署、节能、安全等系列管理工具，标准化接口构建服务器管理更加完善的生态系统。\niBMC登陆界面 iBMC管理界面 监控与故障管理 (FDM) 故障诊断与管理（FDM）是iBMC一系列诊断技术和工具的总称，FDM对服务器各类部件进行全面的监控，实现服务器关键部件的深度故障诊断和故障预测机制。\n智慧能耗管理 (DEMT) 动态能耗管理技术（DEMT）是一组根据CPU负载、环境温度等多种输入参数，动态实时智能调节各部件的功耗的技术集合，通过动态能耗管理技术和休眠技术，使设备节能管理更加高效。\n“零”接触运维 iBMC提供KVM，SOL虚拟媒体，Web接入等多种远程管理方式，支持配置、升级、部署能力，实现“零”接触运维，方便运维人员随时随地接入服务器实施运维管理。\n","date":"2024-05-27T00:00:00Z","permalink":"https://zuoco.github.io/p/ibmc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/","title":"iBMC服务器管理软件"},{"content":"1. 内核中的Makefile、Kconfig、config Makefile：编译源文件的方法。 Kconfig：内核的配置菜单。 .config：根据配置菜单生成的配置，根据该配置编译内核。 2. Makefile 内核中的Makefile中有三种编译规则：\n编译进入内核。 1 obj-y += xxx/ # 进入子Makefile 1 obj-y += xxx.o 根据.config决定是否编译进入内核。 1 obj-$(CONFIG_XXX) += xxx/ # 进入子Makefile 1 obj-$(CONFIG_XXX) += xxx.o 编译为模块 执行make modules时被编译 1 obj-m += xxx.o 3. Kconfig 执行make menuconfig时会展示一个菜单，就是Kconfig的功劳。\nlinux-6.0目录下的Kconfig: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # SPDX-License-Identifier: GPL-2.0 # # For a description of the syntax of this configuration file, # see Documentation/kbuild/kconfig-language.rst. # mainmenu \u0026#34;Linux/$(ARCH) $(KERNELVERSION) Kernel Configuration\u0026#34; source \u0026#34;scripts/Kconfig.include\u0026#34; # ...... 表示省略一堆代码 # ...... source \u0026#34;drivers/Kconfig\u0026#34; # ...... # ...... source \u0026#34;Documentation/Kconfig\u0026#34; linux-6.0/drivers目录下的Kconfig: 1 2 3 4 5 6 7 8 9 10 11 # SPDX-License-Identifier: GPL-2.0 menu \u0026#34;Device Drivers\u0026#34; # Keep I/O buses first # ...... # ...... source \u0026#34;drivers/video/Kconfig\u0026#34; ## ...... ## ...... linux-6.0/drivers/video目录下的Kconfig: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # SPDX-License-Identifier: GPL-2.0-only # # Video configuration # menu \u0026#34;Graphics support\u0026#34; # ...... # ...... source \u0026#34;drivers/gpu/drm/Kconfig\u0026#34; # ...... # ...... endmenu linux-6.0/drivers/gpu/drm目录下的Kconfig: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # ...... # ...... source \u0026#34;drivers/gpu/drm/display/Kconfig\u0026#34; # ...... #...... source \u0026#34;drivers/gpu/drm/amd/amdgpu/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/nouveau/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/i915/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/rockchip/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/qxl/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/virtio/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/xen/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/vboxvideo/Kconfig\u0026#34; drivers/gpu/drm/qxl/Kconfig: 1 2 3 4 5 6 7 8 9 10 11 12 # SPDX-License-Identifier: GPL-2.0-only config DRM_QXL tristate \u0026#34;QXL virtual GPU\u0026#34; depends on DRM \u0026amp;\u0026amp; PCI \u0026amp;\u0026amp; MMU select DRM_KMS_HELPER select DRM_TTM select DRM_TTM_HELPER select CRC32 help QXL virtual GPU for Spice virtualization desktop integration. Do not enable this driver unless your distro ships a corresponding X.org QXL driver that can handle kernel modesetting. 下面详细分析一下这个Kconfig文件的内。\n3.1. Kconfig文件内容分析 第1行\n1 # SPDX-License-Identifier: GPL-2.0-only 声明此文件的许可证为 GPL-2.0-only（GNU通用公共许可证第2版，仅限此版本）。这是一个开源许可证，表示任何人可以自由使用、修改和分发此代码，但必须保留相同的许可证条款。only 表示只能使用 GPL-2.0，不能升级到更新的版本（如 GPL-3.0）。 第2行\n1 config DRM_QXL # 使用config关键字定义一个选项 定义了一个选项，省略了CONFIG_，全称是CONFIG_DRM_QXL，在对应的Makefile文件中使用。如下：\ndrivers/gpu/drm/Makefile\n1 obj-$(CONFIG_DRM_QXL) += qxl/ drivers/gpu/drm/qxl/Makefile\n1 obj-$(CONFIG_DRM_QXL)+= qxl.o 第3行\n1 tristate \u0026#34;QXL virtual GPU\u0026#34; 声明 DRM_QXL 是一个 三态选项（tristate），可选值为 Y（内置）、M（模块）、N（禁用），并为其添加描述文本 \u0026ldquo;QXL virtual GPU\u0026rdquo;。 Y（Yes）：驱动直接编译进内核。\nM（Module）：驱动编译为可加载的内核模块（.ko 文件）。\nN（No）：不编译此驱动。\n第4行\n1 depends on DRM \u0026amp;\u0026amp; PCI \u0026amp;\u0026amp; MMU 指定 DRM_QXL 的依赖条件，只有当 DRM、PCI 和 MMU 都被启用时，DRM_QXL 才能被选择。\n第5~8行\n1 2 3 4 select DRM_KMS_HELPER select DRM_TTM select DRM_TTM_HELPER select CRC32 反向依赖关系，该选项选中时，同时选中select后面定义的那一项。。\n第9~13行\n1 2 3 4 help QXL virtual GPU for Spice virtualization desktop integration. Do not enable this driver unless your distro ships a corresponding X.org QXL driver that can handle kernel modesetting. 为 DRM_QXL 提供帮助信息，在配置工具中按 ? 可以查看。\n4. .config文件 使用make menuconfig生成的配置文件。\n5. make menuconfig 运行make menuconfig命令，会显示一个配置菜单:\n使用“上”“下”方向键选择选项，使用“空格”键选择或取消选择选项，使用“Enter”键进入子菜单。使用“左”“右”保存、后退、加载已有的.config文件。配置完后保存为.config文件，然后运行make命令进行开始编译。\n","date":"2024-05-10T00:00:00Z","permalink":"https://zuoco.github.io/p/linux%E5%86%85%E6%A0%B8%E6%9E%84%E5%BB%BA%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA/","title":"Linux内核构建、内核模块构建"},{"content":"free命令 命令结果如下：\n1 2 3 4 5 6 7 8 9 10 zcli@MiBook:~$ free -m total used free shared buff/cache available 内存： 31412 6177 19370 127 6443 25234 # 物理内存 交换： 8191 0 8191 # 交换空间 zcli@MiBook:~$ zcli@MiBook:~$ free -g total used free shared buff/cache available 内存： 30 6 18 0 6 24 交换： 7 0 7 zcli@MiBook:~$ 参数选项： -m 以MB为单位显示内存使用情况，-g 以GB为单位显示内存使用情况。\n字段解释 物理内存: 就是我们主板上的内存条。 交换空间（Swap）: 是磁盘上的一块虚拟内存区域。当物理内存不足时，操作系统会将不活跃的内存页移动到 Swap 中，释放物理内存供其他程序使用。 shared: 共享内存，即多个进程共享的内存，如共享内存段（System V 共享内存、POSIX 共享内存）等等。 used: 已经使用的物理内存，total-available或者total-free-buff/cache。 buff/cache: 缓冲/缓存。 free与available: free是表面上的可用物理内存，available是实际可用的物理内存，available=free+buff/cache，当内存（free）不够时，系统会从buff/cache中回收内存。 ","date":"2024-05-08T00:00:00Z","permalink":"https://zuoco.github.io/p/free%E5%91%BD%E4%BB%A4/","title":"free命令"},{"content":"1. 虚拟硬件模型 简单的讲“虚拟化”就是使用软件模拟硬件，一个硬件设备，例如QXl（一种虚拟显卡），或者一套硬件，例如虚拟机（可以运行操作系统）。虚拟硬件模型虚拟的就是一个完整的主板环境，如QEMU中的q35或i440fx。那么这个主板环境有那些东西呢？\n芯片组（Chipset）：如北桥、南桥（或现代的MCH/ICH），负责协调CPU、内存、I/O设备等的通信。 内存控制器：管理内存的访问和分配。 PCI/PCIe总线：支持外设的连接和数据传输。 存储控制器：如SATA、NVMe接口。 其他硬件特性：如UEFI固件、IOMMU（用于设备直通）、电源管理等。 2. q35与i440fx i440FX\n这个比较老了，是QEMU最早支持的虚拟硬件模型之一，基于1996年发布的Intel 82443FX（i440FX）芯片组。\nq35\n这是QEMU中较新的虚拟硬件模型，基于Intel 82801（ICH9）芯片组。相比于i440FX，它提供了更多的现代硬件特性支持，适合更高要求的应用场景支持很多现代硬件特性，如：\nIOMMU支持：通过vIOMMU（虚拟IOMMU），可以实现设备直通（如GPU、网卡等），这对于高性能计算和图形处理非常重要。 UEFI支持：通过OVMF（Open Virtual Machine Firmware），可以支持UEFI启动，这在现代操作系统中越来越普遍。 PCIe支持：相比i440FX，q35提供了更好的PCI Express（PCIe）支持，允许更高的带宽和更低的延迟。 电源管理：支持S3（挂起到RAM）和S4（挂起到磁盘）等高级电源状态，这些功能在现代PC中很常见。 VirtIO支持：推荐使用VirtIO SCSI或VirtIO Block控制器以获得更好的性能和维护性。 ","date":"2024-05-03T00:00:00Z","permalink":"https://zuoco.github.io/p/%E8%99%9A%E6%8B%9F%E7%A1%AC%E4%BB%B6%E6%A8%A1%E5%9E%8B/","title":"虚拟硬件模型"},{"content":" 1. 系统基础组件 2. 内核镜像 3. 内核头文件 4. 硬件支持 5. 内核工具 6. 内核的用户空间接口层 7. 内核模块 8. 音频支持 9. 系统管理工具 1. 系统基础组件 1 2 3 zci@GEM:~$ apt list --installed | grep linux-base linux-base/noble-updates,now 4.5ubuntu9+24.04.1 all [已安装，自动] 一个元包（meta-package），用于确保系统中安装了基本的 Linux 工具和库。它通常包含与 Linux 系统基础功能相关的依赖项（如 init 脚本、基础工具等）。该包本身不提供具体功能，而是通过依赖关系拉入其他必要的软件包。\n2. 内核镜像 1 2 3 4 5 zci@GEM:~$ apt list --installed | grep linux-image linux-image-6.11.0-29-generic/noble-updates,noble-security,now 6.11.0-29.29~24.04.1 amd64 [已安装，自动] linux-image-6.14.0-24-generic/noble-updates,noble-security,now 6.14.0-24.24~24.04.3 amd64 [已安装，自动] linux-image-generic-hwe-24.04/noble-updates,noble-security,now 6.14.0-24.24~24.04.3 amd64 [已安装，自动] noble： Ubuntu 24.04 的代号。 linux-image-6.11.0-29-generic: 通用内核（generic）版本，一个较旧的内核版本（6.11），可能作为备用内核保留。 linux-image-6.14.0-24-generic: 更新的通用内核版本，通过 apt upgrade 或安全更新安装，当前系统正在使用的主内核。通常，系统会保留多个内核版本以防止升级失败时回滚。 linux-image-generic-hwe-24.04: Ubuntu 的长期支持（LTS）版本中提供的较新内核，用于支持更新的硬件，这是一个元包，由其他包（如 linux-generic 或 linux-image）自动拉入。 3. 内核头文件 1 2 3 4 5 **zci@GEM:~$ apt list --installed | grep linux-headers linux-headers-6.11.0-29-generic/noble-updates,noble-security,now 6.11.0-29.29~24.04.1 amd64 [已安装，自动] linux-headers-6.14.0-24-generic/noble-updates,noble-security,now 6.14.0-24.24~24.04.3 amd64 [已安装，自动] linux-headers-generic-hwe-24.04/noble-updates,noble-security,now 6.14.0-24.24~24.04.3 amd64 [已安装，自动] 编译内核模块（如驱动程序）所需的头文件和 Makefile，与内核经镜像对应，编译内核模块时，需要使用与当前内核匹配的头文件。\n4. 硬件支持 1 2 3 linux-headers-generic-hwe-24.04 ├── linux-hwe-6.14-headers-6.14.0-24 ← 当前 HWE 内核头文件（6.14） └── linux-hwe-6.11-headers-6.11.0-29 ← 旧版本 HWE 内核头文件（6.11） 1 2 3 linux-generic-hwe-24.04/noble-updates,noble-security,now 6.14.0-24.24~24.04.3 amd64 [已安装] ├── linux-image-generic-hwe-24.04/noble-updates,noble-security,now 6.14.0-24.24~24.04.3 amd64 [已安装，自动] └── linux-firmware/noble-updates,noble-security,now 20240318.git3b128b60-0ubuntu2.14 amd64 [已安装，自动] linux-generic-hwe-24.04: 硬件支持的战略指挥官（决定是否启用HWE）。\nlinux-image-generic-hwe-24.04: 内核版本管理员（提供具体内核）。 linux-headers-generic-hwe-24.04: 编译硬件相关模块的头文件。\nlinux-firmware: 核心固件包，提供各种硬件设备（如显卡、网卡、Wi-Fi 适配器等）所需的二进制固件文件，存储在 /lib/firmware 目录。确保系统在安装时支持尽可能多的硬件设备，无需手动安装驱动。\n5. 内核工具 1 2 3 4 5 linux-tools-common/noble-updates,noble-security,now 6.8.0-64.67 all [已安装，自动] linux-tools-6.11.0-29-generic/noble-updates,noble-security,now 6.11.0-29.29~24.04.1 amd64 [已安装，自动] linux-tools-6.14.0-24-generic/noble-updates,noble-security,now 6.14.0-24.24~24.04.3 amd64 [已安装，自动] linux-hwe-6.11-tools-6.11.0-29/noble-updates,noble-security,now 6.11.0-29.29~24.04.1 amd64 [已安装，自动] linux-hwe-6.14-tools-6.14.0-24/noble-updates,noble-security,now 6.14.0-24.24~24.04.3 amd64 [已安装，自动] 提供与特定内核版本配套的用户空间工具，用于系统性能分析（如 perf）、硬件调试（如 turbostat）、内核功能配置（如 cpupower）等等，包含的关键工具：\n工具 用途 perf 性能分析器 usbip USB设备共享 cpupower CPU频率控制 x86_energy_perf_policy 能效策略 bpftool eBPF管理 turbostat CPU状态监控 内核中的文件系统结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 zci@GEM:~$ tree /usr/lib/linux-tools -L 2 /usr/lib/linux-tools ├── 6.11.0-29-generic # 6.11内核专用工具，软连到/usr/lib/linux-hwe-6.11-tools-6.11.0-29 │ ├── acpidbg │ ├── bpftool │ ├── cpupower │ ├── lib │ ├── libperf-jvmti.so │ ├── perf │ ├── rtla │ ├── turbostat │ ├── usbip │ ├── usbipd │ └── x86_energy_perf_policy └── 6.14.0-24-generic # 6.14内核专用工具， 软连到/usr/lib/linux-hwe-6.14-tools-6.14.0-24 6. 内核的用户空间接口层 1 linux-libc-dev/noble-updates,noble-security,now 6.8.0-64.67 amd64 [已安装，自动] 包含/usr/include/linux/下的头文件，用于用户空间程序（特别是C库）与内核交互，是编译任何依赖内核特性的程序的基础。\n关键作用：\n✅ 系统调用定义：提供 syscalls.h 等系统调用接口声明。\n✅ 内核数据结构：包含 socket.h, input.h 等内核数据结构定义。\n7. 内核模块 1 2 3 4 5 linux-modules-6.11.0-29-generic/noble-updates,noble-security,now 6.11.0-29.29~24.04.1 amd64 [已安装，自动] linux-modules-6.14.0-24-generic/noble-updates,noble-security,now 6.14.0-24.24~24.04.3 amd64 [已安装，自动] linux-modules-extra-6.11.0-29-generic/noble-updates,noble-security,now 6.11.0-29.29~24.04.1 amd64 [已安装，自动] linux-modules-extra-6.14.0-24-generic/noble-updates,noble-security,now 6.14.0-24.24~24.04.3 amd64 [已安装，自动] linux-modules-*: 包含基础的内核模块，例如网络驱动、存储驱动、USB 支持等。\nlinux-modules-extra: 包含额外的内核模块（如专有驱动、虚拟化支持、硬件扩展模块等）,如NVIDIA 显卡驱动、AMDGPU 驱动、VirtualBox 支持模块。\n8. 音频支持 1 linux-sound-base/noble,now 1.0.25+dfsg-0ubuntu7 all [已安装，自动] 提供音频的内核模块、驱动、用户空间工具等等。\n9. 系统管理工具 1 util-linux/noble-updates,now 2.39.3-9ubuntu6.3 amd64 [已安装，自动] Linux 系统的核心工具包，提供磁盘管理、文件系统操作等基础功能，如 mount、fdisk、systemd 等。\n","date":"2024-04-18T00:00:00Z","permalink":"https://zuoco.github.io/p/linux%E5%86%85%E6%A0%B8%E7%8E%AF%E5%A2%83%E4%BB%A5ubuntu%E4%B8%BA%E4%BE%8B/","title":" Linux内核环境，以Ubuntu为例 "},{"content":" 1. 线程同步 2. 互斥锁 (std::mutex) 3. 避免死锁 4. 使用消息队列 5. 读写锁（std::shared_mutex） 6. 原子操作（atomic） 1. 线程同步 标准库中的同步方法都是 RAII 的。\nstd::mutex 互斥锁，防止多个线程同时访问共享资源。 在C代码中往往会直接使用pthread线程库中的mutex，但是在C++中一般使用lock_guard或者unique_lock。 std::lock_guard RAII 风格的锁管理器，离开作用域自动释放锁。\n相对于std::unique_lock更加轻量级，用于简单场景。\n构造时立即加锁，析构时自动解锁。 不支持手动解锁或重新加锁。\n不可复制，不可移动。 std::unique_lock 功能类似lock_guard，功能更多。\n支持延迟加锁（通过 std::defer_lock）。\n支持手动调用 lock() 和 unlock()。 支持尝试加锁（try_lock()、try_lock_for()、try_lock_until()）。\n可移动（std::move），不可复制。 std::atomic 原子操作模板类型，基于硬件级别的原子指令，用于简单数据类型，比如说基本数据类型的自增，自减。 2. 互斥锁 (std::mutex) 其中最基础的就是互斥锁了， 用来保证同一时刻只有一个线程访问临界区代码，通常配合 std::lock_guard、std::unique_lock 使用。std::lock_guard的功能非常简单，就是创建一个 RAII 风格的锁管理器，在作用域结束后自动销毁锁。 此处主要介绍std::unique_lock：\n延迟加锁（std::defer_lock），在构造 std::unique_lock 时不立即加锁，而是稍后手动加锁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; std::mutex mtx1, mtx2; void task() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock1(mtx1, std::defer_lock); // 不立即加锁 std::unique_lock\u0026lt;std::mutex\u0026gt; lock2(mtx2, std::defer_lock); // 不立即加锁 // 手动加锁，避免死锁（按固定顺序） std::lock(lock1, lock2); // 安全地同时加锁两个互斥量 // 访问共享资源 std::cout \u0026lt;\u0026lt; \u0026#34;Thread acquired both locks.\u0026#34; \u0026lt;\u0026lt; std::endl; // 离开作用域，自动销毁锁 } 手动加锁/解锁，在函数内部临时执行共享数据的互斥读/写。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; std::mutex mtx; int shared_data = 0; void process_data() { // ... std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); // 上锁 ++shared_data; // 读写共享数据 lock.unlock(); // 解锁 // ... } 尝试加锁（try_lock），避免线程长时间等待锁，提高程序响应性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; std::mutex mtx; void attempt_lock() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::try_to_lock); // 尝试加锁 if (lock.owns_lock()) { std::cout \u0026lt;\u0026lt; \u0026#34;Lock acquired successfully!\u0026#34; \u0026lt;\u0026lt; std::endl; // 访问共享资源 } else { std::cout \u0026lt;\u0026lt; \u0026#34;Failed to acquire lock. Doing something else...\u0026#34; \u0026lt;\u0026lt; std::endl; } } 与条件变量配合，线程等待某个条件满足后被唤醒，实现线程间的同步（如生产者-消费者模型）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;thread\u0026gt; std::mutex mtx; std::condition_variable cv; bool ready = false; void wait_for_ready() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); /** * 1. 自动解锁，并等待信通知。 * 2. 线程被唤醒时，会自动重新获取锁，确保后续操作的原子性。 */ cv.wait(lock, []{ return ready; }); std::cout \u0026lt;\u0026lt; \u0026#34;Condition met! Proceeding...\u0026#34; \u0026lt;\u0026lt; std::endl; } void set_ready() { std::this_thread::sleep_for(std::chrono::seconds(1)); { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); ready = true; } cv.notify_one(); // 唤醒一个等待线程 } int main() { std::thread t1(wait_for_ready); std::thread t2(set_ready); t1.join(); t2.join(); return 0; } 转移锁所有权（移动语义），在函数间传递锁的管理权。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; std::mutex mtx; void transfer_lock(std::unique_lock\u0026lt;std::mutex\u0026gt; lock) { std::cout \u0026lt;\u0026lt; \u0026#34;Lock transferred to this function.\u0026#34; \u0026lt;\u0026lt; std::endl; // 函数结束时自动解锁 } int main() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); transfer_lock(std::move(lock)); // 移动锁的所有权 // 此时 lock 为空，不能再使用 return 0; } 3. 避免死锁 std::scoped_lock 支持同时锁定多个互斥锁，并通过原子性加锁（内部调用 std::lock）避免死锁。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; std::mutex mtx1, mtx2; void update_shared_resources() { std::scoped_lock lock(mtx1, mtx2); // 同时锁定两个互斥锁 // 安全地访问共享资源 } 4. 使用消息队列 共享变量越多，锁的复杂度越高，所以尽可能使用消息队列进行线程间通信。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 std::queue\u0026lt;int\u0026gt; tasks; std::mutex mtx; std::condition_variable cv; void producer() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); tasks.push(42); // 入队 cv.notify_one(); // 通知消费者 } void consumer() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); cv.wait(lock, [] { return !tasks.empty(); }); // 等待队列非空 int task = tasks.front(); // 读取队头数据 tasks.pop(); } 5. 读写锁（std::shared_mutex） 现在有一个多线程场景，一个线程写数据，另外还有多个线程读数据，那么 std::shared_mutex 就派上了用场了， 这是 C++17 提供的特性，允许多个线程同时读，但写操作必须独占。搭配 std::shared_lock 和 std::unique_lock 使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;shared_mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; std::shared_mutex rw_mtx; void reader(int id) { std::shared_lock\u0026lt;std::shared_mutex\u0026gt; lock(rw_mtx); std::cout \u0026lt;\u0026lt; \u0026#34;Reader 线程读数据。\u0026#34; \u0026lt;\u0026lt; std::endl; } void writer(int val) { std::unique_lock\u0026lt;std::shared_mutex\u0026gt; lock(rw_mtx); std::cout \u0026lt;\u0026lt; \u0026#34;Writer 线程写数据 \u0026#34; \u0026lt;\u0026lt; std::endl; } 6. 原子操作（atomic） 可以理解为一个非常简单的计数器。可以原子的递增、递减。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;atomic\u0026gt; std::atomic\u0026lt;int\u0026gt; counter{0}; void worker() { for (int i = 0; i \u0026lt; 10000; ++i) { counter.fetch_add(1); } } int main() { std::thread t1(worker); std::thread t2(worker); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;counter = \u0026#34; \u0026lt;\u0026lt; counter \u0026lt;\u0026lt; std::endl; } ","date":"2024-02-07T00:00:00Z","permalink":"https://zuoco.github.io/p/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/","title":"C++ 多线程中的同步方法"},{"content":" 1. 创建一个线程对象 2. 创建带参数thread对象 3. C++20新鲜玩意儿 4. 线程管理 4.1. 线程安全退出 4.2. 异步任务 4.3. 捕获线程内的异常 5. 标准库容器的线程安全 C++11提供了一个std::thread，它通过构造函数启动一个新线程，任务可以是普通函数、Lambda 表达式、类的成员函数等。在Linux平台上是基于pthread的，在Win平台上则是基于Windows原生API（MSVC），是对平台上的线程接口进行面向对象的封装，所以对于熟悉pthread的，这个std::thread比较好理解。\n1. 创建一个线程对象 使用普通函数：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void hello() { std::cout \u0026lt;\u0026lt; \u0026#34;std::thread\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t(hello); // 创建线程 t.join(); // 等待线程完成 return 0; } 使用lambda:\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; int main() { std::thread t([]() { std::cout \u0026lt;\u0026lt; \u0026#34;std::thread\u0026#34; \u0026lt;\u0026lt; std::endl; }); t.join(); return 0; } 使用类成员函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; class MyClass { public: void print() { std::cout \u0026lt;\u0026lt; \u0026#34;std::thread\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { MyClass obj; std::thread t(\u0026amp;MyClass::print, \u0026amp;obj); // 传递成员函数指针和对象指针 t.join(); return 0; } 2. 创建带参数thread对象 参数使用引用方式时，要小心参数的生命周期，数据竞态。\n值拷贝（默认）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;string\u0026gt; void print_message(const std::string\u0026amp; message) { std::cout \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } int main() { std::string msg = \u0026#34;AAABBBCCC!\u0026#34;; std::thread t(print_message, msg); // 按值传递参数 t.join(); return 0; } 引用传递，通过 std::ref/std::cref 包装参数，传递参数的引用:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;functional\u0026gt; // std::ref void modify_value(int\u0026amp; value) { value += 10; std::cout \u0026lt;\u0026lt; \u0026#34;----------: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } int main() { int data = 100; std::thread t(modify_value, std::ref(data)); // 按引用传递参数 t.join(); std::cout \u0026lt;\u0026lt; \u0026#34;+++++++++++: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; return 0; } 使用移动语义，将临时对象的所有权转移给线程函数，避免拷贝开销。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;utility\u0026gt; // std::move void process_string(std::string str) { std::cout \u0026lt;\u0026lt; \u0026#34;Processing string: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; } int main() { std::string data = \u0026#34;AAAAAA\u0026#34;; std::thread t(process_string, std::move(data)); // 移动语义传递参数 t.join(); return 0; } 3. C++20新鲜玩意儿 C++20引入了std::jthread，它在对象析构时自动调用join()。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void task() { std::cout \u0026lt;\u0026lt; \u0026#34;Thread is running...\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::jthread jt(task); // 自动 join，无需显式调用 return 0; // 程序正常退出 } std::jthread 提供 request_stop() 和 std::stop_token，允许线程主动响应取消请求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; void cancellable_task(std::stop_token stoken) { while (!stoken.stop_requested()) { std::cout \u0026lt;\u0026lt; \u0026#34;Working...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); } std::cout \u0026lt;\u0026lt; \u0026#34;Thread stopped.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::jthread jt(cancellable_task); std::this_thread::sleep_for(std::chrono::seconds(3)); jt.request_stop(); // 请求线程停止 return 0; } 4. 线程管理 4.1. 线程安全退出 使用join() 与 detach()保证线程安全退出。\njoin()：阻塞主线程，等待子线程完成。 1 2 std::thread t(task); t.join(); // 主线程等待 t 完成 detach()：分离线程，让其独立运行。 1 2 std::thread t(task); t.detach(); // t 在后台独立运行 分离后的线程就不能再join()了，所以要需确保线程在程序退出前完成。\n如果 std::thread 对象销毁时未调用 join() 或 detach()，会抛出 std::system_error 异常。\n4.2. 异步任务 std::async，在并发场景下，我们将耗时操作（如网络请求、文件读写、复杂计算）异步执行，避免阻塞主线程，提升程序响应性。但是使用异步任务时，要注意异步策略，如果使用默认策略，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { // 默认策略：由系统决定执行方式 auto future = std::async([]() { std::cout \u0026lt;\u0026lt; \u0026#34;异步任务运行在 ID: \u0026#34; \u0026lt;\u0026lt; std::this_thread::get_id() \u0026lt;\u0026lt; std::endl; return 42; }); // 可能在 future.get() 时才真正执行任务，不符合并发预期。 int result = future.get(); // 阻塞等待任务完成 std::cout \u0026lt;\u0026lt; \u0026#34;结果: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } 系统默认策略是： std::launch::async | std::launch::deferred 。系统可能以异步方式（std::launch::async）在新线程中执行任务，也可能以延迟方式（std::launch::deferred）在当前线程中执行任务，也就是说有可能不会创建线程，那就不是并发了，所以异步时要明确指定异步策略。\n1 auto future = std::async(std::launch::async, task_function); 4.3. 捕获线程内的异常 如果线程中抛出了异常，但是我们没有捕获它，C++ 会调用 std::terminate() 直接终止程序。所以需要在每个线程函数中使用 try-catch 将异常信息传出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;future\u0026gt; void risky_function() { // 模拟可能抛出异常的函数 if (rand() % 2 == 0) { throw std::runtime_error(\u0026#34;Something went wrong!\u0026#34;); } std::cout \u0026lt;\u0026lt; \u0026#34;Task succeeded.\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::promise\u0026lt;void\u0026gt; prom; std::future\u0026lt;void\u0026gt; fut = prom.get_future(); std::thread t([\u0026amp;] { try { risky_function(); // 可能抛出异常 prom.set_value(); // 成功时设置值 } catch (...) { prom.set_exception(std::current_exception()); // 捕获并传递异常 } }); t.join(); // 等待线程完成 try { fut.get(); // 获取结果 } catch (const std::exception\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Exception in thread: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } return 0; } 搭配std::promise和std::future来处理子线程抛出的异常，两者成对存在的：\nstd::promise 在子线程中： 任务成功执行，没有抛出异常，通过set_value()通知主线程: “我这里任务完成了”，该方法会标记 std::promise 的内部状态为“已就绪”（ready），并唤醒所有等待该 future 的线程。 任务抛出异常，通过set_exception(std::current_exception())捕获并传递异常，同样会唤醒所有等待该 future 的线程。 std::future 在主线程中： 通过fut.get();获取子线程执行结果，如果有异常就抛出。 5. 标准库容器的线程安全 stl标准库的容器本身不是线程安全的，多线程访问需要开发者自行加锁。\n","date":"2024-02-03T00:00:00Z","permalink":"https://zuoco.github.io/p/stdthread/","title":"std::thread"},{"content":"1. BootLoader Bootloader是操作系统的“引导程序”以及“引导管理程序”，操作系统的启动流程可以简单理解为：\n[上电] \u0026ndash;\u0026gt; [UEFI] \u0026ndash;\u0026gt; [bootloader] \u0026ndash;\u0026gt; [内核] 。\n显然，Bootloader的作用就是将内核加载到内存中，然后由于内核来加载操作系统的其他组件/服务，如文件系统，文件管理器，图形界面等。在linux生态中，常见的Bootloader有两种，Grub(用于X86架构)，U-Boot(用于ARM架构)。其中引导就是进行一些硬件的检测、初始化的任务，然后将内核加载到内存中来启动内核，引导管理就是当有多个内核时，在屏幕上显示一个菜单让用户选择要启动的哪个内核。 2. Grub grub程序保存在那里？\ngrub程序保存在EFI分区中，EFI分区挂在于位于/boot/efi目录下。\ngrub配置文件保存在那里？\n/boot/grub/grub.cfg文件，定义了grub是如何引导内核的。 /etc/default/grub文件，定义grub全局行为和启动参数，然后生成/boot/grub/grub.cfg文件，下面讲解以下该配置文件的内容： 1 2 3 4 5 6 7 8 9 GRUB_TIMEOUT=5 # 启动菜单的超时时间，超时后启动默认内核,-1表示无限等待。 GRUB_TIMEOUT_STYLE=menu # 启动菜单的样式，menu表示菜单样式，hidden表示隐藏菜单。 GRUB_DISTRIBUTOR=\u0026#34;$(sed \u0026#39;s, release .*$,,g\u0026#39; /etc/system-release)\u0026#34; # 动态提取发行版名称 GRUB_DEFAULT=saved # 默认启动项由上一次保存的选择决定 GRUB_DISABLE_SUBMENU=true # 禁用子菜单，所有内核和启动项直接显示在主菜单中。若设为 false，旧内核会折叠到“Advanced options”子菜单下。 GRUB_TERMINAL_OUTPUT=\u0026#34;console\u0026#34; # 强制GRUB仅使用文本控制台输出，禁用图形化终端（如gfxterm）。 GRUB_CMDLINE_LINUX=\u0026#34;rhgb quiet\u0026#34; # rhgb：启用Plymouth图形启动动画（常见于RHEL/CentOS/Fedora）。quiet：隐藏内核启动日志，仅显示简要信息。 GRUB_DISABLE_RECOVERY=\u0026#34;true\u0026#34; # 禁止恢复模式（Recovery Mode）的启动项。 GRUB_ENABLE_BLSCFG=true # 启用 Boot Loader Specification (BLS) 配置，取代传统的grub.cfg生成方式。 3. U-Boot XIP设备\n非XIP设备中存储的代码需要从存储设备中加载到内存中，然后才能执行，而XIP存储设备中的代码可以直接执行，XIP设备有SRAM、BROM等等，非XIP设备有EMMC、NANDFLASH、SD卡等等。 ARM-Linux启动流程\nU-Boot一般分为两个阶段，uboot-SPL和uboo-proper，CPU上电首先执行BROM中的程序(由芯片厂写入)，该程序会根据芯片的引脚电平或者寄存器配置确定启动模式(从那个设备启动系统)，例如系统安装在SD卡，BROM中的程序会初始化SD卡，然后拷贝uboot-spl到SRAM中，开始执行uboot-spl中的程序，uboot-spl程序会初始化LDDR内存、pll、gpio等等硬件，然后从SD卡中加载uboot-proper到LDDR中，并跳转到程序的入口地址执行uboot-proper程序。uboot还会初始化一些其他设备，例如网卡等，然后从SD卡中加载内核文件。\n参考:\nhttps://linux-sunxi.org/Bootable_SD_card#SD_Card_Layout 4. 修改Grub配置 GRUB配置文件： /boot/grub2/grub.cfg，但是该配置文件是生成的，不可直接手动修改，我们通过修改/etc/default/grub文件和/etc/grub.d/目录下的配置文件生成的。\n4.1. Fedora系统 修改/etc/default/grub文件，然后执行sudo grub2-mkconfig -o /boot/grub2/grub.cfg命令来生成新的/boot/grub2/grub.cfg文件。\n4.2. Debian系统 修改/etc/default/grub文件，然后执行sudo update-grub命令来生成新的/boot/grub/grub.cfg文件。\n5. 查看Grub配置信息 5.1. Fedora系统 5.1.1. grubby命令 查看默认引导项 1 sudo grubby --info=DEFAULT 列出所有引导项 1 sudo grubby --info=ALL 列出所有引导项的索引 1 sudo grubby --info=0 # 0是引导项的索引，使用sudo grubby --info=ALL命令查看 5.2. Debian系统 使用grep命令查看即可。\n","date":"2023-12-17T00:00:00Z","permalink":"https://zuoco.github.io/p/bootloader/","title":"BootLoader"},{"content":" 1. 注册信号处理器 1.1. signal 1.2. sigaction 2. 发送信号 3. 使用 Linux信号机制是一种异步通知机制，用于通知进程某个事件的发生。常被看做是一种软中断，类似于硬中断，但作用对象是进程而非 CPU，这是Glib提供的功能，所以源码需要到Glib代码库中查看。\n1 2 3 4 5 6 7 8 #define SIGHUP\t1 #define SIGINT\t2 #define SIGQUIT\t3 #define SIGILL\t4 #define SIGTRAP\t5 #define SIGABRT\t6 #define SIGIOT\t6 // ...... 常见的有SIGINT、SIGKILL、SIGUSR1、SIGUSR2、SIGTERM等等，使用kill -l命令可以查看系统中的所有信号。\nSIGINT 中断信号，用户按下 Ctrl+C 触发，用于终止前台进程 SIGKILL 强制终止进程，无法被忽略或捕获 SIGTERM 优雅终止信号，默认由 kill 命令发送，允许进程清理资源 SIGUSR1 SIGUSR2 用户自定义信号 2，可由程序自定义用途 1. 注册信号处理器 1.1. signal 指定进程收到某个信号后要去做的事情。\n1 2 // 若设置失败，返回 SIG_ERR，并设置 errno 表示错误原因。 extern __sighandler_t signal (int __sig, __sighandler_t __handler) __THROW; 其中 __sighandler_t：\n1 typedef void (*__sighandler_t) (int); 所以__sighandler_t是一个函数指针类型。\n1.2. sigaction 1 2 3 4 5 6 7 8 /* * __act: 内部包含了信号处理回调函数。 * __oact: 对于原来的信号处理回调函数的备份，一般为NULL，不备份。 */ extern int sigaction (int __sig, const struct sigaction *__restrict __act, struct sigaction *__restrict __oact ) __THROW; struct sigaction的原型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct sigaction { #if defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED union { __sighandler_t sa_handler; // 普通信号处理函数。 void (*sa_sigaction) (int, siginfo_t *, void *); // 带有额外数据的信号处理函数，需要将sa_flags成员设置为SA_SIGINFO。 } __sigaction_handler; # define sa_handler\t__sigaction_handler.sa_handler # define sa_sigaction\t__sigaction_handler.sa_sigaction # else __sighandler_t sa_handler; #endif __sigset_t sa_mask; // 信号处理期间阻塞的信号集，当前处理的信号会自动被阻塞（防止递归触发）。 int sa_flags; // 标志位，控制信号行为 void (*sa_restorer) (void); // 已弃用，保留历史兼容性 }; 对于sa_mask：\n1 2 3 // sa是struct sigaction类型变量 sigemptyset(\u0026amp;sa.sa_mask); // 清空信号集 sigaddset(\u0026amp;sa.sa_mask, SIGINT); // 添加 SIGINT 到阻塞列表 对于siginfo_t:\nsiginfo_t 是 POSIX 信号处理中用于传递 信号详细信息 的结构体，通常与 SA_SIGINFO 标志一起使用。它提供了比传统 signal() 函数更丰富的上下文信息。\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct { int si_signo; // 信号编号。 int si_errno; // 错误码，如果非零，表示与信号相关的系统错误码。 int si_code; // 指示信号产生的具体原因，分为系统生成（SI_KERNEL）和用户生成（SI_USER），需要的时候在进一步查询。 __pid_t si_pid;\t// 发送信号的进程 ID。 __uid_t si_uid;\t// 发送信号的用户 ID。 void *si_addr; // 指向引发信号的内存地址（如段错误时的无效地址）。 int si_status; // 传递子进程的退出状态或信号值。 long int si_band; // 与 SIGPOLL 或 SIGIO 信号一起使用，表示文件描述符的带事件（如 I/O 就绪）。 __sigval_t si_value; // 通过 sigqueue() 发送的自定义信号值（sigval）。 } siginfo_t; 2. 发送信号 发送信号有两个函数： kill、sigqueue，其中sigqueue可以携带额外的数据。\n1 2 3 4 5 6 7 8 9 10 /* * __pid: 目标进程ID。 * __sig: 要发送的信号。 */ extern int kill (__pid_t __pid, int __sig); /* * __val: 携带的额外数据。 */ extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val); union sigval的结构如下：\n1 2 3 4 5 union sigval { int sival_int; void *sival_ptr; }; 3. 使用 以带数据的信号为例：\n信号接收方： 1 2 3 4 5 6 7 8 9 10 11 // 信号处理函数 void handler(int sig, siginfo_t *info, void *old) { // 检查信号，sig。 // 从info中读取信号上下文。 } struct sigaction act; act.sa_sigaction = handler; act.sa_flags = SA_SIGINFO; sigaction(SIGUSR1, \u0026amp;act, NULL); 信号发送方： 1 2 3 union signal value; value.sigval_int = 99; sigqueue(getpid(), SIGUSR1, value); ","date":"2023-09-10T00:00:00Z","permalink":"https://zuoco.github.io/p/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A101-%E4%BF%A1%E5%8F%B7/","title":"Linux进程间通信（01） — 信号"},{"content":"2. 将程序装载到内存中 程序执行时所需要的指令和数据必须在内存中才能够正常运行，最简单的办法就是将程序运行所需要的指令和数据全都装入内存中，这样程序就可以顺利运行。程序装载有两种方式：静态装载、动态装载，静态装载占用内存较大，甚至大于物理内存的数量，所以现代操作系统都采用动态装载。程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是动态装入的基本原理。\n","date":"2023-07-12T00:00:00Z","permalink":"https://zuoco.github.io/p/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%A3%85%E8%BD%BD/","title":"进程的装载"},{"content":" 可执行文件只有装载到内存以后才能被CPU执行。早期的程序装载十分简陋，装载的基本过程就是把程序从外部存储器中读取到内存中的某个位置。随着硬件MMU的诞生，多进程、多用户、虚拟存储的操作系统出现以后，可执行文件的装载过程变得非常复杂。\n1. 进程的虚拟地址空间 每个程序被运行起来以后，它将拥有自己独立的虚拟地址空间（Virtual Address Space），这个虚拟地址空间的大小由计算机的硬件平台决定，具体地说是由CPU的位数决定的。硬件决定了地址空间的最大理论上限，即硬件的寻址空间大小，比如32位的硬件平台决定了虚拟地址空间的地址为0 ~ $2^{32-1}$，即0x00000000~0xFFFFFFFF，也就是我们常说的4GB 虚拟空间大小；而64位的硬件平台具有64位寻址能力，它的虚拟地址空间高达0 ~ $2^{64}$。\n我们以32位Linux操作系统为例，32位平台下有4GB的虚拟空间，而进程只能使用那些操作系统分配给进程的地址，如果访问未经允许的空间，那么操作系统就会捕获到这些访问，将进程的这种访问当作非法操作，强制结束进程。Windows系统上的进程因非法操作需要关闭以及Linux下的Segmentation fault很多时候就是因为进程访问了未经允许的地址。那么到底这4GB的进程虚拟地址空间是怎样的分配状态呢？默认情况下，Linux操作系统将进程的虚拟地址空间做了如下图所示的分配: 4GB内存可能不够用，所以Intel 在1995年在CPU中引入了PAE（物理地址扩展）机制，将32位地址扩展到36位，即4GB到64GB。\n对于Windows\n在 32 位 Windows系统 中，可用的虚拟地址空间共计为 2^32 字节（4 GB）。 通常，较低的 2 GB 用于用户空间，而上 2 GB 用于系统空间。不过Windows是可以修改启动参数将操作系统占用的虚拟地址空间减少到1GB，即跟Linux一样。在 64 位 Windows 中，虚拟地址空间的理论大小为 2^64 字节，但实际上仅使用一小部分。\n对于64位系统\n对于64位系统，理论虚拟地址空间是0 ~ $2^{64}$，也就是高达16EB的空间，实际也用不了这么多，所以一般操作系统分配了256TB的地址空间，低128TB分配给用户进程，高128TB给内核空间。\n","date":"2023-07-11T00:00:00Z","permalink":"https://zuoco.github.io/p/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/","title":"进程的虚拟地址空间"},{"content":" 1. 内存分配场景 2. 创建进程时的内存分配 2.1. 多进程 2.2. 启动一个程序 3. 进程申请动态内存 1. 内存分配场景 内核为进程分配内存，有两种情况：\n创建进程时。 进程申请动态内存。 2. 创建进程时的内存分配 在Linux系统中，创建进程有两种场景：\n一个程序使用多进程结构并行处理业务。 启动一个程序。 2.1. 多进程 想要将一个程序分成多个进程进行处理，需要使用fork()函数。fork函数基于当前进程（父进程）创建一个完全一样的新进程（子进程）。两个进程一起从fork函数返回，从此开始执行不同的代码。但是需要注意，在父进程中，fork返回子进程的ID，而子进程中的fork返回0。 fork创建新进程的速度还是很快的，因为这个fork并不会复制父进程的内存空间，而是和父进程共享一个写时复制的内存空间，两个进程可以同时自由的读取内存，但是任意一个进程需要修改内存时，就会复制一份给修改方单独使用。\n2.2. 启动一个程序 在fork后，我们可以在新进程中使用exec()族函数来拉取一个新的二进制文件，也就是使用新的内存映像替换当前的映像，并从入口开始执行。\n3. 进程申请动态内存 进程开始运行后，如果需要申请更多内存，就会向内核发出内存申请请求。然后内核在可用内存中分出一块相应大小的内存块，并将起始地址返回给进程。\n","date":"2023-07-08T00:00:00Z","permalink":"https://zuoco.github.io/p/%E8%BF%9B%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98/","title":"进程中使用的内存"},{"content":"TCP可靠性可以总结为 6 个方面：\n1. 数据分片与序列号\nTCP将应用层的数据流分割成适合网络传输的报文段（Segment），每个报文段包含一个序列号（Sequence Number），标识该段数据在整体数据流中的位置。\n乱序重组： 即使数据包通过不同路径到达，接收方也能根据序列号重新排序。 去重： 通过序列号识别并丢弃重复的数据包。 重排： 接收方按序号重组数据后，按顺序交给应用层。 1 2 3 4 5 6 7 8 示例： 发送方发送数据 \u0026#34;Hello\u0026#34;，初始序列号为100，每个字符占1字节： 报文1：Seq=100, Data=\u0026#34;H\u0026#34; 报文2：Seq=101, Data=\u0026#34;e\u0026#34; ... 接收方返回确认号（ACK=105），表示期望下一个字节是105。 2. 确认应答（ACK）机制\n接收方每收到一个报文段，会返回一个确认报文（ACK），其中包含期望接收的下一个字节的序列号。\n确保发送方知道哪些数据已被正确接收。 发送方仅需重传未被确认的数据段。 1 2 3 示例： 若接收方收到 Seq=100 的数据，会返回 ACK=101，表示“已收到100，期待101”。 3. 超时重传 见《报文重传》。\n4. 滑动窗口\n流量控制 接收方通过TCP头部的**窗口字段（Window Size）**告知发送方当前可接收的数据量（接收窗口 rwnd）。 发送方根据 rwnd 动态调整发送速率，避免接收方缓冲区溢出。\n拥塞控制 根据一定的算法控制发送速率。 发送方根据网络状态动态调整发送窗口（拥塞窗口 cwnd），避免网络过载。\n实际发送窗口大小为 min(rwnd, cwnd)。\n5. 校验和\n数据完整性校验：TCP头部和数据部分均包含校验和，接收方通过校验和验证数据是否在传输中损坏。 丢弃损坏数据：若校验失败，接收方丢弃该报文段，并等待发送方重传。 6. 连接管理 也就是三次握手与四次挥手。\n","date":"2023-06-23T00:00:00Z","permalink":"https://zuoco.github.io/p/tcp%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84/","title":"TCP是如何保证可靠性的"},{"content":" 1. TCP拥塞控制 1.1. 发生拥塞前的拥塞控制 1.2. 发生拥塞后的拥塞控制 2. 其他 1. TCP拥塞控制 动态调整数据传输速率，在网络好的时候提高发送速度，在网络不好的时候减少发送速度，这样在最大化利用带宽的同时并保证数据传输的可靠性，这就是拥塞控制的业务了，在拥塞控制的标准文档中（RFC 5681）中描述了拥塞控制的4个部分，或者说4种状态，拥塞控制就是4种状态之间的切换。\n慢启动 拥塞避免 快速重传 快速恢复 但是要注意了，标准没有规定4种状态都要实现，取决于具体的算法设计思路，Linux内核中提供了多种实现，我当前的系统是Ubuntu24.4，使用的是：cubic算法。\n1 2 zci@GEM:~$ cat /proc/sys/net/ipv4/tcp_congestion_control cubic 这个拥塞控制，到底控制了个啥呀，这时候要先提3个概念：RWDN（接收通告窗口）、CWDN（拥塞窗口）、SWDN（Send Window，发送窗口）。\nRWND：接收方通过这个东西告诉发送方，它的TCP接收缓存区还能容纳多少字节的数据。 CWND：拥塞窗口，拥塞控制直接控制这个变量。 SWND：RWND、CWND两者的最小值。 拥塞控制这一套最终的目的就是控制SWDN的大小。从另一个角度理解SWND，TCP采用发送应答机制，每一个发送出去的数据报文，都要接收对方的应答报文，以此来确保对方确实收到了数据。如果说每次发送数据后，非要等到收到对方的应答报文后才能发送下一个报文，那网络就卡到爆炸了。所以TCP协议允许一次性发送多个报文，这个一次性发送的数据量就是发送窗口。现在我们知道了RWND来自于接收方，那么CWND如何获取呢？ 在一些书籍上，将SWND计算分为两种情况： 1.发生拥塞前的拥塞控制 2.发生拥塞后的拥塞控制。\n1.1. 发生拥塞前的拥塞控制 预防性拥塞避免，这种情况下的拥塞控制有两个阶段：慢启动、拥塞避免。在TCP连接建立后，CWND会有一个初始值，内核版本不同这个初始值可能也会不同。慢启动处于刚开始发送数据的时候，实际上它也不慢，以指数形式增加CWDN，每收到一个ACK就增加一次。但是会受到慢启动门限的限制，当CWND大于慢启动门限时就会进入拥塞避免状态，而拥塞避免采用线性的方法增加CWND。\n1.2. 发生拥塞后的拥塞控制 首先我们要判断拥塞是否发生了，有两种判断依据：传输超时、接收到重复的确认报文段。两种情况使用的拥塞控制方法也不同。\n1. 传输超时，或者收到重复报文段发生在超时后面：这种情况使用的还是“慢启动-\u0026gt;拥塞避免”的套路。如果判断是这种情况，就会将CWDN设置为一个小于慢启动门限制的值，如此一来，拥塞控制就会进入慢启动状态了。\n2. 接收到重复ACK报文： 使用快速重传-\u0026gt;快速恢复的套路。检测到这种事件，会立即重传丢失的报文，也就是快速重传，重传后会将CWND设置为一个大于慢启动门限的值，之后每次收到一个重复的ACK，SWND就增加一个SMSS，直到收到新数据的ACK时，将CWND设置为慢启动门限，这就是快速恢复，之后就会进入拥塞避免状态了。\n2. 其他 SMSS： TCP报文段数据部分的最大长度。\n","date":"2023-06-19T00:00:00Z","permalink":"https://zuoco.github.io/p/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/","title":"TCP拥塞控制"},{"content":" 1. 什么时候重传报文 2. 超时重传策略 3. 快速重传策略 3.1. SACK 4. 其他 1. 什么时候重传报文 重传报文有两种情况：超时重传、快速重传：\n超时重传: 发送端的TCP模块每发送一个报文后都会启用定时器，如果在定时时间内没有收到应答报文，就会重传该报文，这就是超时重传，至于没有收到应答报文，可能是报文丢失，也可能是应答报文丢失。 快速重传： 发送端连续收到3个重复报文段，就认为丢包了，触发快速重传，重传丢失的报文段。 2. 超时重传策略 TCP模块会为每一个发送出去但没有收到ACK的报文维护一个定时器，报文发送出去就会启用超时定时器，超时时间（RTO）的设置当然是依据RTT的，但不是简单的RTO=RTT，毕竟RTT也是动态变化的，具体的计算方法我也没有细究。当前只需要知道，当到达超时时间但没有收到ACK，就会重传报文并重置定时器，以Linux为例，有两个重要的内核参数：\n1 2 3 4 5 6 root@GEM:/proc/sys/net/ipv4# pwd /proc/sys/net/ipv4 root@GEM:/proc/sys/net/ipv4# root@GEM:/proc/sys/net/ipv4# ls tcp_retries tcp_retries1 tcp_retries2 # 两个文件决定了重传的次数 root@GEM:/proc/sys/net/ipv4# tcp_retries1 最少重传次数，默认为3，在IP层接管之前的最少重传次数。\ntcp_retries2 最多重传次数，默认为15，连接放弃前的最多重传次数。\n至于多次重传时RTO的设置，Linux采用的是加倍的方式，即每次重传都将RTO增大一倍，当然在算法层面，这个“加倍”不是“x2”，只是最终的结果表现为倍增。不管底层算法是如何设计的，这个超时重传的时间跨度还是比较长的，这肯定不行啊，所以就有了快速重传。\n3. 快速重传策略 从发送端角度看，连续收到3个重复的ACK，就认为这个报文丢了，例如一个报文的编号为10～101，发送端连续收到3个101-ACK，就认为“seq 10:101”这个报文丢失了，此时就会触发快速重传，这玩意儿也是拥塞控制的一部分。\n缺点:\n当发生丢包事件时就说明网络可能是拥塞了，这种情况下可能就不是丢一个包这么简单了，如果丢了好几个包呢，那此时的重传工作就复杂了，那几个包需要重传呢？这时就需要SACK（Selective Acknowledgment）机制了，在TCP协议头的头部选项中开启此功能。\n3.1. SACK 在【TCP协议与报文结构】篇章中我们提到了SACK，也就是kind=5的头部选项，接收端通过该选项来携带丢失的数据信息，告诉发送端哪些数据丢失了，这样发送端只需要重传丢失的数据即可。但是这个“丢失信息”的格式是什么样的呢，这时候就要注意了，TCP是流式协议，我们不能应该从报文的角度来看，它是数据流，“丢包”就是数据流中的一段或者多段缺失了，此时我只需要标识出那几段缺失了，也就是缺失数据段的起始位置和结束位置，SACK类型的头部选项格式如下： 从图中可以看出，SACK选项的info部分，包含了一段或者多段记录，每段记录包含8个字节，这8个字节又分为两部分：\n缺失段左边缘： 左边4个字节记录了起始序号，就是缺失数据段的第一个字节的序号。 缺失段右边缘： 右边4个字节记录了结束序号，就是缺失数据段的最后一个字节的序号的下一个序号。 4. 其他 RTT，它表示包的往返时间，就是数据发送时刻到接收到ACK时刻的差值。\n","date":"2023-06-18T00:00:00Z","permalink":"https://zuoco.github.io/p/tcp%E6%8A%A5%E6%96%87%E9%87%8D%E4%BC%A0/","title":"TCP报文重传"},{"content":" 1. tcpdump 抓取Tcp报文 2. 分析抓包结果 2.1. 三次握手 2.2. 数据发送与响应 2.3. 四次挥手 3. 其他 1. tcpdump 抓取Tcp报文 1. 现在有一对tcp程序\n服务端地址：192.168.52.39：8080。 客户端地址：192.168.52.67。 连接建立后客户端发送数据： ABCDEF。 服务器收到数据后，发送数据：ABCDEFGH。 客户端断开连接。 2. tcpdump抓取Tcp报文\n1 sudo tcpdump -i any \u0026#39;tcp and host 192.168.52.39 and host 192.168.52.67\u0026#39; -vvn 3. 抓取结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 tcpdump: data link type LINUX_SLL2 tcpdump: listening on any, link-type LINUX_SLL2 (Linux cooked v2), snapshot length 262144 bytes 13:29:25.569020 wlp4s0 In IP (tos 0x0, ttl 64, id 57345, offset 0, flags [DF], proto TCP (6), length 60) 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [S], cksum 0x3356 (correct), seq 3666571938, win 64240, options [mss 1460,sackOK,TS val 1128528921 ecr 0,nop,wscale 7], length 0 13:29:25.569049 wlp4s0 Out IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60) 192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [S.], cksum 0xe9e9 (incorrect -\u0026gt; 0x92ef), seq 394631164, ack 3666571939, win 65160, options [mss 1460,sackOK,TS val 4121163671 ecr 1128528921,nop,wscale 7], length 0 13:29:25.571512 wlp4s0 In IP (tos 0x0, ttl 64, id 57346, offset 0, flags [DF], proto TCP (6), length 52) 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [.], cksum 0xbe4a (correct), seq 1, ack 1, win 502, options [nop,nop,TS val 1128528925 ecr 4121163671], length 0 13:29:25.571513 wlp4s0 In IP (tos 0x0, ttl 64, id 57347, offset 0, flags [DF], proto TCP (6), length 58) 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [P.], cksum 0xfa78 (correct), seq 1:7, ack 1, win 502, options [nop,nop,TS val 1128528925 ecr 4121163671], length 6: HTTP 13:29:25.571554 wlp4s0 Out IP (tos 0x0, ttl 64, id 45420, offset 0, flags [DF], proto TCP (6), length 52) 192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [.], cksum 0xe9e1 (incorrect -\u0026gt; 0xbe39), seq 1, ack 7, win 510, options [nop,nop,TS val 4121163674 ecr 1128528925], length 0 13:29:25.571658 wlp4s0 Out IP (tos 0x0, ttl 64, id 45421, offset 0, flags [DF], proto TCP (6), length 60) 192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [P.], cksum 0xe9e9 (incorrect -\u0026gt; 0xb520), seq 1:9, ack 7, win 510, options [nop,nop,TS val 4121163674 ecr 1128528925], length 8: HTTP 13:29:25.577532 wlp4s0 In IP (tos 0x0, ttl 64, id 57348, offset 0, flags [DF], proto TCP (6), length 52) 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [.], cksum 0xbe35 (correct), seq 7, ack 9, win 502, options [nop,nop,TS val 1128528929 ecr 4121163674], length 0 13:29:30.578167 wlp4s0 In IP (tos 0x0, ttl 64, id 57349, offset 0, flags [DF], proto TCP (6), length 52) 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [F.], cksum 0xaaab (correct), seq 7, ack 9, win 502, options [nop,nop,TS val 1128533930 ecr 4121163674], length 0 13:29:30.618353 wlp4s0 Out IP (tos 0x0, ttl 64, id 45422, offset 0, flags [DF], proto TCP (6), length 52) 192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [.], cksum 0xe9e1 (incorrect -\u0026gt; 0x96ec), seq 9, ack 8, win 510, options [nop,nop,TS val 4121168721 ecr 1128533930], length 0 13:29:35.571866 wlp4s0 Out IP (tos 0x0, ttl 64, id 45423, offset 0, flags [DF], proto TCP (6), length 52) 192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [F.], cksum 0xe9e1 (incorrect -\u0026gt; 0x8392), seq 9, ack 8, win 510, options [nop,nop,TS val 4121173674 ecr 1128533930], length 0 13:29:35.576375 wlp4s0 In IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 52) 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [.], cksum 0x7014 (correct), seq 8, ack 10, win 502, options [nop,nop,TS val 1128538928 ecr 4121173674], length 0 ^C 11 packets captured 11 packets received by filter 0 packets dropped by kernel 2. 分析抓包结果 1 2 3 11 packets captured 11 packets received by filter 0 packets dropped by kernel 三次握手、四次挥手、一个数据报文，一个数据报文的ACK，算起来9个报文，下面分析一下抓取的报文。\n2.1. 三次握手 1 2 3 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [S], cksum 0x3356 (correct), seq 3666571938, win 64240, options [mss 1460,sackOK,TS val 1128528921 ecr 0,nop,wscale 7], length 0 192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [S.], cksum 0xe9e9 (incorrect -\u0026gt; 0x92ef), seq 394631164, ack 3666571939, win 65160, options [mss 1460,sackOK,TS val 4121163671 ecr 1128528921,nop,wscale 7], length 0 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [.], cksum 0xbe4a (correct), seq 1, ack 1, win 502, options [nop,nop,TS val 1128528925 ecr 4121163671], length 0 简单分析一下：\n192.168.52.67.33762 \u0026gt; 192.168.52.39.8080： 报文的源地址 \u0026gt; 目标地址 Flags [S]: 同步报文段，由客户端发送，表示请求建立一个连接。\nFlags [S.]: 同步+确认报文段，由服务端发送，做了两件事： 1.同步,表示同意客户端的连接请求。2.响应客户端的SYN报文。 Flags [.]: 确认报文。\nseq 3666571938: 客户端ISN值，就是报文序号的初始值。\nseq 394631164: 服务端ISN值，两个传输方向分别有各自的ISN值。 ack 3666571939: 确认序号，表示服务端已经收到客户端的报文,确认序号就是接收到的报文的seq+1。 options [mss 1460,sackOK,TS val 1128528921 ecr 0,nop,wscale 7]: TCP头部结构中的头部选项。\nlength 0: 报文的数据长度，SYN 包不携带数据，所以为0。\n以上就是“三次握手”。\n2.2. 数据发送与响应 1 2 3 4 5 6 7 8 # 客户端发送数据包，6个字节 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [P.], cksum 0xfa78 (correct), seq 1:7, ack 1, win 502, options [nop,nop,TS val 1128528925 ecr 4121163671], length 6: HTTP # 服务器收到数据包，发送确认消息 192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [.], cksum 0xe9e1 (incorrect -\u0026gt; 0xbe39), seq 1, ack 7, win 510, options [nop,nop,TS val 4121163674 ecr 1128528925], length 0 # 服务器发送数据包，8个字节 192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [P.], cksum 0xe9e9 (incorrect -\u0026gt; 0xb520), seq 1:9, ack 7, win 510, options [nop,nop,TS val 4121163674 ecr 1128528925], length 8: HTTP # 客户端接收数据包，发送确认消息 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [.], cksum 0xbe35 (correct), seq 7, ack 9, win 502, options [nop,nop,TS val 1128528929 ecr 4121163674], length 0 seq 1:7: 数据报文的起始序列号为1（方向： 客户端-\u0026gt;服务器），报文所携带的字节编号是[1, 7)。 length 6: HTTP: 报文携带的数据长度为6字节，识别为HTTP报文是因为使用了8080端口。 seq 1:9: 数据报文的起始序列号为1（方向： 服务器-\u0026gt;客户端）。 ack 7: 确认序号为7，就是对于来自客户端的数据报文进行响应，表示收到了这个报文，ack=seq+length+1，也就是下一个报文的起始序列号。\n注意：\ntcp虽然也是一个一个报文发送的，但是tcp是流式协议，序列号用于表示一次网络通信过程中，所传输数据的每一个字节的编号，注意了是字节的编号，在一次通信活动中，数据字节的编号是连续的。因为是流式协议，对于应用层协议来说，tcp数据流是没有边界的，会发生所谓的粘包问题，这需要应用层去解决，毕竟tcp只负责数据的可靠传输，而不管数据从哪里开始，从到哪里结束。\nACK报文：\n例如一个报文，字节编号是[100, 201)，这个报文的应答报文的ACK就是201，也就是下一个报文的数据字节的起始编号，通过这个方式告诉发送端，这个报文已经收到，可以开始发送下一个报文了。\n2.3. 四次挥手 1 2 3 4 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [F.], cksum 0xaaab (correct), seq 7, ack 9, win 502, options [nop,nop,TS val 1128533930 ecr 4121163674], length 0 192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [.], cksum 0xe9e1 (incorrect -\u0026gt; 0x96ec), seq 9, ack 8, win 510, options [nop,nop,TS val 4121168721 ecr 1128533930], length 0 192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [F.], cksum 0xe9e1 (incorrect -\u0026gt; 0x8392), seq 9, ack 8, win 510, options [nop,nop,TS val 4121173674 ecr 1128533930], length 0 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [.], cksum 0x7014 (correct), seq 8, ack 10, win 502, options [nop,nop,TS val 1128538928 ecr 4121173674], length 0 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [F.]: 客户端发送了关闭连接的请求。\n192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [.]: 服务器收到客户端请求后，发送了确认包。 192.168.52.39.8080 \u0026gt; 192.168.52.67.33762: Flags [F.]: 服务器发送了关闭连接的请求。 192.168.52.67.33762 \u0026gt; 192.168.52.39.8080: Flags [.]: 客户端收到服务器的关闭请求后，发送了确认包。\n双方都要发送关闭连接请求，保证双方都没有数据要发送。有些机器挥手只有3个报文，因为中间的两个报文合并在一起了。\n3. 其他 1 2 3 # 时间戳 网络接口 数据方向 IP报文相关信息 13:29:25.571513 wlp4s0 In IP (tos 0x0, ttl 64, id 57347, offset 0, flags [DF], proto TCP (6), length 58) 13:29:25.571554 wlp4s0 Out IP (tos 0x0, ttl 64, id 45420, offset 0, flags [DF], proto TCP (6), length 52) ","date":"2023-06-17T00:00:00Z","permalink":"https://zuoco.github.io/p/tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","title":"TCP的“三次握手”与“四次挥手”"},{"content":" 1. TCP报文结构 1.1. 固定头部 1.2. 头部选项 1.2.1. 流控相关 1.2.2. 报文重传相关 1.2.3. 时间戳相关 2. 协议特性 1. TCP报文结构 TCP头部由固定头部（20字节）、头部选项（最长40字节）组成。\n1.1. 固定头部 字段 功能 32位序列号 一次TCP传输活动中，一个传输方向上，字节流中的每一个字节的编号。 32位确认号 用于响应对方，告诉对方收到了数据，等于序列号+1 4位头部长度 记录了TCP头部的长度有几个32Bit 6个标志位 16位窗口大小 接收通告窗口（RWND），于流量控制，拥塞控制中会用到 16位校验和 发送端填充，接收端进行校验 16位紧急指针 16位标志位\n标志位 功能 URG 紧急指针是否有效 ACK 确认号是否有效 PSH 接收方应该尽快将这个报文交给应用层，这是一个数据报文 RST 连接复位请求 SYN 同步序号，用于建立连接，这是一个连接请求报文 FIN 这是一个close报文 1.2. 头部选项 头部选项长度可变，最长40个字节，主要是用于在建立连接时，协商一些参数，确定开启那些功能。头部选项结构如下（3部分）：\n一个Byte 一个Byte n个Byte kind length info 选项类型 头部选项的长度（包括kind和length） 选项的具体信息 1.2.1. 流控相关 流控相关的选项，只在建立TCP连接时才会发送，即SYN包中。 kind=2, length=4, info占用2个Byte 用于指定最大报文段长度，此时，TCP连接初始化时，双方以此协商最大报文段长度（MSS），一般这个MSS=MTU-40，这个“40”包含20字节的tcp头部和20字节的ip头部。这样一来，报文就不超过MTU的长度，也就是减少了ip分片。\nkind=3, length=3，info占用1个Byte\n窗口扩大因子，info记录移位数，用于设置RWND，例如，固定头部中的16位窗口大小是S，头部选项给的窗口扩大因子是T，那么这一次TCP连接的实际RWND大小就是: $S \\times 2^T，T \\in [0,14]$，也就是S左移T位。但是有一个问题，人家RWND最大才16bBit(65536)，这样一搞，不就超了吗？实际上内核是允许的，并可以通过修改 /proc/sys/net/ipv4/tcp_window_scaling 的值来启用或者关闭窗口扩大因子选项。\n1.2.2. 报文重传相关 kind=4, length=2, 无info\n该选项在建立连接时使用，用于启用SACK选项（Selective Acknowledgment，选择性确认）。TCP协议有丢包重传的功能，假如现在发送方发送了A、B、C、D、E、F，6个报文，结果从B开始丢包了，此时TCP模块会重传A之后的所有报文，开启SACK功能后，TCP模块只重传那些丢失的报文，至于如何确认那些报文丢失了，就是kind=5选项的工作了。\nkind=5, ..., ...\n这个是SACK实际工作选项，也就是丢包时会用到，这个选项会发送丢包信息（info），发送方通过这些信息确认丢失的报文。\n参考 【报文重传】 篇章理解该选项。\n1.2.3. 时间戳相关 kind=8, length=10, info占用8个Byte\n这个是时间戳选项，计算RTT时间，主要服务于流控。\n2. 协议特性 传输层协议有两个，TCP和UDP，我们都知道UDP是数据报协议，用于广播/多播场景， 而TCP协议是面向连接、字节流、可靠传输的传输层协议，同时，每每提到TCP协议，都会提及用塞控制，对于这些关键特性后面会有单独的章节进行介绍：\n面向连接： 每一次的通讯都需要建立一对一的连接，然后才能进行数据传输，数据传输完成后结束连接。 字节流： 在发送端，应用层通过N次写操作，将数据放到TCP发送缓存区后，TCP模块会将发送缓存区中的数据封装成M个TCP报文发送出去，但是这个N和M没有联系，再说接收端接收到数据后，TCP模块会按照报文的序号将数据依次放入TCP的接收缓存区中，并通知应用程序读取数据，应用程序是一次性读取完成还是分为K次读取，完全是应用程序的设计需求，和N、M没有关系。也就是说，发送端写的次数和接收端读取的次数没有瓜葛，可以理解为TCP协议在传输数据时是没有边界的，这就是“字节流”的概念。 可靠传输： 为了保证可靠性，TCP做了3件事，采用发送应答机制、报文重传、报文重排。 用塞控制： 通过一定的算法设计控制发送报文的速度，以此提高网络带宽利用率，这也是TCP模块的重要职责之一。 ","date":"2023-06-16T00:00:00Z","permalink":"https://zuoco.github.io/p/tcp%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/","title":"TCP协议与报文结构"},{"content":"1. 用法 1 2 # 显示内存使用量最大的前10个进程 ps -eo pid,comm,%mem --sort -%mem | head -n 10 参数解释：\n-e：显示所有进程。 -o：自定义输出格式，指定需要显示的字段： pid(进程ID),comm(进程名),%mem(进程使用的内存百分比)。 --sort -%mem：按照内存使用百分比降序排序。 head -n 10：显示前10行。 ","date":"2023-06-13T00:00:00Z","permalink":"https://zuoco.github.io/p/ps%E5%91%BD%E4%BB%A4/","title":"ps命令"},{"content":" 1. 基本组成 2. 头文件 1. 基本组成 组成 用途 容器 一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。 算法 STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，\n这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 中，少部分位于头文件 中。 迭代器 在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。 函数对象 如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。 适配器 可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。 内存分配器 为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。 2. 头文件 13个标准库头文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iterator\u0026gt;\t#include \u0026lt;functional\u0026gt;\t#include \u0026lt;vector\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;list\u0026gt;\t#include \u0026lt;queue\u0026gt;\t#include \u0026lt;stack\u0026gt;\t#include \u0026lt;set\u0026gt; #include \u0026lt;map\u0026gt;\t#include \u0026lt;algorithm\u0026gt;\t#include \u0026lt;numeric\u0026gt;\t#include \u0026lt;memory\u0026gt; #include \u0026lt;utility\u0026gt; ","date":"2023-06-10T00:00:00Z","permalink":"https://zuoco.github.io/p/%E6%A0%87%E5%87%86%E5%BA%93%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/","title":"标准库基本组成"},{"content":" 1. std::lock_guard 2. std::unique_lock 2.1. 多种构造方式 2.2. 使用方法 2.3. 条件变量 3. std::scoped_lock 智能锁 用途 std::lock_guard 简化的互斥锁管理模板类 std::unique_lock 增强版的lock_guard，支持条件变量 std::scoped_lock 用于理多个互斥锁 1. std::lock_guard std::lock_guard 是一个用于简化互斥锁（std::mutex）管理的RAII类模板。它的核心目标是确保在作用域结束时自动释放互斥锁，从而避免手动调用 lock() 和 unlock() 可能导致的资源泄漏或死锁问题。\n主要特性包括：\n自动加锁/解锁： 在构造时自动锁定互斥锁，析构时自动解锁。 不可复制/不可移动： 禁止拷贝和移动操作，防止锁的意外传递或释放。 非递归性： 不支持递归锁定同一互斥锁，多次锁定会导致未定义行为。 异常安全性： 即使在临界区代码中抛出异常，锁也会被正确释放。 1 2 3 4 { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); // 构造时加锁 // 临界区代码 } // 析构时自动解锁 2. std::unique_lock std::unique_lock 是 C++11 标准引入的互斥锁管理工具，用于管理 std::mutex 的生命周期。比 std::lock_guard 更强大，提供了更多控制选项，例如延迟锁定、尝试锁定、手动解锁等。但是std::unique_lock 的灵活性以性能为代价，简单场景推荐使用 std::lock_guard。\n主要特性：\nRAII 机制： 自动加锁/解锁，在构造时自动获取锁，析构时自动释放锁，确保异常安全性。 手动控制：允许显式调用 lock() 和 unlock()，灵活控制锁的生命周期。 支持条件变量： 唯一支持条件变量（std::condition_variable）的锁类型，条件变量的 wait() 需要临时释放锁并重新获取。 支持移动语义（move），允许将锁的所有权转移到其他 std::unique_lock 对象。 2.1. 多种构造方式 std::unique_lock 提供了多种构造方式，通过不同的标签（tag）控制锁定行为：\nstd::defer_lock：延迟锁定（构造时不锁定互斥锁）。 std::try_to_lock：尝试锁定（构造时尝试获取锁，失败则不阻塞）。 std::adopt_lock：接管已锁定的互斥锁（适用于手动锁定后交给 unique_lock 管理）。 2.2. 使用方法 1. 基本使用\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; std::mutex mtx; void thread_func() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); // 构造时自动锁定 // 临界区代码 } // 析构时自动解锁 2. 延迟锁定\n1 2 3 4 5 6 std::mutex mtx; std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::defer_lock); // 构造时不锁定 // 执行其他操作 lock.lock(); // 手动锁定 // 临界区代码 lock.unlock(); // 手动解锁 3. 尝试锁定\n1 2 3 4 5 6 7 std::mutex mtx; std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::try_to_lock); if (lock.owns_lock()) { // 成功获取锁，执行临界区代码 } else { // 未获取锁，执行其他逻辑 } 4. 接管已锁定的互斥锁\n1 2 3 4 5 std::mutex mtx; mtx.lock(); // 手动锁定 std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::adopt_lock); // 接管已锁定的互斥锁 // 临界区代码 // 析构时自动解锁 5. 超时锁定\n1 2 3 4 5 6 7 8 std::mutex mtx; std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); if (lock.try_lock_for(std::chrono::seconds(1))) { // 最多等待1秒获取锁 // 临界区代码 } else { // 超时未获取锁 } 2.3. 条件变量 std::condition_variable，通过 wait()、notify_one() 和 notify_all() 实现线程间的协作。\nwait()：释放锁并等待唤醒，唤醒后会重新获取锁并检查条件，还有wait_for()、wait_until()等超时等待方法。 notify_one()：唤醒一个等待线程。 notify_all()：唤醒所有等待线程。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;queue\u0026gt; std::mutex mtx; std::condition_variable cv; std::queue\u0026lt;int\u0026gt; buffer; const int MAX_BUFFER_SIZE = 5; void producer() { for (int i = 0; i \u0026lt; 10; ++i) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); // 使用谓词防止虚假唤醒，被唤醒后会检查谓词，如果返回false会继续等待，如果返回true就获取锁并执行后续的代码（临界区）。 cv.wait(lock, [ ] { return buffer.size() \u0026lt; MAX_BUFFER_SIZE; }); buffer.push(i); std::cout \u0026lt;\u0026lt; \u0026#34;Produced: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; lock.unlock(); cv.notify_one(); // 通知消费者 } } void consumer() { for (int i = 0; i \u0026lt; 10; ++i) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); cv.wait(lock, [ ] { return !buffer.empty(); }); int value = buffer.front(); buffer.pop(); std::cout \u0026lt;\u0026lt; \u0026#34;Consumed: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; lock.unlock(); cv.notify_one(); // 通知生产者 } } int main() { std::thread prod(producer); std::thread cons(consumer); prod.join(); cons.join(); return 0; } 3. std::scoped_lock 在C++17中，std::scoped_lock 是一个用于管理多个互斥锁（std::mutex）的工具，它通过RAII机制确保锁的正确获取和释放。它的核心目标是简化多线程代码中对多个互斥锁的管理，避免死锁，并提高代码的异常安全性。\n多锁管理：支持同时锁定多个互斥锁，避免手动管理多锁时的复杂性。 死锁预防：内部按照互斥锁的地址顺序统一锁定，确保所有线程以相同的顺序获取锁，从而防止死锁。 不可复制/可移动：禁止拷贝操作，但支持移动语义（如作为函数返回值）。 1 2 3 4 { std::scoped_lock lock(mtx1, mtx2); // 构造时同时锁定两个互斥锁 // 临界区代码（安全地访问共享资源） } // 析构时自动解锁所有锁 与 std::unique_lock 不同，std::scoped_lock 不支持延迟锁定或尝试锁定（try_lock）。\n","date":"2023-06-04T00:00:00Z","permalink":"https://zuoco.github.io/p/lock_guardunique_lockscoped_lock/","title":"lock_guard、unique_lock、scoped_lock"},{"content":" 1. shared_ptr 1.1. 基本方法 1.2. 自定义删除器 1.3. make_shared 1.4. 对象数组 2. unique_ptr 2.1. make_unique 2.2. 基本方法 2.3. 自定义删除器 3. weake_ptr 3.1. 解决循环引用 3.2. 安全访问 std::shared_ptr 管理的对象 1. shared_ptr 共享智能指针，内部维护一块内存，允许多个shared_ptr对象共享这块内存。\n1 2 // Defined in header \u0026lt;memory\u0026gt; template\u0026lt; class T \u0026gt; class shared_ptr; shared_ptr对象内部包含两个指针： 指向资源的指针、指向控制块的指针，而控制块包含： 引用计数、弱引用计数（用于统计weak_ptr）、自定义删除器等等。\nshared_ptr就是通过引用计数来管理对象的生命周期，引用计数的操作是原子的，当引用计数为0时，对象会被自动销毁。\n使用 std::make_shared 时，资源与控制块会分配在同一块内存，减少内存碎片并提升缓存效率。\n1 2 3 4 5 6 7 8 9 10 // int* x = new int(10); std::shared_ptr\u0026lt;int\u0026gt; x(new int(10)); // 申请一块内存来初始化x，引用计数为 1 std::cout \u0026lt;\u0026lt; x.use_count() \u0026lt;\u0026lt; std::endl; // 输出1 { std::shared_ptr\u0026lt;int\u0026gt; y = x; // 这块内存的引用计数 +1 std::cout \u0026lt;\u0026lt; x.use_count() \u0026lt;\u0026lt; std::endl; // 输出2 } // 离开y的作用域，y被销毁，引用计数-1 std::cout \u0026lt;\u0026lt; x.use_count() \u0026lt;\u0026lt; std::endl; // 输出1 1.1. 基本方法 重载了*，所以可以用*x来获取x指向的元素。 提供了get()方法获取原始指针，但是要注意这个操作不会增加引用计数，所以不要用它来初始化另一个shared_ptr, 或者delete它，因为shared_ptr并不知道你干了什么，所以会导致多次delete。 提供了reset()方法，先将引用计数减1，然后判断是否为0，如果为0，就则释放管理的原始内存。 template\u0026lt; class Y \u0026gt; void reset( Y* ptr );，该方法先将引用计数减1，然后判断是否为0，如果为0，就释放管理的原始内存，并将ptr赋值给内部的指针。如果不为0，那就什么也不做。 1.2. 自定义删除器 1 2 3 // 构造函数 template\u0026lt; class Y, class Deleter \u0026gt; shared_ptr( Y* ptr, Deleter d ); 删除器是一个可调用对象（函数、Lambda 表达式、仿函数等），在最后一个 shared_ptr 被销毁时调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // 自定义删除器仿函数 struct FileDeleter { void operator()(FILE* file) const { if (file) fclose(file); std::cout \u0026lt;\u0026lt; \u0026#34;File closed via functor.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 创建 shared_ptr，绑定文件句柄和仿函数 std::shared_ptr\u0026lt;FILE\u0026gt; file(fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;), FileDeleter()); if (file) { std::cout \u0026lt;\u0026lt; \u0026#34;File opened successfully.\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 1.3. make_shared 1 2 std::shared_ptr\u0026lt;int\u0026gt; x(new int(10)); // 引用计数和int 10的内存分别位于两个地方。 auto y = std::make_shared\u0026lt;int\u0026gt;(10); // 引用计数和int 10的存储空间会尽挨得近一些，使得访问更快。 1.4. 对象数组 1 2 3 4 // C++ 17 std::shared_ptr\u0026lt;int[]\u0026gt; x(new int[10]); // C++20 auto y = std::make_shared\u0026lt;int[]\u0026gt;(10); 2. unique_ptr 独享智能指针，内部维护一块内存，同一时刻只允许一个unique_ptr拥有这块内存，unique_ptr不支持拷贝和赋值，只能移动。\n1 2 3 4 5 6 // Defined in header \u0026lt;memory\u0026gt; template\u0026lt;class T, class Deleter = std::default_delete\u0026lt;T\u0026gt;\u0026gt; class unique_ptr; template \u0026lt;class T, class Deleter\u0026gt; class unique_ptr\u0026lt;T[], Deleter\u0026gt;; 代码示例：\n1 2 3 std::unique_ptr\u0026lt;int\u0026gt; x(new int(10)); std::unique_ptr\u0026lt;int\u0026gt; y = x; // ✘ std::unique_ptr\u0026lt;int\u0026gt; z = std::move(x); // ✔ 在函数中返回unique_ptr，会使用移动语义（如果返回类型支持移动语义）。\n2.1. make_unique 1 auto x = std::make_unique\u0026lt;int\u0026gt;(10); 2.2. 基本方法 和shared_ptr一样，也有get、reset方法。\n2.3. 自定义删除器 这一点和shared_ptr不一样了，unique_ptr的模板参数是两个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 仿函数 struct FileDeleter { void operator()(FILE* fp) const { fclose(fp); } }; int main() { auto file = std::unique_ptr\u0026lt;FILE, FileDeleter\u0026gt;( fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;), FileDeleter{} ); // 使用 file... } 1 2 3 4 5 6 7 8 // Lambda int main() { auto file = std::unique_ptr\u0026lt;FILE, decltype([](FILE* fp) { fclose(fp); })\u0026gt;( fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;), [](FILE* fp) { fclose(fp); } ); // 使用 file... } 1 2 3 4 5 6 7 8 9 10 11 12 // 函数指针 void custom_deleter(FILE* fp) { fclose(fp); } int main() { auto file = std::unique_ptr\u0026lt;FILE, decltype(\u0026amp;custom_deleter)\u0026gt;( fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;r\u0026#34;), \u0026amp;custom_deleter ); // 使用 file... } 3. weake_ptr weake_ptr提供一种轻量级引用，不占用引用计数。shared_ptr在使用中可能会发生循环引用，此时可以使用weak_ptr来打破 std::shared_ptr 的所有权闭环。\n3.1. 解决循环引用 当两个对象通过 std::shared_ptr 相互持有对方时，引用计数永远不会归零，导致内存泄漏。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class B; // 前向声明 class A { public: std::shared_ptr\u0026lt;B\u0026gt; b_ptr; ~A() { std::cout \u0026lt;\u0026lt; \u0026#34;A destroyed\\n\u0026#34;; } }; class B { public: std::shared_ptr\u0026lt;A\u0026gt; a_ptr; ~B() { std::cout \u0026lt;\u0026lt; \u0026#34;B destroyed\\n\u0026#34;; } }; int main() { auto a = std::make_shared\u0026lt;A\u0026gt;(); auto b = std::make_shared\u0026lt;B\u0026gt;(); a-\u0026gt;b_ptr = b; b-\u0026gt;a_ptr = a; // 形成循环引用 a = nullptr; // 引用计数仍为 1，内存泄漏 b = nullptr; // 引用计数仍为 1，内存泄漏 return 0; } 解决方案：\n将其中一个 std::shared_ptr 替换为 std::weak_ptr，打破循环引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class B; // 前向声明 class A { public: std::shared_ptr\u0026lt;B\u0026gt; b_ptr; ~A() { std::cout \u0026lt;\u0026lt; \u0026#34;A destroyed\\n\u0026#34;; } }; class B { public: std::weak_ptr\u0026lt;A\u0026gt; a_ptr; // 使用 weak_ptr 避免循环引用 ~B() { std::cout \u0026lt;\u0026lt; \u0026#34;B destroyed\\n\u0026#34;; } }; int main() { auto a = std::make_shared\u0026lt;A\u0026gt;(); auto b = std::make_shared\u0026lt;B\u0026gt;(); a-\u0026gt;b_ptr = b; b-\u0026gt;a_ptr = a; // 不增加 a 的引用计数 a = nullptr; // a 的引用计数归零，对象被销毁 b = nullptr; // b 的引用计数归零，对象被销毁 return 0; } 3.2. 安全访问 std::shared_ptr 管理的对象 不要直接解引用 std::weak_ptr，必须通过 lock() 获取 std::shared_ptr，检查是否为空，不为空才能访问对象。\n1 2 3 4 5 6 7 8 std::shared_ptr\u0026lt;int\u0026gt; shared = std::make_shared\u0026lt;int\u0026gt;(42); std::weak_ptr\u0026lt;int\u0026gt; weak = shared; if (auto locked = weak.lock()) { std::cout \u0026lt;\u0026lt; *locked \u0026lt;\u0026lt; std::endl; // 对象存在时访问 } else { std::cout \u0026lt;\u0026lt; \u0026#34;Object has been destroyed\\n\u0026#34;; // 对象已销毁时处理 } ","date":"2023-06-03T00:00:00Z","permalink":"https://zuoco.github.io/p/shared_ptrunique_ptrweake_ptr/","title":"shared_ptr、unique_ptr、weake_ptr"},{"content":" 1. 可调用对象 2. bind 2.1. 使用方法 2.2. bind的问题 3. bind_front与bind_back 4. 其他 1. 可调用对象 很多算法可以通过可调用对象来提供自定义计算逻辑细节的能力，可调用对象可以是函数指针、函数对象(类)、bind、lambda表达式等。\n2. bind std::bind通过绑定的方式，生成一个调用包装器（call wrapper），将可调用对象与部分参数绑定，形成一个新的可调用对象。\n2.1. 使用方法 1. 使用案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool MyCompare(int x, int y) { return x \u0026gt; y; } int main() { using namespace std::placeholders; // 占位符定义在这里 auto x = std::bind(MyCompare, _1, 3); x(2); // MyCompare(2, 3) x(6); // MyCompare(6, 3) auto y = std::bind(MyCompare, _2, 3); y(\u0026#34;hello\u0026#34;, 7); // MyCompare(7, 3) } 代码解析：\n1 2 3 4 5 6 7 auto x = std::bind(MyCompare, _1, 3); // 将3绑定到MyCompare的参数y， “_1”是参数x的占位符。 // 返回一个新的可调用对象f。 // 但是要注意，占位符“_1”中的1指的是： “调用f()时，将f()中的第几个参数传给到MyCompare的参数x”， // 请看如下代码： auto y = std::bind(MyCompare, _2, 3); y(\u0026#34;hello\u0026#34;, 7); // MyCompare(7, 3), 将f(\u0026#34;hello\u0026#34;, 7)中的第二个参数传给到MyCompare的参数x。 我们来看一下bind的声明：\n1 2 3 4 5 6 7 8 // (since C++11) (constexpr since C++20) template\u0026lt; class F, class... Args \u0026gt; bind( F\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args ); template\u0026lt; class R, class F, class... Args \u0026gt; bind( F\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args ); 在创建可调用对象时，也就是在调用std::bind时，参数列表Args\u0026amp;\u0026amp;中的参数顺序（包括占位符）对应着函数f的形参顺序，不在于占位符是“_1“还是”_2”。 而当我们调用可调用对象时，传给可调用对象几个参数，第一个传给“_1”, 第二个传给“_2”，以此类推。\n也就是说，当我们调用可调用对象时，传入的参数中，有些参数是无效的，因为实际使用的是绑定的参数。调用可调用对象时，参数的使用和原函数是一样的，至于那个参数会被采用，这是在调用std::bind时，通过Args\u0026amp;\u0026amp;中的参数顺序以及占位符设计好的。\n2. 使用案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bool MyCompare(int x, int y) { return x \u0026gt; y; } bool MyAnd(bool x, bool y) { return x \u0026amp;\u0026amp; y; } int main() { using namespace std::placeholders; auto x = std::bind(MyCompare, _1, 3); auto y = std::bind(MyCompare, 6, _1); auto z = std::bind(MyAnd, x, y); z(4); // MyAnd(x(4, 3), y(6 ,4)) } 3. 使用案例：\n1 2 3 4 5 6 7 8 9 10 11 bool MyCompare(int x, int y) { return x \u0026gt; y; } int main() { using namespace std::placeholders; auto x = std::bind(MyCompare, _1, _1); // x 始终返回false x(6); } 2.2. bind的问题 调用std::bind时，传入的参数会被复制，这可能导致一些风险。\n1. 使用案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void MyFunc(int* x) { } auto fun() { int x; return std::bind(MyFunc, \u0026amp;x); // 在fun()返回时，x会被销毁 } int main() { auto f = fun(); // 当调用f时，绑定的参数已经失效了，甚至会导致内存错误。 } 若果有此类场景，可以使用智能指针来解决，在使用std::bind时，传入的参数应该是智能指针，保证参数有效。\n2. 使用案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void MyFunc(int\u0026amp; x) { ++x; } int main() { int x = 0; auto fun = std::bind(MyFunc, x); fun(); std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; // 输出为0， 因为std::bind，对于传入的参数采用了拷贝的方法， 压根不会改变x的值。 } 这种情况需要使用std::ref、std::cref来改变参数的绑定方式：\n1 auto fun = std::bind(MyFunc, std::ref(x)); 3. bind_front与bind_back std::bind_front, std::bind_back是C++20引入的新特性，用来给第一个参数绑定一个值，或者给最后一个参数绑定一个值。\n4. 其他 在使用bind时，绑定那些参数，调用可调用对象时，那些参数有效，参数是如何对应的，非常的绕，所以后来引入了lambda表达式。\n","date":"2023-05-29T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B-bind/","title":"可调用对象之 bind"},{"content":" 1. lambdab表达式组成部分 2. 参数捕获 3. lambda被编译器翻译成类 4. 参数捕获详解 4.1. 值捕获 4.2. 引用捕获 4.3. this捕获与*this捕获 4.4. 初始化捕获 5. 修饰符 5.1. mutalbe 5.2. constexpr和conxteval 5.3. 形参修饰 5.3.1. C++20 模板形参 5.3.2. const auto\u0026amp; 7. Lambda递归 1. lambdab表达式组成部分 Lambda表达式的格式为：\n1 2 [capture list](parameters) -\u0026gt; return type { }; // 捕获列表 ，函数参数， 返回值， 函数体 例如：\n1 2 3 4 5 6 7 #include \u0026lt;iostream\u0026gt; int main() { auto f = [](int a) -\u0026gt; int { return a \u0026gt; 6 \u0026amp;\u0026amp; a \u0026lt; 9 ; }; std::cout \u0026lt;\u0026lt; f(7) \u0026lt;\u0026lt; std::endl; } [capture list]: 参数捕获。 (parameters)： 形参。 -\u0026gt; return type： 返回类型，能够自动推导时，可以省略。 {}： 函数体，和普通函数一样。 2. 参数捕获 一个Lambda处于一个作用域内部，可以捕获该作用域中的局部变量，而对于静态变量，全局变量直接使用即可。对于局部变量的捕获可以分为以下集中情况：\n捕获类型 \u0026ndash; 值捕获 [x]: 捕获指定变量 [=]: 捕获所有变量 引用捕获 [\u0026amp;x]（显式捕获单个变量的引用） [\u0026amp;]（隐式捕获所有变量的引用） 混合捕获 [=, \u0026amp;x]：按值捕获所有变量，但x为引用 [\u0026amp;, =x]：按引用捕获所有变量，但x为值 [x, \u0026amp;y]: x使用值捕获，y使用引用捕获 捕获 this 指针 [this] 或 [*this] 在类成员函数中，捕获当前对象的 this 指针（[this]）或整个对象的副本（[*this]） 用于访问类的成员变量和成员函数 其他 \u0026hellip; 3. lambda被编译器翻译成类 上面的代码被翻译成类，并重载函数调用符()，也就是仿函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; int main() { class __lambda_5_12 { public: inline /*constexpr */ int operator()(int a) const { return static_cast\u0026lt;int\u0026gt;((a \u0026gt; 6) \u0026amp;\u0026amp; (a \u0026lt; 9)); } using retType_5_12 = auto (*)(int) -\u0026gt; int; inline constexpr operator retType_5_12 () const noexcept { return __invoke; }; private: static inline /*constexpr */ int __invoke(int a) { return __lambda_5_12{}.operator()(a); } public: // /*constexpr */ __lambda_5_12() = default; }; __lambda_5_12 f = __lambda_5_12{}; std::cout.operator\u0026lt;\u0026lt;(f.operator()(7)).operator\u0026lt;\u0026lt;(std::endl); return 0; } 从上面代码中可以看出，lambda表达式，会被翻译成一个类，捕获的变量用于在类的构造函数中初始化成员变量。并且该类还重载了函数调用运算符“（）”，重载函数的函数体就是lambda的函数体。\n4. 参数捕获详解 无论值捕获还是引用捕获，当使用全部捕获时，编译器生成的类只会捕获使用到的变量，这个比较智能。\n4.1. 值捕获 编译器在创建类的时候，会定义相应的类成员变量，然后在构造lambda对象时，使用捕获的变量初始化类成员变量。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; int main() { int x = 10; auto f = [x](int a) -\u0026gt; int { return a \u0026gt; 6 \u0026amp;\u0026amp; a \u0026lt; 9 ; }; std::cout \u0026lt;\u0026lt; f(7) \u0026lt;\u0026lt; std::endl; } 上面代码翻译成：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; int main() { int x = 10; class __lambda_7_12 { public: inline /*constexpr */ int operator()(int a) const { return static_cast\u0026lt;int\u0026gt;((a \u0026gt; 6) \u0026amp;\u0026amp; (a \u0026lt; 9)); } private: int x; public: // 构造函数 __lambda_7_12(int \u0026amp; _x): x{_x} {} }; // 调用构造函数时，会将x的值复制给类的成员变量x中。 __lambda_7_12 f = __lambda_7_12{x}; std::cout.operator\u0026lt;\u0026lt;(f.operator()(7)).operator\u0026lt;\u0026lt;(std::endl); return 0; } 4.2. 引用捕获 如果使用引用捕获，类中会定义对应的引用类型的成员变量，这种情况下，lambda对于自身成员变量的操作会影响对应的外部变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; int main() { int x = 10; auto f = [\u0026amp;x](int a) { ++x; return a \u0026gt; x ; }; std::cout \u0026lt;\u0026lt; f(7) \u0026lt;\u0026lt; std::endl; } 翻译后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; int main() { int x = 10; class __lambda_7_12 { public: inline /*constexpr */ bool operator()(int a) const { ++x; return a \u0026gt; x; } private: int \u0026amp; x; // 引用捕获，就会定义对应的引用类型的成员变量 public: __lambda_7_12(int \u0026amp; _x): x{_x} {} }; __lambda_7_12 f = __lambda_7_12{x}; std::cout.operator\u0026lt;\u0026lt;(f.operator()(7)).operator\u0026lt;\u0026lt;(std::endl); return 0; } 4.3. this捕获与*this捕获 请看下面案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class str { auto fun() { int a = 10; auto f = [a, x] () { return a \u0026gt; x; // 这样捕获是错的。 }; }; int x; }; 上面的案例中，虽然说fun和x都是类成员，但是fun中的lambda是不能直接捕获x的，fun中的局部变量倒是可以捕获。正确做法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class str { auto fun() { int a = 10; auto f = [a, this] () { return a \u0026gt; x; }; }; int x; }; 翻译后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class str { inline void fun() { int a = 10; class __lambda_6_16 { public: inline /*constexpr */ bool operator()() const { return a \u0026gt; __this-\u0026gt;x; // 通过 Str* 类型的成员变量访问对象的成员 } private: int a; str * __this; // 一个Str* 类型的成员变量 public: __lambda_6_16(str * _this, int \u0026amp; _a) : __this{_this} , a{_a} {} }; __lambda_6_16 f = __lambda_6_16{this, a}; } int x; }; 但是，要注意this指向的对象的生命周期，这个很危险，Lambda表示式很多时候用来创建一个可调用对象，但是并不是马上就要调用，所以要确保调用的时候参数都是有效的，所以C++17中提供了*this捕获。\n4.4. 初始化捕获 Demo1：\n1 2 3 4 5 6 int main() { int x = 10; auto f = [y = x] (int a) { return a \u0026gt; y; }; // 类似于值捕获 std::cout \u0026lt;\u0026lt; f(11) \u0026lt;\u0026lt; std::endl; } Demo2：\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { std::string str = \u0026#34;Are You OK!\u0026#34;; auto f = [ss = std::move(str)] () { std::cout \u0026lt;\u0026lt; ss \u0026lt;\u0026lt; std::endl; }; std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; // str为空 f(); // 打印 Are You OK! } Demo3:\n1 2 3 4 5 6 7 8 9 10 int main() { int x = 10; int y = 10; auto f = [z = y + x] (int a) { return a \u0026gt; z; // 其实也是值捕获 }; } 5. 修饰符 5.1. mutalbe 1 2 3 4 5 6 7 8 9 ##include \u0026lt;iostream\u0026gt; int main() { int x = 10; auto f = [x](int a) { return a \u0026gt; 6 \u0026amp;\u0026amp; a \u0026lt; 9 ; }; std::cout \u0026lt;\u0026lt; f(7) \u0026lt;\u0026lt; std::endl; } 翻译后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ##include \u0026lt;iostream\u0026gt; int main() { int x = 10; class __lambda_7_12 { public: inline /*constexpr */ int operator()(int a) const // 这个const是修饰this的 { return static_cast\u0026lt;int\u0026gt;((a \u0026gt; 6) \u0026amp;\u0026amp; (a \u0026lt; 9)); } private: int x; public: __lambda_7_12(int \u0026amp; _x) : x{_x} {} }; __lambda_7_12 f = __lambda_7_12{x}; std::cout.operator\u0026lt;\u0026lt;(f.operator()(7)).operator\u0026lt;\u0026lt;(std::endl); return 0; } 上面的代码中，重载函数的this是const的，所以重载函数中不能修改成员变量，使用mutalbe修饰符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ##include \u0026lt;iostream\u0026gt; int main() { int x = 10; auto f = [x](int a) mutable { return a \u0026gt; 6 \u0026amp;\u0026amp; a \u0026lt; 9 ; }; std::cout \u0026lt;\u0026lt; f(7) \u0026lt;\u0026lt; std::endl; } 翻译后:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ##include \u0026lt;iostream\u0026gt; int main() { int x = 10; class __lambda_7_12 { public: inline /*constexpr */ bool operator()(int a) // 没有const了 { return (a \u0026gt; 6) \u0026amp;\u0026amp; (a \u0026lt; 9); } private: int x; public: __lambda_7_12(int \u0026amp; _x) : x{_x} {} }; __lambda_7_12 f = __lambda_7_12{x}; std::cout.operator\u0026lt;\u0026lt;(f.operator()(7)).operator\u0026lt;\u0026lt;(std::endl); return 0; } 5.2. constexpr和conxteval constexpr： 声明Lambda可以在编译期执行。 conxteval： 声明表达式不会抛出异常， 这个特性在《 C++异常 》篇章讲解。 5.3. 形参修饰 5.3.1. C++20 模板形参 C++20引入，没用过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ##include \u0026lt;iostream\u0026gt; int main() { int x = 10; auto f = [x]\u0026lt;typename T\u0026gt;(T a) // 模板形参 { return a \u0026gt; 6 \u0026amp;\u0026amp; a \u0026lt; 9 ; }; std::cout \u0026lt;\u0026lt; f(7) \u0026lt;\u0026lt; std::endl; } 翻译后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ##include \u0026lt;iostream\u0026gt; int main() { int x = 10; class __lambda_7_12 { public: template\u0026lt;typename T\u0026gt; // 函数模板 inline /*constexpr */ auto operator()(T a) const { return (a \u0026gt; 6) \u0026amp;\u0026amp; (a \u0026lt; 9); } ##ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; inline /*constexpr */ bool operator()\u0026lt;int\u0026gt;(int a) const { return (a \u0026gt; 6) \u0026amp;\u0026amp; (a \u0026lt; 9); } ##endif private: int x; public: __lambda_7_12(int \u0026amp; _x) : x{_x} {} }; __lambda_7_12 f = __lambda_7_12{x}; std::cout.operator\u0026lt;\u0026lt;(f.operator()(7)).operator\u0026lt;\u0026lt;(std::endl); return 0; } 5.3.2. const auto\u0026amp; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ##include \u0026lt;map\u0026gt; ##inclide \u0026lt;iostream\u0026gt; ##include \u0026lt;functional\u0026gt; int main() { std::map\u0026lt;int, int\u0026gt; m{6, 8} auto lam = [](const auto\u0026amp; x) // 等效于： const std::pair\u0026lt;const int, int\u0026gt;\u0026amp; x { return p.first + p.second; } std::cout \u0026lt;\u0026lt; lam(*m.begin()) \u0026lt;\u0026lt; std::endl; } 我们看翻译后的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ##include \u0026lt;map\u0026gt; ##include \u0026lt;iostream\u0026gt; ##include \u0026lt;functional\u0026gt; int main() { std::map\u0026lt;int, int, std::less\u0026lt;int\u0026gt;, std::allocator\u0026lt;std::pair\u0026lt;const int, int\u0026gt; \u0026gt; \u0026gt; m = std::map\u0026lt;int, int, std::less\u0026lt;int\u0026gt;, std::allocator\u0026lt;std::pair\u0026lt;const int, int\u0026gt; \u0026gt; \u0026gt;{std::initializer_list\u0026lt;std::pair\u0026lt;const int, int\u0026gt; \u0026gt;{std::pair\u0026lt;const int, int\u0026gt;{6, 8}}, std::less\u0026lt;int\u0026gt;(), std::allocator\u0026lt;std::pair\u0026lt;const int, int\u0026gt; \u0026gt;()}; class __lambda_8_15 { public: template\u0026lt;class type_parameter_0_0\u0026gt; inline /*constexpr */ auto operator()(const type_parameter_0_0 \u0026amp; x) const { return x.first + x.second; } ##ifdef INSIGHTS_USE_TEMPLATE // 重点 template\u0026lt;\u0026gt; // 此处形参的形参为 const std::pair\u0026lt;const int, int\u0026gt;\u0026amp; 是由const auto\u0026amp; 推导出来的 inline /*constexpr */ int operator()\u0026lt;std::pair\u0026lt;const int, int\u0026gt; \u0026gt;(const std::pair\u0026lt;const int, int\u0026gt; \u0026amp; x) const { return x.first + x.second; } ##endif private: template\u0026lt;class type_parameter_0_0\u0026gt; static inline /*constexpr */ auto __invoke(const type_parameter_0_0 \u0026amp; x) { return __lambda_8_15{}.operator()\u0026lt;type_parameter_0_0\u0026gt;(x); } }; __lambda_8_15 lam = __lambda_8_15{}; std::cout.operator\u0026lt;\u0026lt;(lam.operator()(m.begin().operator*())).operator\u0026lt;\u0026lt;(std::endl); return 0; } ##- 1. lambdab表达式组成部分\n1. lambdab表达式组成部分 2. 参数捕获 3. lambda被编译器翻译成类 4. 参数捕获详解 4.1. 值捕获 4.2. 引用捕获 4.3. this捕获与*this捕获 4.4. 初始化捕获 5. 修饰符 5.1. mutalbe 5.2. constexpr和conxteval 5.3. 形参修饰 5.3.1. C++20 模板形参 5.3.2. const auto\u0026amp; 7. Lambda递归 涉及到函数重载时 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 auto fun(int x) { return ++x; } auto fun(int x) { return ++x; } int main() { auto lam = [](auto x) { return fun(x); }; } 根据参数类型来选择对应的函数，内部实现为模板函数。\n7. Lambda递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ##include \u0026lt;iostream\u0026gt; int main() { // 使用了两层Lambda auto factorial = [](int n) { // 递归Lambda, 在执行前就定义好 auto fact = [](int n, const auto\u0026amp; f) -\u0026gt; int { return n \u0026gt; 1 ? n * f(n - 1, f) : 1; }; // 开始递归，此时fact的类型已经定义 return fact(n, fact); }; std::cout \u0026lt;\u0026lt; factorial(5) \u0026lt;\u0026lt; std::endl; } ","date":"2023-05-28T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B-lambda/","title":"可调用对象之 Lambda"},{"content":" 1. 泛型算法 2. 典型泛型算法 2.1. 读算法 1. 2.1.1. accumulate 2. 2.1.2. find 3. 2.1.3. count 4. 2.1.4. distance 2.2. 写算法 1. 2.2.1. fill 2. 2.2.2. fill_n 3. 2.2.3. transform 4. 2.2.4. copy 2.3. 排序算法 1. 2.3.1. sort 2. 2.3.2. unique 3. 其他相关 3.1. 并行计算 3.2. 谓词 1. 泛型算法 C++标准库提供了一些泛型算法，使用时需要包含对应的头文件：\n1 2 3 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;ranges\u0026gt; 1. 为什么引入泛型算法而不是使用方法？\n一方面，内建的类型是不支持方法的，如int、char、数组、指针等，这些类型不支持方法，只能使用运算符。另一方面，一些方法的计算逻辑是相似的，没有必要重复定义。\n2. 泛型算法的简单举例？ 泛型算法使用模板来实现，例如std::sort， 这是最常用的泛型算法：\n1 2 3 // (constexpr since C++20) template\u0026lt; class RandomIt \u0026gt; void sort( RandomIt first, RandomIt last ); 编译器在编译期间会进行模板特化，这就是泛型算法实现的泛型的背后逻辑。\n3. 迭代器与泛型算法？\n迭代器是算法与数据结构之间的桥梁，泛型算法使用迭代器访问元素。\n4. 泛型算法与类方法名称相同时？\n此时使用类方法，因为，为了实现“泛型”带来了性能损失，例如： std::find和std::map::find，std::find是线性查找，而std::map::find是二分查找。\n2. 典型泛型算法 2.1. 读算法 给定迭代区间，读取其中的元素并进行计算： accumulate/find/count。\n2.1.1. accumulate 对元素进行累加计算，需要包含头文件#include \u0026lt;numeric\u0026gt;，函数声明如下：\n1 2 3 4 5 6 7 // (constexpr since C++20) template\u0026lt; class InputIt, class T \u0026gt; T accumulate( InputIt first, InputIt last, T init ); // (constexpr since C++20) template\u0026lt; class InputIt, class T, class BinaryOp \u0026gt; T accumulate( InputIt first, InputIt last, T init, BinaryOp op ); first, last: 输入区间的起始迭代器，[first, last)。 init: 进行累加的初始值。 op: 二元操作函数对象。它定义了如何将当前累积结果 (result) 与序列中的当前元素 (*first) 组合成新的累积结果。\n如果字符串类型使用accumulate，那就是拼接字符串。 2.1.2. find 包含头文件#include \u0026lt;algorithm\u0026gt;，函数声明如下：\n1 2 3 // (constexpr since C++20) (until C++26) template\u0026lt; class InputIt, class T \u0026gt; InputIt find( InputIt first, InputIt last, const T\u0026amp; value ); first, last: 输入区间的迭代器，[first, last) 。 value: 要查找的值。 返回值： 返回一个迭代器，指向第一个等于value的元素，如果没有元素等于value，则返回last。 2.1.3. count 包含头文件#include \u0026lt;algorithm\u0026gt;，函数声明如下：\n1 2 3 4 5 6 7 8 9 10 11 // 计算范围 [first, last) 中等于 value 的元素数量。 // (constexpr 自 C++20 起) (直到 C++26)。 template\u0026lt; class InputIt, class T \u0026gt; typename std::iterator_traits\u0026lt;InputIt\u0026gt;::difference_type count( InputIt first, InputIt last, const T\u0026amp; value ); // 计算范围 [first, last) 中满足谓词条件 p 的元素数量。 // (constexpr 自 C++20 起) template\u0026lt; class InputIt, class UnaryPred \u0026gt; typename std::iterator_traits\u0026lt;InputIt\u0026gt;::difference_type count_if( InputIt first, InputIt last, UnaryPred p ); first、last: 输入迭代器范围，在输入迭代器范围 [first, last) 中查找满足条件的元素的数量。 value: 统计范围 [first, last) 内等于 value 的元素数量。 p: 一元谓词，用于判断元素是否满足条件（true：满足条件，false：不满足条件）。 关于UnaryPred（一元谓词）： 一个接受单个参数并返回布尔值的可调用对象，可以是Lambda、函数指针、函数对象。 返回值： typename std::iterator_traits::difference_type，其中typename告诉编译器这是类型而不是值，difference_type：表示两个迭代器间距离的有符号整数类型。 2.1.4. distance 求取迭代器间距离。\n1 2 3 template\u0026lt; class InputIt \u0026gt; typename std::iterator_traits\u0026lt;InputIt\u0026gt;::difference_type distance( InputIt first, InputIt last ); 实现案例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;class It\u0026gt; constexpr typename std::iterator_traits\u0026lt;It\u0026gt;::difference_type distance(It first, It last) { using category = typename std::iterator_traits\u0026lt;It\u0026gt;::iterator_category; static_assert(std::is_base_of_v\u0026lt;std::input_iterator_tag, category\u0026gt;); // 根据迭代器类型进行优化 if constexpr (std::is_base_of_v\u0026lt;std::random_access_iterator_tag, category\u0026gt;) return last - first; //随机访问迭代器支持迭代器距离 else { // 普通迭代器，只能通过++first来计算距离 typename std::iterator_traits\u0026lt;It\u0026gt;::difference_type result = 0; while (first != last) { ++first; ++result; } return result; } } 2.2. 写算法 给定迭代区间，将元素写入到指定位置: fill/fill_n/transpose/copy。\n2.2.1. fill 1 2 3 // (constexpr since C++20) (un til C++26) template\u0026lt; class ForwardIt, class T \u0026gt; void fill( ForwardIt first, ForwardIt last, const T\u0026amp; value ); 将范围 [first, last) 内的所有元素赋值为指定的 value。 2.2.2. fill_n 1 2 3 // (constexpr since C++20) (until C++26) template\u0026lt; class OutputIt, class Size, class T \u0026gt; OutputIt fill_n( OutputIt first, Size count, const T\u0026amp; value ); 将指定值 value 赋给从 first 开始的连续 count 个元素。 2.2.3. transform 1 2 3 // (constexpr since C++20) template\u0026lt; class InputIt, class OutputIt, class UnaryOp \u0026gt; OutputIt transform( InputIt first1, InputIt last1, OutputIt d_first, UnaryOp unary_op ); 将输入范围 [first1, last1) 中的每个元素应用一元操作 unary_op，并将结果写入从 d_first 开始的输出范围。 1 2 3 // (constexpr since C++20) template\u0026lt; class InputIt1, class InputIt2, class OutputIt, class BinaryOp \u0026gt; OutputIt transform( InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOp binary_op ); 将两个输入范围 [first1, last1) 和 [first2, first2 + N)（其中 N = last1 - first1) 中的对应元素应用二元操作 binary_op，并将结果写入从 d_first 开始的输出范围。 这个版本的transform用在什么地方呢？例如向量/矩阵的运算，如下： 1 2 3 4 // 向量相加 std::vector\u0026lt;double\u0026gt; a{1.0, 2.0, 3.0}, b{4.0, 5.0, 6.0}; std::vector\u0026lt;double\u0026gt; result(a.size()); std::transform(a.begin(), a.end(), b.begin(), result.begin(), [](double x, double y) { return x + y; }); 2.2.4. copy 1 2 template\u0026lt; class InputIt, class OutputIt \u0026gt; OutputIt copy( InputIt first, InputIt last, OutputIt d_first ); 将范围 [first, last) 内的元素按顺序复制到从 d_first 开始的目标位置 2.3. 排序算法 2.3.1. sort 1 2 3 template\u0026lt; class RandomIt \u0026gt; void sort( RandomIt first, RandomIt last ); 对范围 [first, last) 内的元素进行升序排序（默认使用 operator\u0026lt;）。 1 2 template\u0026lt; class RandomIt, class Compare \u0026gt; void sort( RandomIt first, RandomIt last, Compare comp ); 对范围 [first, last) 内的元素进行升序排序（使用 comp 比较）。 Compare类型： 比较函数，签名形式如下： 1 2 bool cmp(const Type1\u0026amp; a, const Type2\u0026amp; b); // a \u0026lt; b 时返回true。 2.3.2. unique 1 2 3 4 5 6 7 // (constexpr since C++20) template\u0026lt; class ForwardIt \u0026gt; ForwardIt unique( ForwardIt first, ForwardIt last ); // (constexpr since C++20) template\u0026lt; class ForwardIt, class BinaryPred \u0026gt; ForwardIt unique( ForwardIt first, ForwardIt last, BinaryPred p ); 在范围[first， last）中，如果有多个重复且连续的元素，就保留第一个，删除其他几个重复的元素。 unique操作后，容器有效数据范围缩小，返回一个迭代器，指向新的END，但是注意了，容器本身大小不变，可以理解容器范围为： [first, new_end),[new_end, last)。 3. 其他相关 3.1. 并行计算 在C++标准库中，每个函数除了上面列举的重载类型，还是存在其他重载类型，如：\n1 2 3 4 5 6 template\u0026lt; class RandomIt \u0026gt; void sort( RandomIt first, RandomIt last ); // ExecutionPolicy template\u0026lt; class ExecutionPolicy, class RandomIt \u0026gt; void sort( ExecutionPolicy\u0026amp;\u0026amp; policy, RandomIt first, RandomIt last ); 函数声明中的参数为涉及到 ExecutionPolicy 类型用于指定算法执行策略的类型，它允许开发者控制算法是顺序执行还是并行执行。通过传递不同的策略对象，可以控制算法的执行模式（如顺序、并行或向量化），这在处理大规模数据时可以显著提升性能。\nC++ 标准定义了多种执行策略，每种都有对应的全局对象：\n策略类型 全局对象 版本 描述 std::execution::sequenced_policy std::execution::seq C++17 顺序执行（无并行） std::execution::parallel_policy std::execution::par C++17 并行执行（多线程） std::execution::parallel_unsequenced_policy std::execution::par_unseq C++17 并行+向量化执行（多线程+SIMD） std::execution::unsequenced_policy std::execution::unseq C++20 向量化执行（单线程 SIMD） 食用方法：\n1 2 3 4 std::sort(std::execution::seq, first, last); std::sort(std::execution::par, first, last); std::sort(std::execution::par_unseq, first, last); std::sort(std::execution::unseq, first, last); 不同的计算任务对于这几个策略的效率不同，例如排序算法，多线程比单线程有较大提升，但是使用SIMD就没有什么提升了。 Single Instruction, Multiple Data（单指令多数据流），现代CPU具有多PU单元，可以同时计算多条数据流，适用于向量、矩阵运算。\n3.2. 谓词 谓词，一种可调用对象：\n返回bool类型的函数对象。 函数接受一个参数，称为一元谓词。 函数接受两个参数，称为二元谓词。 一般使用lambda表达式来定义谓词。 ","date":"2023-05-27T00:00:00Z","permalink":"https://zuoco.github.io/p/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/","title":"泛型算法"},{"content":" 1. 什么是容器 2. 容器分类 2.1. 顺序容器 2.2. 关联容器 2.2.1. 有序关联容器 2.2.2. 无序关联容器 2.3. 容器适配器 2.4. 其他特殊容器 3. 容器的访问与遍历 3.1. 容器迭代器 3.2. 常用迭代器 3.3. 迭代器分类 3.4. 不同容器支持的迭代器类型 1. 什么是容器 C++容器是标准模板库（STL）的核心组件，本质上是预定义的、类型安全的\u0026quot;数据盒子\u0026quot;。它们以模板类的形式提供了一套即插即用的数据结构（如动态数组、链表、树等），通过自动管理内存和提供通用操作接口（增删查改），简化了数据集合的存储与处理流程。\n2. 容器分类 C++容器分类及常用容器如下：\n2.1. 顺序容器 顺序容器中的顺序两个字儿指的是元素插入序列的顺序，和元素的值没有关系。\nvector：动态数组，变长数组，容量不够时会自动扩容，在尾部增加或删除元素的效率最高（O(1) 常数阶），在其它位置插入或删除元素效率较差（O(n) 线性阶）。 deque：双端队列，和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶。 list：双向链表，可以在序列的任意位置高效地增加或删除元素（O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为链表这种东西必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。 forward_list：单向链表，以单链表的形式组织元素，内部的元素只能从第一个元素开始访问，比链表容器快、更节省内存。 array：基于数组，大小固定。 2.2. 关联容器 分为有序和无序两种，分配基于红黑树和哈希表实现。\n2.2.1. 有序关联容器 底层为红黑树，，排序容器中的元素是按序插入的（默认按键的升序排列），所以有序关联容器在查找时具有非常好的性能。\nset：唯一键集合 map：键值对映射 multiset：允许重复键的集合 multimap：允许重复键的映射 2.2.2. 无序关联容器 底层为哈希表，和有序关联容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。\nunordered_set：哈希集合 unordered_map：哈希映射 unordered_multiset：允许重复键的哈希集合 unordered_multimap：允许重复键的哈希映射 2.3. 容器适配器 封装基础容器来提供特定的功能。\nstack：后进先出（LIFO）栈 queue：先进先出（FIFO）队列 priority_queue：优先级队列（默认最大堆） 2.4. 其他特殊容器 string（常作为独立容器使用） 3. 容器的访问与遍历 3.1. 容器迭代器 使用迭代器访问或便利 容器中的元素，指定容器中的一段区间，用于遍历容器中的元素。STL 标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。\n3.2. 常用迭代器 下面展示容器的常见成员函数，这些成员函数返回一个特定的迭代器。\n1 2 begin() end() 1 2 rbegin() rend() # 指向第一个元素的前一个位置， 因为容器是头闭尾开的区间, 也就是`[begin, end)`。 1 cbegin() 1 2 crbegin() crend() 3.3. 迭代器分类 可以理解为对于指针的封装，常用的迭代器可以分为分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。其中输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。\n前向迭代器（forward iterator）\n支持的操作： ++、*（可以被复制或赋值）、使用 == 和 != 运算符进行比较。此外，两个前向迭代器可以互相赋值。\n双向迭代器（bidirectional iterator）\n支持的操作： 前向迭代器的全部功能，以及--。\n随机访问迭代器（random access iterator）\n随机访问迭代器具有双向迭代器的全部功能。除此之外，还支持随机访问操作p[i]、+或者-一个整数、两个随机访问迭代器相减。\n3.4. 不同容器支持的迭代器类型 容器 迭代器类型 array 随机访问迭代器 vector 随机访问迭代器 deque 随机访问迭代器 list 双向迭代器 set / multiset 双向迭代器 map / multimap 双向迭代器 forward_list 前向迭代器 unordered_map / unordered_multimap 前向迭代器 unordered_set / unordered_multiset 前向迭代器 stack 不支持迭代器 queue 不支持迭代器 不是所有的容器都支持迭代器，支持迭代器的容器称为range。容器适配器 stack 和 queue 就没有迭代器，但是它们包含有一些成员函数，可以用来对元素进行访问。\n","date":"2023-05-20T00:00:00Z","permalink":"https://zuoco.github.io/p/stl%E5%AE%B9%E5%99%A8-%E6%80%BB%E7%BB%93/","title":"STL容器 — 总结"},{"content":" 1. 迭代器分类 2. 常规迭代器 2.1. 输入迭代器 InputIt 2.2. 输出迭代器 OutputIt 2.3. 前向迭代器 ForwardIt 2.4. 双向迭代器 BidirIt 2.5. 随机访问迭代器 RandomIt 3. 特殊迭代器 3.1. 插入迭代器 3.1.1. back_insert_iterator 3.1.2. front_insert_iterator 3.1.3. insert_iterator 3.1.4. 为什么要引入插入“迭代器” 3.2. 流迭代器 3.2.1. istream_iterator 3.2.2. ostream_iterator 3.2.3. 流迭代器的开始与结束位置 3.3. 反向迭代器 3.4. 移动迭代器 4. 迭代器哨兵的概念 1. 迭代器分类 输入迭代器 ： 可读，可递增，典型应用为find算法。 输出迭代器 ： 可写，可递增，典型用应用为copy算法。 前向迭代器 ： 可读，可写，可递增，典型应用为算法如replace。 双向迭代器 ： 可读，可写，可递增，可递减，典型应用为reverse算法。 随机访问迭代器 ： 可读，可写，可递增一个整数(随机跳跃)，下标访问，迭代器距离，典型应用为sort算法。 泛型算法可以根据迭代器类型的不同引入相应的优化。\n不管是哪一个类型，根源上，都是从同一个抽象基类型派生出来的。\n2. 常规迭代器 2.1. 输入迭代器 InputIt 以std::find为例：\n1 2 template\u0026lt; class InputIt, class T \u0026gt; InputIt find( InputIt first, InputIt last, const T\u0026amp; value ); 实现逻辑如下：\n1 2 3 4 5 6 7 8 9 template\u0026lt;class InputIt, class T = typename std::iterator_traits\u0026lt;InputIt\u0026gt;::value_type\u0026gt; constexpr InputIt find(InputIt first, InputIt last, const T\u0026amp; value) { for (; first != last; ++first) if (*first == value) // 只是访问，不改变 return first; return last; } 2.2. 输出迭代器 OutputIt 以std::copy为例：\n1 2 3 template\u0026lt; class InputIt, class OutputIt \u0026gt; OutputIt copy( InputIt first, InputIt last, OutputIt d_first ); 实现逻辑如下：\n1 2 3 4 5 6 7 8 template\u0026lt;class InputIt, class OutputIt\u0026gt; OutputIt copy(InputIt first, InputIt last, OutputIt d_first) { for (; first != last; (void)++first, (void)++d_first) *d_first = *first; // 可以改变迭代器指向的对象的值 return d_first; } 2.3. 前向迭代器 ForwardIt 1 2 3 template\u0026lt; class ForwardIt, class T \u0026gt; void replace( ForwardIt first, ForwardIt last, const T\u0026amp; old_value, const T\u0026amp; new_value ); 实现案例如下：\n1 2 3 4 5 6 7 8 9 template\u0026lt;class ForwardIt, class T = typename std::iterator_traits\u0026lt;ForwardIt\u0026gt;::value_type\u0026gt; void replace(ForwardIt first, ForwardIt last, const T\u0026amp; old_value, const T\u0026amp; new_value) { // 前向迭代器支持 “++” 操作 for (; first != last; ++first) if (*first == old_value) *first = new_value; } 2.4. 双向迭代器 BidirIt 1 2 template\u0026lt; class BidirIt \u0026gt; void reverse( BidirIt first, BidirIt last ); 实现案例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template\u0026lt;class BidirIt\u0026gt; constexpr // since C++20 void reverse(BidirIt first, BidirIt last) { // 翻转[frist, last)区间的元素。 // 双向迭代器支持 “++”和“--”操作。 using iter_cat = typename std::iterator_traits\u0026lt;BidirIt\u0026gt;::iterator_category; // 进行条件编译 if constexpr (std::is_base_of_v\u0026lt;std::random_access_iterator_tag, iter_cat\u0026gt;) // 判断iter_cat是否继承自std::random_access_iterator_tag { if (first == last) return; for (--last; first \u0026lt; last; (void)++first, --last) std::iter_swap(first, last); } else while (first != last \u0026amp;\u0026amp; first != --last) std::iter_swap(first++, last); } 上面代码涉及到std::random_access_iterator_tag类型，这里简单提一下，是 C++ 中用于标识随机访问迭代器的结构体，如果iter_cat是否继承自std::random_access_iterator_tag返回true,那么iter_cat就属于随机访问迭代器类型，随机访问迭代器支持“\u0026lt;”、“\u0026gt;”操作，算法根据迭代器类型不同来优化实现。\n2.5. 随机访问迭代器 RandomIt 随机访问迭代器支持的特性最多，可读，可写，可递增一个整数(随机跳跃)，下标访问，迭代器距离，支持\u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;=，但是不支持==。\n1 2 template\u0026lt; class RandomIt \u0026gt; void sort( RandomIt first, RandomIt last ); 排序算法实现路线较多，不同的实现路线要求不同的访问元素的方式，所以就选用了随机访问迭代器。\n3. 特殊迭代器 插入迭代器 ： insert_iterator、back_insert_iterator、front_insert_iterator。 流迭代器 ： istream_iterator、ostream_iterator。 反向迭代器 ： reverse_iterator。 移动迭代器 ： move_iterator。 3.1. 插入迭代器 insert_iterator、back_insert_iterator、front_insert_iterator是标准库提供的3个类模板。\n3.1.1. back_insert_iterator 1 2 template\u0026lt; class Container \u0026gt; class back_insert_iterator; 构成函数：\n1 constexpr explicit back_insert_iterator( Container\u0026amp; c ); // (since C++20) 使用容器来初始化back_insert_iterator迭代器，所以这个迭代器对象与一个容器关联，使用该迭代器的“=”运算符可以将元素插入到容器的尾部。使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;deque\u0026gt; int main() { std::deque\u0026lt;int\u0026gt; q; std::back_insert_iterator\u0026lt;std::deque\u0026lt;int\u0026gt;\u0026gt; it(q); for(int i = 0; i \u0026lt; 10; i++) it = i; // 将元素插入到容器的尾部, q.push_back(i); for (auto\u0026amp; elem : q) std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; v; std::fill_n(std::back_inserter_iterator(v), 10, 3); for (auto\u0026amp; elem : v) std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } // 输出： std::back_inserter_iterator也可以使用std::back_inserter替换，其实现逻辑如下：\n1 2 3 4 5 template\u0026lt;class Container\u0026gt; std::back_insert_iterator\u0026lt;Container\u0026gt; back_inserter(Container\u0026amp; c) { return std::back_insert_iterator\u0026lt;Container\u0026gt;(c); // 返回一个back_insert_iterator迭代器 } 3.1.2. front_insert_iterator 和back_insert_iterator类似， 容器必须支持push_front操作。当然C++也提供了std::front_insert操作来简化使用。\n3.1.3. insert_iterator 更加一般化的插入迭代器。\n1 2 template\u0026lt; class Container \u0026gt; class insert_iterator; 构造函数：\n1 constexpr insert_iterator( Container\u0026amp; c, ranges::iterator_t\u0026lt;Container\u0026gt; i ); 这个insert_iterator在构造的时候需要一个容器和容器的迭代器，每一次使用“=”操作，实际上是调用容器的insert方法，每次插入操作都会调用容器的 insert 方法，在 i 所指向的位置插入元素（插入到i前面）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; v{1, 2, 3, 4, 5}; std::list\u0026lt;int\u0026gt; l{-1, -2, -3}; std::copy(v.begin(), v.end(), // may be simplified with std::inserter std::insert_iterator\u0026lt;std::list\u0026lt;int\u0026gt;\u0026gt;(l, std::next(l.begin()))); for (int n : l) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 这个insert_iterator也是有简化操作的：\n1 2 3 4 // 返回一个insert_iterator迭代器。 template\u0026lt; class Container \u0026gt; constexpr std::insert_iterator\u0026lt;Container\u0026gt; inserter( Container\u0026amp; c, ranges::iterator_t\u0026lt;Container\u0026gt; i ); 3.1.4. 为什么要引入插入“迭代器” 对容器进行写操作，我们必须保证目标容器有足够大的空间，如果不能够确保，那么就可以使用插入迭代器，通过push_back/push_front操作将元素插入到容器中，即使容器空间不够，也可以完成写操作。很显然，一个容器要想使用插入迭代器， 就必须支持push_back()/push_front方法。\n3.2. 流迭代器 3.2.1. istream_iterator 1 2 3 4 5 template\u0026lt; class T, class CharT = char, class Traits = std::char_traits\u0026lt;CharT\u0026gt;, class Distance = std::ptrdiff_t \u0026gt; class istream_iterator; 构造函数：\n1 2 3 constexpr istream_iterator(); istream_iterator( istream_type\u0026amp; stream ); istream_iterator( const istream_iterator\u0026amp; other ) = default; 除了参数T，其他带都有默认值。使用案例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;sstream\u0026gt; int main() { std::istringstream iss(\u0026#34;1 2 3 4 5\u0026#34;); std::istream_iterator\u0026lt;int\u0026gt; is(iss); //使用构造函数istream_iterator( istream_type\u0026amp; stream ); std::cout \u0026lt;\u0026lt; *is \u0026lt;\u0026lt; std::endl; ++is; std::cout \u0026lt;\u0026lt; *is \u0026lt;\u0026lt; std::endl; // 输出： // 1 // 2 } 3.2.2. ostream_iterator 1 2 3 4 template\u0026lt; class T, class CharT = char, class Traits = std::char_traits\u0026lt;CharT\u0026gt; \u0026gt; class ostream_iterator; 构造函数：\n1 2 ostream_iterator( ostream_type\u0026amp; stream, const CharT* delim ); // delim 间隔符 ostream_iterator( ostream_type\u0026amp; stream ); // 使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;numeric\u0026gt; int main() { std::ostream_iterator\u0026lt;char\u0026gt; oo{std::cout}; // 关联到 std::cout std::ostream_iterator\u0026lt;int\u0026gt; i1{std::cout, \u0026#34;, \u0026#34;}; std::fill_n(i1, 5, -1); // -1, -1, -1, -1, -1, *oo++ = \u0026#39;\\n\u0026#39;; std::ostream_iterator\u0026lt;double\u0026gt; i2{std::cout, \u0026#34;; \u0026#34;}; *i2++ = 3.14; *i2++ = 2.71; *oo++ = \u0026#39;\\n\u0026#39;; // 输出： // -1, -1, -1, -1, -1, // 3.14; 2.71; } 3.2.3. 流迭代器的开始与结束位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;sstream\u0026gt; int main() { std::istringstream stream(\u0026#34;1 2 3 4 5\u0026#34;); std::copy( std::istream_iterator\u0026lt;int\u0026gt;(stream), std::istream_iterator\u0026lt;int\u0026gt;(), std::ostream_iterator\u0026lt;int\u0026gt;(std::cout, \u0026#34; \u0026#34;) ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;sstream\u0026gt; int main() { std::istringstream iss(\u0026#34;1 2 3 4 5\u0026#34;); std::istream_iterator\u0026lt;int\u0026gt; x(iss); // 相当于开始位置 std::istream_iterator\u0026lt;int\u0026gt; y{}; // 相当于结束位置 std::cout \u0026lt;\u0026lt; *is \u0026lt;\u0026lt; std::endl; for (; x != y; ++x) { std::cout \u0026lt;\u0026lt; *x \u0026lt;\u0026lt; std::endl; } } 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;sstream\u0026gt; int main() { std::istringstream iss(\u0026#34;1 2 3 4 5\u0026#34;); std::istream_iterator\u0026lt;int\u0026gt; x(iss); std::istream_iterator\u0026lt;int\u0026gt; y{}; int res=std::accumulate(x, y, 0); std::cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; std::endl; } 3.3. 反向迭代器 就是rbegin和rend。\n从图中可以看到，迭代器区间是一个左闭右开区间，所以尾迭代器指向的是最后一个元素的下一个位置。\n3.4. 移动迭代器 1 2 template\u0026lt; class Iter \u0026gt; class move_iterator; 使用案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;ranges\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;string_view\u0026gt; #include \u0026lt;vector\u0026gt; void print(const std::string_view rem, const auto\u0026amp; v) { std::cout \u0026lt;\u0026lt; rem; for (const auto\u0026amp; s : v) std::cout \u0026lt;\u0026lt; std::quoted(s) \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }; int main() { std::vector\u0026lt;std::string\u0026gt; v{\u0026#34;this\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;an\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;example\u0026#34;}; print(\u0026#34;Old contents of the vector: \u0026#34;, v); std::string concat; for (auto begin = std::make_move_iterator(v.begin()), end = std::make_move_iterator(v.end()); begin != end; ++begin) { std::string temp{*begin}; // moves the contents of *begin to temp concat += temp; } // Starting from C++17, which introduced class template argument deduction, // the constructor of std::move_iterator can be used directly: // std::string concat = std::accumulate(std::move_iterator(v.begin()), // std::move_iterator(v.end()), // std::string()); print(\u0026#34;New contents of the vector: \u0026#34;, v); print(\u0026#34;Concatenated as string: \u0026#34;, std::ranges::single_view(concat)); } 输出：\n1 2 3 Old contents of the vector: \u0026#34;this\u0026#34; \u0026#34;_\u0026#34; \u0026#34;is\u0026#34; \u0026#34;_\u0026#34; \u0026#34;an\u0026#34; \u0026#34;_\u0026#34; \u0026#34;example\u0026#34; New contents of the vector: \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; Concatenated as string: \u0026#34;this_is_an_example\u0026#34; 移动迭代器的主要作用是移动迭代器所迭代的元素，也就是说我们通过移动迭代器读取元素后，该元素的值就会被移动走了(std::move)，再次访问就是空的，请看如下代码：\n1 2 3 4 5 6 7 int main() { std::string str = \u0026#34;this is an example\u0026#34;; auto y = std::move(str); std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; // x置为空 std::cout \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; // y正常输出: this is an example } 4. 迭代器哨兵的概念 对于一个迭代器区间: first,last，first不断++，直到first == last，我们就认为到达迭代器结尾了，那么last就是一个哨兵，first和哨兵不一定是一个类型，但是一定能够进行“==”运算。\n","date":"2023-05-20T00:00:00Z","permalink":"https://zuoco.github.io/p/%E8%BF%AD%E4%BB%A3%E5%99%A8/","title":"迭代器"},{"content":" 1. boot 2. usr/src 3. /usr/lib/modules 1. boot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 zci@GEM:/boot$ ls -lah 总计 187M -rw-r--r-- 1 root root 286K 6月 26 20:36 config-6.11.0-29-generic # 安装内核时自动生成，记录对应内核版本的编译配置，包含内核编译时的选项（如启用的硬件驱动、模块支持等），用于调试或重新编译内核模块。 -rw-r--r-- 1 root root 290K 7月 7 22:27 config-6.14.0-24-generic drwxr-xr-x 4 root root 4.0K 1月 1 1970 efi # 启动分区挂载位置，存放 UEFI 系统所需的引导文件。包含 grubx64.efi 等 UEFI 启动管理器文件。 drwxr-xr-x 5 root root 4.0K 7月 18 11:17 grub # 存放 GRUB（GRand Unified Bootloader）的配置文件和模块。 lrwxrwxrwx 1 root root 28 7月 18 11:16 initrd.img -\u0026gt; initrd.img-6.14.0-24-generic # 临时根文件系统，用于加载启动时需要的驱动和工具，在挂载真实根文件系统前，加载必要的模块（如 RAID、LVM、加密驱动）。。 -rw-r--r-- 1 root root 69M 7月 14 11:09 initrd.img-6.11.0-29-generic -rw-r--r-- 1 root root 70M 7月 18 11:19 initrd.img-6.14.0-24-generic lrwxrwxrwx 1 root root 28 7月 18 11:16 initrd.img.old -\u0026gt; initrd.img-6.11.0-29-generic -rw-r--r-- 1 root root 140K 4月 9 2024 memtest86+ia32.bin # 内存测试工具，用于检测硬件故障。 -rw-r--r-- 1 root root 141K 4月 9 2024 memtest86+ia32.efi -rw-r--r-- 1 root root 145K 4月 9 2024 memtest86+x64.bin -rw-r--r-- 1 root root 146K 4月 9 2024 memtest86+x64.efi -rw------- 1 root root 9.1M 6月 26 20:36 System.map-6.11.0-29-generic # 内核符号表，用于调试和分析内核问题，。 -rw------- 1 root root 8.8M 7月 7 22:27 System.map-6.14.0-24-generic lrwxrwxrwx 1 root root 25 7月 18 11:16 vmlinuz -\u0026gt; vmlinuz-6.14.0-24-generic # 压缩后的 Linux 内核镜像，系统启动时加载到内存并运行的核心程序，负责初始化硬件、挂载根文件系统并启动用户空间进程。 -rw------- 1 root root 15M 6月 26 20:39 vmlinuz-6.11.0-29-generic -rw------- 1 root root 15M 7月 7 22:32 vmlinuz-6.14.0-24-generic lrwxrwxrwx 1 root root 25 7月 18 11:16 vmlinuz.old -\u0026gt; vmlinuz-6.11.0-29-generic 2. usr/src 1 2 3 4 5 6 7 8 /usr/src ├── linux-headers-6.11.0-29-generic/ # 存放特定内核版本的头文件（Header Files），包含ubuntu中的特有文件，用于编译内核模块或开发与内核交互的应用程序。 ├── linux-headers-6.14.0-24-generic/ ├── linux-hwe-6.11-headers-6.11.0-29/ # 提供对新硬件的支持（如更新的 GPU、CPU 驱动）。 ├── linux-hwe-6.14-headers-6.14.0-24/ ├── nvidia-575.57.08/ ├── nvidia-575.64/ └── python3.12/ 3. /usr/lib/modules 存放内核模块的目录。内核模块是动态可加载的代码片段，用于扩展内核功能（如硬件驱动、文件系统支持等），无需重新编译整个内核即可按需加载或卸载，内核模块可以在编译内核时编译到内核中，也可以单独编译成模块，然后动态加载到内核中。\n1 2 3 4 5 /usr/lib/modules ├── 6.11.0-26-generic ├── 6.11.0-28-generic ├── 6.11.0-29-generic └── 6.14.0-24-generic ","date":"2023-05-18T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%B8%B8%E7%94%A8linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95/","title":"常用Linux系统目录"},{"content":"啥是容器适配器 容器适配器还是容器，具体地说就是对标准库的基础容器进行包装，把容器的成员函数组合一下，如此一来就搞出来一个新的容器，这个新容器可以满足某些特殊需求。\n容器适配器 对于基础容器的要求 满足条件的基础容器 默认使用的基础容器 stack empty() size() back() push_back() pop_back() vector deque list deque queue empty() size() front() back() push_back() pop_front() deque list deque priority_queue empty() size() front() push_back() pop_back() vector deque vector ","date":"2023-05-18T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/","title":"容器适配器"},{"content":" 1. std::queue 2. 创建 queue 容器对象 3. 成员函数 1. std::queue 底层可以使用deque或者list，默认使用deque。\n1 2 3 4 5 // Defined in header \u0026lt;stack\u0026gt; template\u0026lt; class T, class Container = std::deque\u0026lt;T\u0026gt; \u0026gt; class stack; 2. 创建 queue 容器对象 1 2 // 一个空的 queue 容器对象 std::queue\u0026lt;int\u0026gt; que; 1 2 // 指定底层容器 std::queue\u0026lt;int, std::list\u0026lt;int\u0026gt;\u0026gt; que; 1 2 3 // 使用底层容器实例初始化queue容器实例 std::deque\u0026lt;int\u0026gt; sq{1,2,3}; std::queue\u0026lt;int\u0026gt; que(values); // 拷贝sq的内存 1 2 3 std::deque\u0026lt;int\u0026gt; sq{1,2,3}; std::queue\u0026lt;int\u0026gt; que1(values); std::queue\u0026lt;int\u0026gt; que2(my_queue1); // 拷贝构造 3. 成员函数 成员函数 功能 empty() queue为空返回 true。 size() 返回 queue 中元素的个数。 front() 返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 back() 返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 push(const T\u0026amp; obj) 在 queue 的尾部添加一个元素的副本。调用底层容器的成员函数 push_back()。 emplace() 在 queue 的尾部原地构造一个元素。 push(T\u0026amp;\u0026amp; obj) 以移动的方式在 queue 的尾部添加元素。调用底层容器的具有右值引用参数的成员函数 push_back() 完成。 pop() 删除 queue 中的第一个元素。 swap(queue \u0026amp;other_queue) 两个 queue 容器中的元素互换，2 个 容器中存储的元素类型以及底层采用的基础容器类型都必须相同。 ","date":"2023-05-17T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%E4%B9%8B-queue/","title":"容器适配器之 queue"},{"content":" 1. std::stack 2. 创建Stack容器对象 3. 成员函数 1. std::stack 底层可以使用vector、deque或者list。\n1 2 3 4 5 // Defined in header \u0026lt;stack\u0026gt; template\u0026lt; class T, class Container = std::deque\u0026lt;T\u0026gt; // 底层容器默认是deque \u0026gt; class stack; 2. 创建Stack容器对象 1 2 // 一个空的stack std::stack\u0026lt;int\u0026gt; st; 1 2 // 指定底层容器为list std::stack\u0026lt;int, std::list\u0026lt;int\u0026gt;\u0026gt; st; 1 2 3 4 // 使用已有的基础容器实例初始化栈对象。 // 但要求基础容器类型和当前栈的底层类型相同。 std::list\u0026lt;int\u0026gt; lst = {4, 5, 6}; std::stack\u0026lt;int, std::list\u0026lt;int\u0026gt;\u0026gt; stack_list(lst); // 拷贝lst的内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 拷贝构造 // 要求基础栈数据类型和栈的底层类型相同。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; int main() { std::stack\u0026lt;int\u0026gt; original; original.push(10); original.push(20); original.push(30); std::stack\u0026lt;int\u0026gt; copied(original); while (!copied.empty()) { std::cout \u0026lt;\u0026lt; copied.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; copied.pop(); } return 0; } 3. 成员函数 成员函数 功能 empty() 栈为空时返回true。 size() 返回 stack 栈中存储元素的个数。 top() 返回一个栈顶元素的引用，类型为 T\u0026amp;。如果栈为空，程序会报错。 push(const T\u0026amp; val) 先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。 push(T\u0026amp;\u0026amp; obj) 以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 pop() 弹出栈顶元素。 emplace(arg\u0026hellip;) 在栈顶位置原地构造一个元素。 swap(stack \u0026amp; other_stack) 将两个stack中的元素进行交换，2 个 stack 中的元素类型以及底层采用的基础容器类型都必须相同。 ","date":"2023-05-17T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%E4%B9%8B-stack/","title":"容器适配器之 stack"},{"content":" 1. 目标文件格式 2. 目标文件结构 1. 目标文件格式 PC平台的主流可执行文件格式有两种：Linux上的ELF和Windows上的PE。不仅仅是可执行文件，动态链接库、静态链接库、目标文件也都是以相同的格式保存的。以ELF为例，可以进一步分为4类：\nELF文件类型 描述 例子 可重定位文件 可以被用来链接成可执行文件、共享目标文件，例如静态库。 linux系统的.o windows系统的.obj 可执行文件 最常见的，没什么好说的 Windows系统的.exe Linux系统上没有后缀 共享目标文件 1. 连接器使用该文件和其他可重定位文件、共享目标文件链接，昌盛新的目标文件。 2. 动态链接器将几个共享目标文件与可执行文件结合，作为进程映像的一部分来运行。 Linux系统的 .so windows系统的 .dll 核心转储文件 进程意外终止时，系统将该进程地址空间的内容和终止时的一些信息存储到核心存储文件。 Linux系统的 core dump 实际上这两货都是COFF格式的变种，在Linux系统上可以使用file命令查看文件类型。COFF引入了段的概念，不同的目标文件，段的数量，类型不同。\n2. 目标文件结构 一个目标文件包含了多种信息，例如指令、数据等等，不同类型的数据放在不同的段中，具有不同的权限。以ELF文件为例： ELF文件的开头是一个文件头，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接，以及入口地址（可执行文件）、目标硬件、目标操作系统等等信息。文件头中还包含一个段表（Section Table），其实就是个数组，这个表描述了文件中的各个段的属性以及段在文件中的偏移位置等等。\n二进制文件中的机器指令位于代码段（.text或.code）中； 已初始化全局变量以及局部静态的变量位于数据段（.data）； 未初始化全局变量以及静态局部变量位于BSS段（.bss），这个段只是一个预留位置，内有内容，不占空间； ","date":"2023-05-09T00:00:00Z","permalink":"https://zuoco.github.io/p/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84/","title":"目标文件是什么样子的"},{"content":" 1. explicit 2. noexcept 3. constexpr 4. consteval 5. final 6. volatile 关键字 7. pragma once 8. 内存对齐 8.1. aligans 1. explicit explicit 关键字用于修饰类的构造函数，表明该构造函数是显式的，不能用于隐式类型转换，也就是说用户给的参数类型必须与构造函数的参数类型一致，否则会编译错误。\n2. noexcept 声明函数不会抛出异常。\n3. constexpr 编译期常量，在编译器初始化。\n4. consteval 这个函数每次调用都返回一个编译期常量。\n5. final 在类声明后添加 final，表示该类不可作为基类：\n1 2 3 4 5 6 7 8 class Base final { // 此类不能被继承 // ... }; // 尝试继承将导致编译错误 class Derived : public Base { // ❌ 错误：Base 是 final 的 // ... }; 6. volatile 关键字 使用 volatile 告诉编译器：该变量的值可能在程序之外被意外修改，所以不要对关键代码进行优化，每次访问该变量都必须直接操作内存。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。\n核心作用：\n防止编译器优化：编译器不会对 volatile 变量进行缓存（如寄存器）。 强制内存访问：每次读取 volatile 变量时，必须从内存中读取；每次写入后，必须立即刷新到内存。 7. pragma once 1 2 // 用于传统头文件 #pragma once // 告诉编译器，此文件只包含一次，防止重复包含 8. 内存对齐 8.1. aligans alignas 是 C++11 引入的标准方法，用于显式指定变量或类型的对齐方式。通过调整结构体成员的顺序，可以减少填充字节（padding），从而优化内存布局。虽然这与标准无关，但仍是实际开发中常用的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 指定结构体对齐 struct alignas(32) Data { // 32 字节对齐 int x; // 占用 [0, 3] 共 4 字节。 double y; // 占用 [8, 15] 共 8 字节。 char z; // 占用 [16] 共 1 字节。 // 为了对齐，尾部填充 15 字节（地址 [17, 31]） // 最终大小：32 字节。 }; // 指定变量对齐 alignas(64) char buffer[1024]; // 64 字节对齐 // 检查对齐 static_assert(alignof(Data) == 32); // 编译期验证 C++17中又引入了std::aligned_union，std::aligned_alloc等等来支持分配对齐内存。C++20 引入了 [[nodiscard]] 特性，可以用于标记返回对齐内存的函数，防止开发者忽略对齐检查，也可以使用编译器特性，但是不同的编译器使用方法不同。\n","date":"2023-05-08T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%85%B3%E9%94%AE%E5%AD%97/","title":"关键字"},{"content":" 1. 哈希容器 2. 底层实现 3. 哈希容器的负载因子 4. 成员函数 1. 哈希容器 无序关联容器基于哈希实现，并使用链地址法处理哈希冲突。和有序关联容器不同，哈希容器中的元素/key是未排序的，元素的位置由哈希函数确定。\nunordered_set：哈希集合 unordered_map：哈希映射 unordered_multiset：允许重复键的哈希集合 unordered_multimap：允许重复键的哈希映射 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但是当使用迭代器遍历容器中存储的元素时，执行效率就不如关联式容器了。\n2. 底层实现 首先，我们要有一个vector数组，但是这个数组不是用来存储元素的，而是用来存储链表头指针的，这些链表被称为“桶（bucket）”，哈希值相同的元素/key被放在同一个桶中，这就是所谓的链地址法。\n现在，我们要插入一个元素，过程如下：\n将key带入哈希函数，得到哈希值，H。 计算出来哈希值和桶的数量（n），进行取余操作（H%n），得到桶的索引。 将元素保存到桶中。 如果桶索引对应的桶不存在，则创建一个链表，将元素插入到链表头部，并将桶的头指针记录在vector数组中。 3. 哈希容器的负载因子 $$ 负载因子 = \\frac{存储的键值对总数}{桶数} $$\n负载因子越大，表明一个桶中存储的元素越多，那么哈希表就越慢，太慢了就说明哈希值的计算套路不好使了。stl中的哈希容器会有一个默认负载因子，超过默认值就会增加桶数量，并重新哈希，重新哈希会导致当前容器迭代器失效。\n4. 成员函数 成员方法 功能 bucket_count() 返回当前容器底层存储键值对时，使用桶的数量。 max_bucket_count() 返回当前系统中，unordered_map 容器底层最多可以使用多少个桶。 bucket_size(n) 返回第 n 个桶中存储键值对的数量。 bucket(key) 返回以 key 为键的键值对所在桶的编号。 load_factor() 返回 unordered_map 容器中当前的负载因子。 max_load_factor() 返回或者设置当前 unordered_map 容器的最大负载因子。 rehash(n) 尝试重新调整桶的数量为等于或大于 n 的值。如果 n 大于当前容器使用的桶数，则该方法会是容器重新哈希，该容器新的桶数将等于或大于 n。\n反之，如果 n 的值小于当前容器使用的桶数，则调用此方法可能没有任何作用。 reserve(n) 将容器使用的桶数（bucket_count() 方法的返回值）设置为最适合存储 n 个元素的桶数。 hash_function() 返回当前容器使用的哈希函数对象。 ","date":"2023-04-26T00:00:00Z","permalink":"https://zuoco.github.io/p/%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E5%93%88%E5%B8%8C%E5%AE%B9%E5%99%A8/","title":"无序关联容器（哈希容器）"},{"content":" 1. map和multimap的区别 1.1. 区别 1.2. 特殊成员函数 2. set和multiset的区别 2.1. 区别 2.2. 特殊成员 1. map和multimap的区别 1.1. 区别 相对于map，multimap允许存在重复的key。 和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。 1.2. 特殊成员函数 lower_bound(key) 返回一个双向迭代器，指向当前 multimap 容器中第一个大于或等于 key 的键值对。\n如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(key) 返回一个双向迭代器，指向当前 multimap 容器中第一个大于 key 的键值对。\n如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(key) 返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说返回了一个范围，该范围中的元素就是键为 key 的键值对。 count(key) 在当前 multimap 容器中，查找键为 key 的键值对的个数并返回。 2. set和multiset的区别 2.1. 区别 相对于set，multiset允许存在重复的元素。\n2.2. 特殊成员 和multimap一样。\n","date":"2023-04-24T00:00:00Z","permalink":"https://zuoco.github.io/p/%E6%9C%89%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8B-multimap%E5%92%8Cmultiset/","title":"有序关联容器之 multimap和multiset"},{"content":" 1. std::pair 2. map 3. 迭代器 4. 插入元素 5. 删除元素 6. 查找 7. 随机访问 8. 其他 1. std::pair 1 2 3 4 template\u0026lt; class T1, class T2 \u0026gt; struct pair; 该类模板用于创建“键值对”，T1，T2可以内置类型，也可以是自定义类型。\n2. map 1 2 3 4 5 6 7 Defined in header \u0026lt;map\u0026gt; template\u0026lt; class Key, class T, class Compare = std::less\u0026lt;Key\u0026gt;, class Allocator = std::allocator\u0026lt;std::pair\u0026lt;const Key, T\u0026gt;\u0026gt; \u0026gt; class map; std:map，基于红黑树，树的每一个节点都是一个std::pair，节点的pair.first的类型必须支持“\u0026lt;”运算，或者自定义比较逻辑，相对于set，map才是真正关联容器。 map的迭代器所指向的对象的“Key”是const的，“Key”本身是不能修改的，这样避免红黑树的平衡结构被改变，当然“value”是可以改变的。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; int main() { std::map\u0026lt;int,bool\u0026gt; m{{3, true}, {4, false}, {1, true}}; for (auto p : m) { std::cout \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt;p.second \u0026lt;\u0026lt; std::endl; } } 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; int main() { std::map\u0026lt;int,bool\u0026gt; m{{3, true}, {4, false}, {1, true}}; for (auto [k, v] : m) { std::cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; std::endl; } } 3. 迭代器 支持双向迭代器。\n4. 插入元素 1 2 3 4 5 int main() { std::map\u0026lt;int, bool\u0026gt; m; m.insert(std::pair\u0026lt;const int, bool\u0026gt;(3,true)); // 插入一个std::pair } 5. 删除元素 1 2 3 4 5 6 7 iterator erase( iterator pos ); iterator erase( const_iterator pos ); iterator erase( const_iterator first, const_iterator last ); size_type erase( const Key\u0026amp; key ); template\u0026lt; class K \u0026gt; size_type erase( K\u0026amp;\u0026amp; x ); 6. 查找 1 2 3 4 bool contains( const Key\u0026amp; key ) const; template\u0026lt; class K \u0026gt; bool contains( const K\u0026amp; x ) const; 7. 随机访问 使用[key]或者at()访问元素。\n对于[key]：\n1 2 3 4 5 6 int main() { std::map\u0026lt;int, bool\u0026gt; m; m.insert(std::pair\u0026lt;const int, bool\u0026gt;(6, true)); std::cout \u0026lt;\u0026lt; m[6] \u0026lt;\u0026lt; std::endl; } 对于m[6]，如果树的Key中没有6这个Key，map会向树中插入一个新元素，该节点的Key为6，value使用value类型的默认初始化方式。也就是说，“[]”操作可能会插入新节点，所以要注意const的map对象是不能使用“[]”的，请看如下代码：\n1 2 3 4 5 6 7 8 9 10 11 void fun(const std::map\u0026lt;int, int\u0026gt;\u0026amp; m) { m[3]; //编译期报错，因为m是const的，是不能修改的。 } int main() { std::map\u0026lt;int, int\u0026gt; m; m.insert(std::pair\u0026lt;const int, int\u0026gt;(3, 100)); fun(m); } 对于at()：\n1 2 3 4 5 6 int main() { std::map\u0026lt;int, bool\u0026gt; m; m.insert(std::pair\u0026lt;const int, bool\u0026gt;(6, true)); std::cout \u0026lt;\u0026lt; m.at(6) \u0026lt;\u0026lt; std::endl; } 对于m[6]，树的Key中没有6这个Key，代码会报错，程序终止。\n8. 其他 extract等等。\n","date":"2023-04-23T00:00:00Z","permalink":"https://zuoco.github.io/p/%E6%9C%89%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8B-map/","title":"有序关联容器之 map"},{"content":" 1. 初步认识 2. 自定义比较函数 3. 迭代器 4. 插入元素 4.1. insert、emplace 4.2. emplace_hint 5. 删除元素 6. 访问元素 6.1. contains 6.2. find 7. 修改元素 1. 初步认识 set底层是红黑树，因此set中的元素必须支持比较大小，对于自定义类型需要重载“\u0026lt;”，或者自定义一个比较函数并在创建set对象时指定。 set被放到关联容器中范畴里面，是从功能上来说的，它本身不是基于键值对形式的，如果非要理解为键值对形式的，那么键就是值，值就是键。\n1 2 3 4 5 template\u0026lt; class Key, class Compare = std::less\u0026lt;Key\u0026gt;, class Allocator = std::allocator\u0026lt;Key\u0026gt; \u0026gt; class set; 上面从类模板中，Compare是用于元素比较的函数，Allocator是分配器，这两个都有默认的参数，所以我们可以如下创建set对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # include \u0026lt;iostream\u0026gt; # include \u0026lt;set\u0026gt; int main() { /** * 初始化时，元素顺序不重要，set会进行排序； * 元素必须支持比较大小，set会去除重复元素； */ std::set\u0026lt;int\u0026gt; s{66, 99, 88}; for (auto ptr = s.begin(); ptr != s.end(); ++ptr) { std::cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; std::endl; } } 代码输出:\n1 2 3 66 88 99 代码输出结果为升序，考虑到set底层使用是红黑树，因此推测set遍历方式为中序遍历。\n2. 自定义比较函数 仿函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; // 自定义比较仿函数：按降序排序 struct CompareDesc { bool operator()(int a, int b) const { return a \u0026gt; b; // 降序排列 } }; int main() { std::set\u0026lt;int, CompareDesc\u0026gt; mySet = {3, 1, 4, 1, 5}; for (const auto\u0026amp; val : mySet) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 输出：5 4 3 1 } return 0; } Lambda 表达式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;functional\u0026gt; int main() { // 使用 Lambda 表达式定义比较规则（降序） auto compareDesc = [](int a, int b) { return a \u0026gt; b; }; std::set\u0026lt;int, decltype(compareDesc)\u0026gt; mySet(compareDesc); mySet.insert(3); mySet.insert(1); mySet.insert(4); for (const auto\u0026amp; val : mySet) { std::cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 输出：4 3 1 } return 0; } 3. 迭代器 支持双向迭代器，但是set迭代器所指向的对象是const的，因此不能通过迭代器修改元素。\n4. 插入元素 4.1. insert、emplace 1 2 3 4 5 6 int main() { std::set\u0026lt;Str, decltype(\u0026amp;MyCompare)\u0026gt; s{Str{Str{66}, Str{99}}, Compare}; s.insert(Str{88}}); s.emplace(77); } 根据参数来看，insert是先构造一个Str对象，然后拷贝或者移动到s中，而emplace直接在s中构造一个Str对象。\n4.2. emplace_hint 1 2 template\u0026lt; class... Args \u0026gt; iterator emplace_hint( const_iterator hint, Args\u0026amp;\u0026amp;... args ); 通过hint参数，告诉系统，新元素大约要插入到那里，参数\u0026quot;Args\u0026amp;\u0026amp;\u0026hellip; args\u0026quot;用来构造新元素，这样能够减少比较次数，但是要求hint准确，如果hint不准确，可能导致效率更低。\n5. 删除元素 1 2 3 size_type erase( const Key\u0026amp; key ); iterator erase( const_iterator pos ); iterator erase( const_iterator first, const_iterator last ); 6. 访问元素 6.1. contains 1 2 3 4 bool contains( const Key\u0026amp; key ) const; template\u0026lt; class K \u0026gt; bool contains( const K\u0026amp; x ) const; 如果包含就返回true，否则返回false。\n6.2. find 1 2 3 4 5 6 7 8 iterator find( const Key\u0026amp; key ); const_iterator find( const Key\u0026amp; key ) const; template\u0026lt; class K \u0026gt; iterator find( const K\u0026amp; x ); template\u0026lt; class K \u0026gt; const_iterator find( const K\u0026amp; x ) const; 如果找到元素就返回该元素的迭代器，否则返回end()。\n7. 修改元素 由于set迭代器是const的，因此不能通过迭代器修改元素，可以使用extract()完成。\n1 2 3 4 5 6 node_type extract( const_iterator pos ); node_type extract( const Key\u0026amp; k ); template\u0026lt; class K \u0026gt; node_type extract( K\u0026amp;\u0026amp; x ); 使用方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string_view\u0026gt; #include \u0026lt;set\u0026gt; void print(std::string_view comment, const auto\u0026amp; data) { std::cout \u0026lt;\u0026lt; comment; for (auto datum : data) std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; datum; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { std::set\u0026lt;int\u0026gt; cont{1, 2, 3}; print(\u0026#34;Start:\u0026#34;, cont); // Extract node handle and change key auto nh = cont.extract(1); nh.value() = 4; print(\u0026#34;After extract and before insert:\u0026#34;, cont); // Insert node handle back cont.insert(std::move(nh)); print(\u0026#34;End:\u0026#34;, cont); } 程序输出：\n1 2 3 Start: 1 2 3 After extract and before insert: 2 3 End: 2 3 4 可以看出来，extract的使用流程是先将这个元素从set中取出来，然后我们修改元素的值，修改完成后再重新放到set中，但不是原先的位置了，因为值变了。\n","date":"2023-04-22T00:00:00Z","permalink":"https://zuoco.github.io/p/%E6%9C%89%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8B-set/","title":"有序关联容器之 Set"},{"content":" 1. std::list 2. 迭代器 3. 创建std::list容器对象 4. 成员函数 4.1. 访问 4.2. 插入 4.3. 删除 5. forward_list 1. std::list std::list，底层是双向链表形式的。\n1 2 3 4 5 // Defined in header \u0026lt;list\u0026gt; template\u0026lt; class T, class Allocator = std::allocator\u0026lt;T\u0026gt; \u0026gt; class list; 2. 迭代器 支持双向迭代器。\n3. 创建std::list容器对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std::list\u0026lt;int\u0026gt; values; std::list\u0026lt;int\u0026gt; values(10); // 创建一个有 10 个元素的 list 容器，元素值都为 0 std::list\u0026lt;int\u0026gt; values(10, 5); // 创建一个有 10 个元素的 list 容器，元素值都为 5 std::list\u0026lt;int\u0026gt; values{1, 2, 3, 4, 5}; // 使用他容器或数组中数据创建 list 容器 int a[] = { 1,2,3,4,5 }; std::list\u0026lt;int\u0026gt; values(a, a+5); std::array\u0026lt;int, 5\u0026gt;arr{ 11,12,13,14,15 }; std::list\u0026lt;int\u0026gt;values(arr.begin()+2, arr.end()); 4. 成员函数 4.1. 访问 front()、back()、迭代器。\n4.2. 插入 push_front()、push_back()、emplace_front()、emplace_back()、emplace()、insert()、splice()\n1 2 3 4 5 6 7 8 9 10 // 将元素从一个链表转移到另一个链表（或同一链表的不同位置）。 // 通过直接调整链表节点的指针实现，不涉及元素的复制或移动，因此性能较高。 void splice( const_iterator pos, list\u0026amp; other ); // 将 other 的所有元素转移到当前链表的 pos 迭代器指向的位置之前。 void splice( const_iterator pos, list\u0026amp;\u0026amp; other ); void splice( const_iterator pos, list\u0026amp; other, const_iterator it ); // 将 other 中由 it 指向的单个元素转移到当前链表的 pos 之前。 void splice( const_iterator pos, list\u0026amp;\u0026amp; other, const_iterator it ); // 将 other 中 [first, last) 范围内的元素转移到当前链表的 pos 之前。 void splice( const_iterator pos, list\u0026amp; other, const_iterator first, const_iterator last ); void splice( const_iterator pos, list\u0026amp;\u0026amp; other, const_iterator first, const_iterator last ); 4.3. 删除 pop_front()： 删除位于 list 容器头部的一个元素。\npop_back()： 删除位于 list 容器尾部的一个元素。\nerase()：\t该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素。\nclear()：\t删除 list 容器存储的所有元素。\nremove(val)： 删除容器中所有等于 val 的元素。\nunique():\t删除容器中相邻的重复元素，只保留一份。\nremove_if(): 删除容器中满足条件的元素。\n5. forward_list 单链表。\n","date":"2023-04-18T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E4%B9%8B-list-%E5%92%8C-forward_list/","title":"序列容器之 list 和 forward_list"},{"content":" 1. deque 2. 迭代器 3. 常用成员函数 4. 创建 deque 容器对象 5. 访问方法 1. deque std::deque，双端队列，支持在头部和尾部高效插入/删除元素，同时提供随机访问能力，不擅长在序列中间添加或删除元素，从功能上看起来，像是对于 std::vector 的增强。\n1 2 3 4 5 6 7 8 9 10 11 12 // Defined in header \u0026lt;deque\u0026gt; template\u0026lt; class T, class Allocator = std::allocator\u0026lt;T\u0026gt; class deque{ // ... protected: iterator start; // 指向第一个块 iterator finish; // 指向最后一个块 map_pointer map; // 映射表 // ... } 可以看到，deque容器底层使用分块存储，由多个相等大小的内存块组成，单是内存块之间不一定是连续的，可以位于在内存的不同区域。使用一个映射表（可能是vector）来保存各个块的起始地址。\n通过映射表就可以将分散的内存块连接起来，从而实现一个“连续的内存块”，当需要在头部或尾部增加块时，只需要申请内存后更新映射表即可。\n2. 迭代器 支持随机访问迭代器，用起来和vector一样，但是底层是不一样的，deque底层是分块的，所以deque对于随机访问进行了封装，重载了随机访问迭代器的各种运算符，使得迭代器需要能够识别块的边界，从而在不连续的分段块之间无缝遍历。\n3. 常用成员函数 相比vector增加了如下成员函数：\n成员函数 函数功能 push_back() 在序列的尾部添加一个元素。 push_front() 在序列的头部添加一个元素。 pop_back() 移除容器尾部的元素。 pop_front() 移除容器头部的元素。 例如插入元素：\n4. 创建 deque 容器对象 1 2 3 4 5 6 7 8 std::deque\u0026lt;int\u0026gt; d; // 空的 deque 容器对象 std::deque\u0026lt;int\u0026gt; d(10); // 创建一个具有 10 个元素的 deque 容器，默认初始值为 0 std::deque\u0026lt;int\u0026gt; d(10, 42); // 创建一个具有 10 个元素的 deque 容器，每个元素的值都为 42 std::deque\u0026lt;int\u0026gt; d1(5); std::deque\u0026lt;int\u0026gt; d2(d1); // 通过拷贝d1创建一个deque对象d2，需要d2与d1的元素类型相同 1 2 3 4 5 6 7 // 通过拷贝其他类型容器中指定区域内的元素创建一个新容器 int a[] = { 1,2,3,4,5 }; std::deque\u0026lt;int\u0026gt;d(a, a + 5); std::array\u0026lt;int, 5\u0026gt;arr{ 11,12,13,14,15 }; std::deque\u0026lt;int\u0026gt;d(arr.begin()+2, arr.end()); 5. 访问方法 使用迭代器、[]、at()。\n","date":"2023-04-17T00:00:00Z","permalink":"https://zuoco.github.io/p/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E4%B9%8B-deque/","title":"顺序容器之 —— deque"},{"content":" 1. vector 2. 使用 2.1. 容量 2.2. 访问 2.3. 构造vector对象 2.4. 插入元素 2.4.1. 尾部插入 2.4.2. 指定位置插入 2.5. 移除元素 3. 内存释放 4. 迭代器 5. 其他 1. vector std::vector，动态数组，维护一块连续的存储空间，容量可动态改变。 size : 当前元素个数。 cap : 当前容量，会动态扩容。 buffer : 指向一块连续的存储空间。\n2. 使用 2.1. 容量 empty、size，capacity方法。 shrink_to_fit()，如果不再需要再填充元素了，那就可以调用shrink_to_fit()方法，将cap缩减到size大小。本质就是在申请一块size大小的内存，然后将原来的元素拷贝到新的内存中，然后释放原来的内存。 2.2. 访问 下标访问，和array一样，可以使用[]访问元素。 支持front、back、data方法。 swap方法，交换两个vector对象，实际是交换指针，所以比array要快（注意是交换两个vector对象，而不是一个vector对象中的元素）。 关于swap方法，有一个常用的技巧是结合它来“清空”一个向量并释放其内存: 1 std::vector\u0026lt;int\u0026gt;().swap(vec1); std::vector\u0026lt;int\u0026gt;() 创建了一个临时的、空的 vector 对象，.swap(vec1) 调用了这个临时对象的 swap 方法，将它与 vec1 的内容交换。交换后，vec1 变成一个空的 vector（和临时对象交换后的结果），临时对象现在持有原来 vec1 的所有内存资源，当这行语句结束后，在临时对象超出作用域时被销毁，它所持有的内存也被一并释放。如果使用clear()，则vec1会被清空，但是容量没有重置，内存不会被释放。\n2.3. 构造vector对象 1 2 3 // 构造一个初始容量为1024的vector对象。 std::vector\u0026lt;int\u0026gt; v; v.reserve(1024); 1 2 // vecitor对象的初始容量为6，每个元素的值都被初始化为1024。 std::vector\u0026lt;int\u0026gt; v(6, 1024); 2.4. 插入元素 2.4.1. 尾部插入 两者都是向容器末尾添加元素，但是工作原理不同：\npush_back\n将一个已经构造好的对象添加到容器的末尾，若传递右值会调用移动构造函数（若存在）；若传递左值，则调用拷贝构造函数。\n1 2 3 4 std::vector\u0026lt;Person\u0026gt; vec; Person alice(\u0026#34;Alice\u0026#34;, 30); vec.push_back(alice); // 拷贝构造 vec.push_back(Person(\u0026#34;Bob\u0026#34;, 25)); // 移动构造 emplace_back\n直接传递构造对象所需的参数列表，在容器末尾直接构造一个对象，避免临时对象的创建，也就是在容器末尾原地构造一个对象出来。\n1 vec.emplace_back(\u0026#34;Charlie\u0026#34;, 40); // 直接构造，无拷贝或移动 2.4.2. 指定位置插入 两者都是向容器中指定位置插入元素，返回指向新插入元素的迭代器，区别参考push_back和emplace_back。两者的第一个参数都是一个迭代器，新元素会插入到迭代器指向的元素之前。\ninsert\n1 2 3 4 5 6 7 8 iterator insert( const_iterator pos, const T\u0026amp; value ); iterator insert( const_iterator pos, T\u0026amp;\u0026amp; value ); iterator insert( const_iterator pos, size_type count, const T\u0026amp; value ); // 快速填充多个相同元素。 template\u0026lt; class InputIt \u0026gt; iterator insert( const_iterator pos, InputIt first, InputIt last ); // 在迭代器 pos 指向的位置前插入范围 [first, last) 中的所有元素。 iterator insert( const_iterator pos, std::initializer_list\u0026lt;T\u0026gt; ilist ); // 在迭代器 pos 指向的位置前插入初始化列表 ilist 中的所有元素。 emplace\n1 2 template\u0026lt; class... Args \u0026gt; iterator emplace( const_iterator pos, Args\u0026amp;\u0026amp;... args ); // 根据给定参数在指定位置前，原地构造一个元素。 2.5. 移除元素 pop_back，移除最后一个元素。\n1 void pop_back(); erase，移除指定位置/区间的元素。移除指定位置的元素，后边的元素要前移，因为vector是连续存储的。\n1 2 3 iterator erase( const_iterator pos ); iterator erase( const_iterator first, const_iterator last ); clear，移除 vector 中所有元素，使其size()变为0，但是容量（capacity()）不变。clear() 会遍历容器中的每个元素，并调用元素的析构函数，但vector对象本身不会被释放。\n1 void clear(); 3. 内存释放 clear() 不释放内存，若需释放内存，需手动调用 shrink_to_fit()：\n1 2 vec.clear(); vec.shrink_to_fit(); // capacity 变为 0 4. 迭代器 支持随机访问的迭代器。\n5. 其他 本身不提供push_front和pop_front方法。 写操作可能会导致迭代器失效，就是发生变化了，这个迭代器指向的已经不是原来的那个元素了。 进行比较时，和array不同，vector的大小可以动态改变，即使是大小不同的两个vector对象也可以比较，但是元素类型还是要相同的。 ","date":"2023-04-16T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E4%B9%8B-vector/","title":"序列容器之  vector"},{"content":" 1. Array 2. 用法 2.1. 迭代器 2.2. 成员函数 2.2.1. 数组填充 2.2.2. 元素交换 2.2.3. 比较 2.2.4. 容量方法 1. Array std::array，基于数组封装，大小固定，不能动态改变。\n1 2 3 4 5 // Defined in header \u0026lt;array\u0026gt; template\u0026lt; class T, std::size_t N \u0026gt; struct array; 2. 用法 思路和数组差不多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;array\u0026gt; int main() { // 1. 声明一个包含5个整数的数组 std::array\u0026lt;int, 5\u0026gt; arr1 = {1, 2, 3, 4, 5}; std::array\u0026lt;int, 5\u0026gt; arr2 = {}; // 全部元素初始化为0 std::array\u0026lt;int, 5\u0026gt; arr3 = {1}; // 第一个元素初始化为1 // 2. 访问数组元素 std::cout \u0026lt;\u0026lt; \u0026#34;First element: \u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;arr.at(10) = \u0026#34; \u0026lt;\u0026lt; arr.at(10) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 越界访问会崩溃 // 3. 遍历数组 std::ranges::sort(arr); // 使用 C++20 的 std::ranges::sort 对 std::array 排序 for (const auto\u0026amp; elem : arr) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 4. 访问数组的第一个和最后一个元素 std::cout \u0026lt;\u0026lt; \u0026#34;First element: \u0026#34; \u0026lt;\u0026lt; arr.front() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Last element: \u0026#34; \u0026lt;\u0026lt; arr.back() \u0026lt;\u0026lt; std::endl; } 2.1. 迭代器 支持最强大的随机访问迭代器。\n1 2 3 4 5 std::cout \u0026lt;\u0026lt; \u0026#34;Using forward iterator:\\n\u0026#34;; for (auto it = arr.begin(); it != arr.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 2.2. 成员函数 2.2.1. 数组填充 用于将容器中的所有元素都设置为指定的值。\n1 2 void fill( const T\u0026amp; value ); // (since C++11) // (constexpr since C++20) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;array\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { constexpr std::size_t xy = 4; using Cell = std::array\u0026lt;unsigned char, 8\u0026gt;; std::array\u0026lt;Cell, xy * xy\u0026gt; board; board.fill({0xE2, 0x96, 0x84, 0xE2, 0x96, 0x80, 0, 0}); // \u0026#34;▄▀\u0026#34;; for (std::size_t count{}; Cell c : board) std::cout \u0026lt;\u0026lt; c.data() \u0026lt;\u0026lt; ((++count % xy) ? \u0026#34;\u0026#34; : \u0026#34;\\n\u0026#34;); } 输出：\n1 2 3 4 ▄▀▄▀▄▀▄▀ ▄▀▄▀▄▀▄▀ ▄▀▄▀▄▀▄▀ ▄▀▄▀▄▀▄▀ 这个比较有趣，是一个棋盘，讲解一下：\n这个棋盘由16个“▄▀”组成，每个“▄▀”在代码中用一个Cell表示，对于每个Cell:\n1 Cell c = {0xE2, 0x96, 0x84, 0xE2, 0x96, 0x80, 0, 0}; 0xE2, 0x96, 0x84打印出来就是“▄”，而0xE2, 0x96, 0x80打印出来就是“▀”， 0, 0确保字符串以空字符结尾（因为代码中使用了data()方法）。\n2.2.2. 元素交换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;array\u0026gt; #include \u0026lt;iostream\u0026gt; /* * 重载“\u0026lt;\u0026lt;” */ template\u0026lt;class Os, class V\u0026gt; Os\u0026amp; operator\u0026lt;\u0026lt;(Os\u0026amp; os, const V\u0026amp; v) { os \u0026lt;\u0026lt; \u0026#39;{\u0026#39;; for (auto i : v) os \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; i; return os \u0026lt;\u0026lt; \u0026#34; } \u0026#34;; } int main() { std::array\u0026lt;int, 3\u0026gt; a1{1, 2, 3}, a2{4, 5, 6}; auto it1 = a1.begin(); auto it2 = a2.begin(); int\u0026amp; ref1 = a1[1]; int\u0026amp; ref2 = a2[1]; std::cout \u0026lt;\u0026lt; a1 \u0026lt;\u0026lt; a2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; a1.swap(a2); std::cout \u0026lt;\u0026lt; a1 \u0026lt;\u0026lt; a2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 这里简单介绍以下“\u0026laquo;”的工作原理：\n1 template\u0026lt;class Os, class V\u0026gt; Os\u0026amp; operator\u0026lt;\u0026lt;(Os\u0026amp; os, const V\u0026amp; v) 函数模板，根据传递的参数进行推导并实例化模板函数。“\u0026laquo;”运算返回Os引用，以便于链式调用：\n1 operator\u0026lt;\u0026lt;(operator\u0026lt;\u0026lt;(std::cout, a1), a2); 2.2.3. 比较 1 2 operator== (C++11) operator\u0026lt;=\u0026gt; (C++20) operator== 1 2 3 // (since C++11) (constexpr since C++20) template\u0026lt; class T, std::size_t N \u0026gt; bool operator==( const std::array\u0026lt;T, N\u0026gt;\u0026amp; lhs, const std::array\u0026lt;T, N\u0026gt;\u0026amp; rhs ); 要求双方类型相同。\n1 2 std::array\u0026lt;int, 3\u0026gt; x; std::array\u0026lt;int, 4\u0026gt; y; x和y的类型不同，所以不能比较。\noperator\u0026lt;=\u0026gt;\n飞船运算符，以后单独章节介绍。 2.2.4. 容量方法 对于std::array，empty() 、size() 、max_size()，这些在编译期就确定了，所以运行时调用这些方法没有意义。那么为什么还要提供这些方法呢？因为这些方法在其他容器中是有意义的，为了统一接口，这些方法在std::array中也提供了。\n","date":"2023-04-15T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E4%B9%8B-array/","title":"序列容器之 Array"},{"content":" 1. 数据成员和函数成员 2. 数据成员的内存布局 3. 有成员变量遮蔽时的内存分布 4. 多继承时的内存模型 5. 虚继承时的内存分布 1. 数据成员和函数成员 类是创建对象的模板，不存在于编译后的可执行文件中，而对象是实实在在的数据，需要内存来存储。在创建对象时要为对象分配内存，不同对象的成员变量值不同，所以需要单独分配内存，但成员函数的代码是相同的，所有对象共享同一段函数代码。成员变量在堆区或栈区分配内存，成员函数放在代码区。\n很显然，对象的大小只受成员变量的影响，和成员函数没有关系。和结构体非常类似，对象的成员变量也会有内存对齐的问题。\n2. 数据成员的内存布局 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A { public: int a; } class B : public A { public: int b; } class C : public B { public: int c; } 类C对象的内存布局如下：\n3. 有成员变量遮蔽时的内存分布 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class A { public: int a; } class B : public A { public: int a; int b; } class C : public B { public: int a; int b; int c; } C::a，C::b遮蔽了A::a，B::b，但是A::a、B::b依然在内存中。\n4. 多继承时的内存模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class A { public: int a; } class B { public: int b; } class C : public A, public B { public: int c; } 两个基类的成员按继承时声明的顺序排列。\n5. 虚继承时的内存分布 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class A{ public: int a; }; class B : virtual public A{ public: int b; }; class C : virtual public A{ public: int c; }; class D : public B ,public C{ public: int d; }; 虚基类子对象（共享部分）位于派生类最后面，所以在编译期共享部分的地址会变化，需要编译器使用特定的方法计算地址，不同的编译器方法可能也不同。\n","date":"2023-04-02T00:00:00Z","permalink":"https://zuoco.github.io/p/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A107-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","title":"C++面向对象（07） — 对象的内存模型"},{"content":" 1. 虚函数与纯虚函数 1.1. 虚函数 1.2. 纯虚函数 2. 构造与析构 2.1. 构造 2.2. 析构 3. 虚函数表 3.1. 什么是虚函数表 3.2. 虚函数表结构 4. 多态 4.1. 类的向上转型 4.2. 基类指针访问派生类 4.2.1. 访问成员函数 4.2.2. 访问成员变量 1. 虚函数与纯虚函数 抽象类： 包含至少一个纯虚函数的类，这种类无法实例化，用于定义接口规范，然后让派生类去实现。 强制实现：派生类必须实现所有纯虚函数，否则仍为抽象类。 1.1. 虚函数 基类中声明为 virtual 的成员函数，允许派生类继承并重写该函数，从而实现运行时多态性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;A constructor\u0026#34; \u0026lt;\u0026lt; endl; } virtual ~A() { cout \u0026lt;\u0026lt; \u0026#34;A destructor\u0026#34; \u0026lt;\u0026lt; endl; } // 虚析构 virtual void print() { cout \u0026lt;\u0026lt; \u0026#34;A::print()\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public A { public: B() { cout \u0026lt;\u0026lt; \u0026#34;B constructor\u0026#34; \u0026lt;\u0026lt; endl; } ~B() { cout \u0026lt;\u0026lt; \u0026#34;B destructor\u0026#34; \u0026lt;\u0026lt; endl; } // 覆盖虚函数 void print() override { cout \u0026lt;\u0026lt; \u0026#34;B::print()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { A* ptr = new B(); // 基类指针指向派生类对象 ptr-\u0026gt;print(); // 实际调用的是B实现的print delete ptr; // 多态析构，调用B的析构函数 return 0; } 代码输出：\n1 2 3 4 5 A constructor B constructor B::print() B destructor A destructor 动态绑定特性，通过基类指针或引用调用虚函数时，会根据所指向的对象的实际类型动态决定调用哪个实现。\n1.2. 纯虚函数 声明为virtual void func() = 0;的虚函数，基类不会给出实现。\n1 2 3 4 5 6 7 8 9 class AbstractBase { public: virtual void pureFunc() = 0; // 纯虚函数 }; class Concrete : public AbstractBase { public: void pureFunc() override { std::cout \u0026lt;\u0026lt; \u0026#34;Concrete::pureFunc\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 一般C++的项目的架构中，会有一个最底层的基类，只有默认构造函数和虚析构函数，项目的所有类型的基类都从这里派生。\n2. 构造与析构 2.1. 构造 构造函数和普通类型的构造函数的规则一样。\n2.2. 析构 抽象类的析构函数必须是虚函数。\n1 2 3 4 class AbstractBase { public: virtual ~AbstractBase() = default; } 3. 虚函数表 3.1. 什么是虚函数表 是编译器在编译期为每个有虚函数的类自动生成虚函数的函数指针数组（虚函数表vtable），只读数据段，在程序加载到内存时已存在。在运行期，通过构造函数设置对象的隐藏指针（vptr）指向虚函数表来实现多态调用（这个 vptr 通常位于对象内存的最前面）。 在继承链中，构造函数的调用顺序决定了 vptr 的初始化过程。\n在vtable中，基类的虚函数的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增（基类没有的）的虚函数放在后面。如果派生类继承并重写了基类虚函数，那么就使用派生类的实现的虚函数替换基类的虚函数，位置是不变的。这样具有遮蔽关系的虚函数在vtable中只会出现一次。在单继承情况下，当通过对象指针p调用虚函数时，编译器内部会发生类似下面的转换：\n*(p+vbi) //虚函数表的地址 *(*(p+vbi)+vfi) //该虚函数的在表中的地址 (*(*(p+vbi)+vfi))(p); //函数调用，p是参数 vbi是vfptr(虚函数表指针)在对象中的偏移，p+vbi是vfptr的地址，虚函数表指针始终位于对象的起始位置，所以vbi = 0; *(p+vbi)是vfptr的值，而vfptr是指向vtable的指针，所以*(p+vbi)也就是vtable的地址; vfi是虚函数在vtable中的索引，所以(*(p+vbi)+vfi)也就是虚函数的地址; 知道了虚函数的地址，(*(*(p+vbi)+vfi))(p)也就是对虚函数的调用了，这里的p就是传递的实参，它会赋值给this指针。 可以看到，转换后的表达式是固定的，对于同一个虚函数，不管是哪个派生类的对象来调用，都会使用这个表达式，最终指向的是虚函数表中的同样位置。\n3.2. 虚函数表结构 基类的虚函数在 vtable 中的索引（下标）是固定的，不会随着继承层次的增加而改变。 派生类新增的虚函数放在基类虚函数的后面。 如果派生重写了基类的虚函数，那么将使用派生类重写的虚函数替换基类的虚函数，这样vtable只有重写后的虚函数。 4. 多态 多态可以分为编译时多态(重载、模板)和运行时多态（虚函数），静态多态在编译时就绑定了，动态多态在运行时才绑定，需要虚函数表的支持，所以动态多态，多少还是会带来性能损失的。此处主要讲解动态多态。\n4.1. 类的向上转型 向上转型（Upcasting）是指，从派生类类型转换为基类类型。 在C++中，向上转型可以是隐式的，也可以是显式的，使用显式类型转换主要是为了代码的清晰性和可读性（ static_cast()、dynamic_cast() ）。 向上转型后通过基类的对象、指针、引用只能访问从基类继承过去的成员（包括成员变量和成员函数），不能访问派生类新增的成员。 向上转型的三种情况：\n将派生类指针赋值给基类指针 将派生类引用赋值给基类引用: 类似于将派生类指针赋值给基类指针。 将派生类对象赋值给基类对象: 对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值。将派生类对象赋值给基类对象时，会舍弃派生类新增的成员 4.2. 基类指针访问派生类 4.2.1. 访问成员函数 编译器根据指针类型查找成员函数，然后成员函数根据this指针访问成员变量。如果没有虚函数机制，类型指针指向派生类对象时，使用的成员函数是基类的，但使用的成员变量却是派生类的（继承自基类的），如此一来，代码运行的结果必然会很离谱。C++通过虚函数机制来支持基类指针调用派生类成员函数。\n4.2.2. 访问成员变量 看下面代码，A类型的指针指向C类型的对象，此时只能访问A子对象中的成员。当有名字遮蔽时，例如下面代码中变量x，实际上内存中存在两个x，只是内层作用域将外层作用域的同名变量遮蔽了，此时使用A类型的指针指向派生类对象，访问到的就是外层作用域的变量，使用C类型的指针访问到的就是内层作用域的变量。一般也不会去遮蔽基类成员变量，遮蔽基类成员函数的情况很多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; class A { public: int a; int x = 100; }; class B : public A { public: int b; }; class C : public B { public: int c; int x; }; int main() { C m; m.a = 66; m.x = 88; C *c = \u0026amp;m; B *b = \u0026amp;m; A *a = \u0026amp;m; std::cout \u0026lt;\u0026lt; a-\u0026gt;a \u0026lt;\u0026lt; std::endl; // 只能访问A子对象的成员，A::a // std::cout \u0026lt;\u0026lt; a-\u0026gt;c \u0026lt;\u0026lt; std::endl; // 错误，A中没有成员c。 std::cout \u0026lt;\u0026lt; b-\u0026gt;b \u0026lt;\u0026lt; std::endl; // 只能访问B子对象的成员，B::b, A::a std::cout \u0026lt;\u0026lt; c-\u0026gt;x \u0026lt;\u0026lt; std::endl; // 输出88 std::cout \u0026lt;\u0026lt; a-\u0026gt;x \u0026lt;\u0026lt; std::endl; // 输出100，参考《c++对象内存模型》篇章 }静态多态在编译时就绑定 ","date":"2023-03-26T00:00:00Z","permalink":"https://zuoco.github.io/p/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A106-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/","title":"C++面向对象（06） — 动态多态与虚函数"},{"content":" 3. 基类指针 4. 使用using提权/降权 5. 继承中的构造与析构 5.1. 构造 5.2. 析构 6. 虚继承 3. 基类指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class UsbDevice { }; class UsbHub : public UsbDevice { } int main() { UsbHub hub; UsbDevice\u0026amp; device1 = hub; // 基类引用指向派生类对象 UsbDevice* device2 = \u0026amp;hub; // 基类指针指向派生类对象 } 4. 使用using提权/降权 用于修饰类成员（从基类继承过来的成员），提升成员的权限，但是只能对基类的public和protected成员进行提权或降权操作，不能改变基类private成员的访问权限，因为它们在派生类中不可见。\n1 2 3 4 5 6 7 8 9 10 11 12 class Base { protected: void internal() {} }; class Derived : public Base { public: using Base::internal; // 将internal成员权限提升为public，原本为protected }; Derived d; d.internal(); 5. 继承中的构造与析构 构造与析构不会被继承。\n5.1. 构造 构造函数调用顺序： 基类 \u0026ndash;\u0026gt; 派生类，与析构相反。 如果有多个基类，基类的构造是从左到右调用。 如果派生类没有指定调用基类的那个构造函数。就调用默认构造函数。 派生类只能调用直接基类的构造函数，但是虚继承中不同。 1 2 3 4 5 6 7 class Derived : public Base { public: // 如果不指定调用基类的那个构成函数，就会调用基类的默认构造函数 Derived( \u0026lt;参数列表\u0026gt; ) : Base( \u0026lt;基类构造函数参数\u0026gt; ) { // 派生类构造函数体 } }; 一个基类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; class Base { public: Base(int x) { cout \u0026lt;\u0026lt; \u0026#34;Base constructor with x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: // 显式调用 Base(int) Derived(int x, int y) : Base(x) { cout \u0026lt;\u0026lt; \u0026#34;Derived constructor with y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } }; int main() { Derived d(10, 20); return 0; } 多个基类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: A(int x) { cout \u0026lt;\u0026lt; \u0026#34;A constructor with x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } int x; }; class B { public: B(double y) { cout \u0026lt;\u0026lt; \u0026#34;B constructor with y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } int y; }; class Derived : public A, public B { public: // 按继承顺序调用 A 和 B Derived(int x, double y) : A(x), B(y) { cout \u0026lt;\u0026lt; \u0026#34;Derived constructor\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Derived d(10, 3.14); return 0; } 使用初始化列表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: A(int x) { cout \u0026lt;\u0026lt; \u0026#34;A constructor with x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } }; class B { public: B(double y) { cout \u0026lt;\u0026lt; \u0026#34;B constructor with y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } }; class Derived : public A, public B { private: int z; public: // 按继承顺序调用基类构造函数，然后是初始化列表 Derived(int x, double y, int z) : A(x), B(y), z(z) { cout \u0026lt;\u0026lt; \u0026#34;Derived constructor with z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } }; int main() { Derived d(10, 3.14, 42); } 5.2. 析构 调用顺序： 派生类 \u0026ndash;\u0026gt; 基类， 与构造函数相反。 无需显式调用基类析构函数， C++ 编译器会自动调用基类的析构函数。 基类的析构函数必须声明为虚函数， 这样才能通过基类的指针或引用调用派生类的析构函数，以安全释放内存。 将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数。 1 2 3 4 5 6 7 8 9 class Base { public: virtual ~Base() = default; }; class Derived : public Base { public: ~Derived() override { /* 释放派生类资源 */ } }; 6. 虚继承 菱形继承如下：\n1 2 3 4 5 A / \\ B C \\ / D 这种结构导致D通过B和C继承了两个独立的A实例，从而引发数据冗余和成员访问二义性。C++提供了虚拟继承机制，该机制下由派生类D来初始化虚基类A，也就说，由派生类D来调用A的构造函数，B和C调用A的构造函数是无效的，最终D中仅保留一份A的实例，B和C共享该实例。 C++标准库中的iostream类就是一个虚继承的实际应用案例。iostream从istream和ostream直接继承而来，而istream和ostream又都继承自一个共同的名为base_ios的类，是典型的菱形继承。此时istream和ostream必须采用虚继承，否则将导致iostream类中保留两份base_ios类的成员。\niostream是最终派生类，istream、ostream是直接基类，base_ios是间接基类（虚基类）。istream和ostream的公共成员声明在虚基类中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; class A{ public: A() { std::cout \u0026lt;\u0026lt; \u0026#34;AAA\u0026#34;\u0026lt;\u0026lt; std::endl; } }; class B : virtual public A{ public: B() { std::cout \u0026lt;\u0026lt; \u0026#34;BBB\u0026#34;\u0026lt;\u0026lt; std::endl; } }; class C : virtual public A { public: C() { std::cout \u0026lt;\u0026lt; \u0026#34;CCC\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class D : public B, public C{ public: D() { std::cout \u0026lt;\u0026lt; \u0026#34;DDD\u0026#34;\u0026lt;\u0026lt; std::endl; } }; int main() { D a; } 上面代码输出：\n1 2 3 4 AAA BBB CCC DDD 如果没有virtual修饰，A的构造函数会被调用两次：\n1 2 3 4 5 AAA ## BBB AAA ## CCC DDD 如果A没有成员（除了构造与析构），或者A有成员但是没有被访问，还是可以编译的，但是只要访问A的成员就会二义性。\n","date":"2023-03-25T00:00:00Z","permalink":"https://zuoco.github.io/p/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A105-%E7%B1%BB%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/","title":"C++面向对象（05） — 类继承中的知识点"},{"content":" 1. 赋值运算符“operator=” 1.1. 拷贝赋值 1.2. 移动赋值 1. 赋值运算符“operator=” 1 2 3 4 5 6 int main() { MyClass a; MyClass b; a = b; // 调用赋值运算符, b.operator=(a) } 1.1. 拷贝赋值 1 2 3 4 5 struct MyClass { int a; std::string b; // std::string 已支持深拷贝 MyClass\u0026amp; operator=(const MyClass\u0026amp;) = default; // 默认生成赋值运算符 }; 需要深拷贝时要自行实现赋值运算符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MyClass { public: int* data; size_t size; // 构造函数 MyClass(size_t s = 0) : size(s), data(new int[s]()) {} // 拷贝赋值运算符 MyClass\u0026amp; operator=(const MyClass\u0026amp; other) { if (this != \u0026amp;other) { // 防止自赋值 delete[] data; // 释放已有资源 size = other.size; data = new int[size]; // 分配新资源 std::copy(other.data, other.data + size, data); // 深拷贝数据 } return *this; // 返回赋值后的结果 } ~MyClass() { delete[] data; } }; 1.2. 移动赋值 1 2 3 4 struct MyClass { std::vector\u0026lt;int\u0026gt; vec; // 支持移动语义 MyClass\u0026amp; operator=(MyClass\u0026amp;\u0026amp; other) = default; // 默认生成移动赋值 }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class MyClass { public: int* data; size_t size; // 构造函数 MyClass(size_t n = 0) : data(new int[n]), size(n) {} // 析构函数 ~MyClass() { delete[] data; } // 移动赋值运算符重载 MyClass\u0026amp; operator=(MyClass\u0026amp;\u0026amp; other) noexcept { if (this != \u0026amp;other) { delete[] data; // 释放当前对象拥有的资源 data = other.data; // 转移 other 的资源 size = other.size; other.data = nullptr; // 防止 other 在析构时释放资源 other.size = 0; } return *this; } }; ","date":"2023-03-18T00:00:00Z","permalink":"https://zuoco.github.io/p/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A104-c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","title":"C++面向对象（04）— C++运算符重载"},{"content":" 1. 基本概念 2. 构造函数 2.1. 默认构造 2.2. 单一参数构造 2.3. 委托构造 2.4. 拷贝构成 2.5. 移动构造 3. 初始化列表 4. 析构函数 1. 基本概念 构造函数名称与类的名称相同。 创建对象，就是调用构造函数对对象进行初始化，确保成员包含有效值。 如果类定义时没有提供构造函数，编译器会默认生成一个无参构造函数。 如果构造函数没有初始化成员变量，那么这个成员变量就会包含一个垃圾值。 一旦我们自定义了构造函数，那么编译器将不会生成默认构造函数，所以自定义构造函数，就必须提供一个默认构造函数。 2. 构造函数 构造函数一般是public的。\n2.1. 默认构造 1 2 3 4 5 6 7 8 class MyClass { public: MyClass() = default; // 默认构造函数 // 其他构造函数 // ... private: // ... } 或者：\n1 2 3 4 5 6 7 8 class MyClass { public: MyClass(int x = 1, int y = 2, int z = 3); // 所有参数都有默认值的构造函数也属于默认构造函数 // 其他构造函数 // ... private: // ... } 2.2. 单一参数构造 仅接受一个参数的构造函数（会触发隐式类型转换），此种情况下，编译器会自动将参数类型转换为目标类型，无需显式调用构造函数。这种机制简化了代码，但也可能带来潜在风险。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MyClass { private: int m_age; public: MyClass(int age) : m_age(age) {} // 单参数构造函数 }; void print(const MyClass\u0026amp; MyClass) { // ... } int main() { MyClass e1(10); // 显式构造 MyClass e2 = 20; // 隐式转换：int → MyClass print(30); // 隐式转换：int → MyClass } 为避免意外的隐式转换，C++ 提供了 explicit 关键字。将构造函数标记为 explicit 后，只能显式调用构造函数，防止隐式转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyClass { private: int m_age; public: explicit MyClass(int age) : m_age(age) {} }; void print(const MyClass\u0026amp; MyClass) { // ... } int main() { MyClass e1(10); // 显式构造 MyClass e1 = 10; // 错误 print(e1(10)); // 显式构造 print(30); // 错误 } 2.3. 委托构造 把构造工作委托给另一个构成函数完成。\nMyClass.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #ifndef MYCLMyClassSS_H #define MYCLMyClassSS_H class MyClass { public: // 主构造函数声明 MyClass(int a, double b); // 委托构造函数声明 MyClass(); MyClass(int a); private: int x; double y; }; #endif // MYCLMyClassSS_H MyClass.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026#34;MyClass.h\u0026#34; #include \u0026lt;iostream\u0026gt; // 包含cout // 主构造函数定义（包含初始化列表和函数体） MyClass::MyClass(int a, double b) : x(a), y(b) { std::cout \u0026lt;\u0026lt; \u0026#34;Primary constructor\\n\u0026#34;; } // 委托构造函数定义（通过初始化列表委托） MyClass::MyClass() : MyClass(0, 0.0) { std::cout \u0026lt;\u0026lt; \u0026#34;Delegating constructor\\n\u0026#34;; } // 另一个委托构造函数定义 MyClass::MyClass(int a) : MyClass(a, 1.5) { // 可在此添加额外逻辑 } 2.4. 拷贝构成 对于指针成员，要使用深拷贝。 编译器会自动生成拷贝构造函数，但使用的是浅拷贝。 如果不希望类具备拷贝构造的能力，则使用delete关键字，例如单例模式中。 可以使用MyClass(MyClass\u0026amp; other) = default;来显式生成默认移动构造函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // 用于智能指针（非必须，但推荐） class MyClass { public: explicit MyClass(int value) : data(new int(value)) { std::cout \u0026lt;\u0026lt; \u0026#34;Constructor called\\n\u0026#34;; } // 拷贝构造函数（深拷贝），申请一块新内存，并将对方的数据拷贝过来。 MyClass(const MyClass\u0026amp; other) : data(new int(*other.data)) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy constructor called\\n\u0026#34;; } ~MyClass() { delete data; std::cout \u0026lt;\u0026lt; \u0026#34;Destructor called\\n\u0026#34;; } void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; *data \u0026lt;\u0026lt; \u0026#34; at \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } private: int* data; // 指针成员 }; 2.5. 移动构造 将对象A所拥有的资源（new出来的资源）转移到对象B中，对象A将不再拥有原本资源的使用权。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; // 用于字符串操作 class MyClass { public: explicit MyClass(const char* text) : data(new char[std::strlen(text) + 1]) { std::strcpy(data, text); std::cout \u0026lt;\u0026lt; \u0026#34;Constructed: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // 移动构造函数 MyClass(MyClass\u0026amp;\u0026amp; other) noexcept : data(other.data) { // 转移资源所有权 other.data = nullptr; // 置空原对象指针 std::cout \u0026lt;\u0026lt; \u0026#34;Moved: \u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } ~MyClass() { if(data) { std::cout \u0026lt;\u0026lt; \u0026#34;Destroying: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; delete[] data; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Destroying null object\\n\u0026#34;; } } void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;Content: \u0026#34; \u0026lt;\u0026lt; (data ? data : \u0026#34;null\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } private: char* data; // 指针成员（动态分配字符串） }; 与拷贝构造不同，编译器不会自动生成移动构造函数，需要显式定义，可以使用MyClass(MyClass\u0026amp;\u0026amp; other) noexcept = default;，来显式生成默认移动构造函数，如果没有移动构造函数就会调用拷贝构造函数。\n知识点： \u0026amp;\u0026amp;表示右值引用，临时对象（如字面量、函数返回的临时对象），生命周期短，无法直接取地址，通过绑定到右值，将原本即将销毁的临时对象的地址“保存”下来，有了地址就可以像使用左值一样使用了。 noexcept 用于声明一个函数不会抛出异常。例如std::vector，这个容器在空间不够时会自动扩容，也就是开辟一块新的空间，然后把原先的数据复制过去，然后释放原先的空间。这个拷贝的过程可能是移动构造，也可能是拷贝构造（如果移动构造不是noexcept的）。开发人必须保证coexcept函数确实不会抛出异常**，否则会带来严重的隐患，例如现在有一个vector\u0026lt;MyClass\u0026gt; v，容器中有6个成员，扩容的时候调用了noexcept的移动构造，但是扩容到一半抛出了异常，此时旧的空间只有后3个成员（前3个被移动到了新空间），新的空间只有前面3个成员，这样一来新的旧的都坏掉了，所以必须保证noexcept的函数真的不会抛出异常。\n3. 初始化列表 MyClass.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #ifndef MYCLASS_H #define MYCLASS_H #include \u0026lt;string\u0026gt; class MyClass { public: MyClass(int _id, std::string _name, double _value); void display() const; private: int id; std::string name; double value; }; #endif // MYCLASS_H MyClass.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026#34;MyClass.h\u0026#34; #include \u0026lt;iostream\u0026gt; // 构造函数定义（使用初始化列表） MyClass::MyClass(int _id, std::string _name, double _value) : id(_id), name(_name), value(_value) { std::cout \u0026lt;\u0026lt; \u0026#34;MyClass object created\\n\u0026#34;; } // 成员函数实现 void MyClass::display() const { std::cout \u0026lt;\u0026lt; \u0026#34;ID: \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;, Name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;, Value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 成员变量初始化顺序，由变量在类中声明的顺序决定。\n4. 析构函数 对于局部对象，离开作用域时，会自动调用析构函数。 对于new出来的对象，需要手动调用delete。 没有编写析构函数时，编译器会自动生成一个默认析构函数。 析构函数不允许抛出异常。 1 2 3 4 5 6 7 8 9 10 11 12 13 class MyClass { public: // 默认析构函数（由编译器隐式生成） ~MyClass() = default; // 显式定义析构函数 ~MyClass() { // 清理资源（如释放内存、关闭文件等） } // 虚析构函数（用于多态基类） virtual ~MyClass() = default; }; ","date":"2023-03-12T00:00:00Z","permalink":"https://zuoco.github.io/p/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A103-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/","title":"C++面向对象（03） — 构造与析构"},{"content":" 1. 对象的初始化 1.1. 基本类型 1.2. 自定义类 2. 自定义类型 2.1. 静态成员变量 2.2. this指针 2.3. const成员函数 2.4. 静态成员函数 2.5. 构造函数 2.6. 析构函数 2.7. 友元 1. 对象的初始化 1.1. 基本类型 对于基本类型，都可以使用零初始化。\n1 2 3 int x {}; // 零初始化： 初始化为0 int y {10}; // 1.2. 自定义类 创建对象就是调用类的构造函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MyClass { public: MyClass() { /* 默认构造函数 */ } MyClass(int x, int y) : x_(x), y_(y) {} private: int x_, y_; }; int main() { MyClass obj; // 默认构造函数 MyClass p(3, 4); // 调用对应的构造函数 } 2. 自定义类型 2.1. 静态成员变量 所有实例共享，也遵循类的访问控制规则（public/private/protected），在单例模式中用的较多。\n1 2 3 4 5 6 7 8 9 // MyClass.h class MyClass { public: /* * C++17 的 inline static 特性，允许在类内部定义并初始化静态成员变量 * inline 允许在头文件中定义静态成员变量，并确保即使多个翻译单元包含该头文件，链接器也能正确处理，不会导致多重定义错误。 */ inline static int count = 0; }; 1 2 3 4 5 6 7 8 class MyClass { public: /* * C++20的constexpr特性, 编译时使用字面量初始化。 * 不可修改，默认内联。 */ static constexpr int MaxValue = 100; }; 2.2. this指针 在类的内部，成员函数可以使用this指针访问当前对象，实际上this就是成员函数的一个参数，由编译器隐式传入的，它的类型是MyClass* const，所以this本身是不能修改的。至于this指向的对象是否可写，取决于成员函数的声明是否为const。\n2.3. const成员函数 参数列表后添加 const，用于修饰this指针。\n1 2 3 4 5 6 7 8 9 10 class MyClass { public: int getValue() const; // 声明 const 成员函数，在函数实现时也必须重复 const 关键字。 void setValue(int val); // 普通成员函数 }; // 定义时必须保持 const 一致性 int MyClass::getValue() const { return value; // 不能修改 value（除非 value 是 mutable） } 需要注意两件事情：\nconst 对象只能调用 const 成员函数，因为一般不允许const转换为非const： 1 2 3 const MyClass obj; obj.getValue(); // 合法（调用 const 函数） obj.setValue(5); // 错误：const 对象无法调用非 const 函数 const 与非 const 版本可以构成重载，因为参数类型不同： 1 2 3 4 5 6 7 8 9 10 11 class class MyClass { public: char get(int x, int y); // 非 const 版本 char get(int x, int y) const; // const 版本 }; const MyClass cs; cs.get(0, 0); // 调用 const 版本 MyClass s; s.get(0, 0); // 调用非 const 版本 2.4. 静态成员函数 所有实例共享，也遵循类的访问控制规则（public/private/protected），但是这种成员函数没有this指针，无法访问非静态的成员。需要显式传递对象。\n2.5. 构造函数 见《构造函数》篇章。\n2.6. 析构函数 见《析构函数》篇章。\n2.7. 友元 class中的成员默认是private的，但是有个别时候，需要访问private成员，此时就需要使用友元，但是友元会破坏封装，一般不用，等用到了再去研究。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class B; class A { friend B; static int a; float b; }; class B { void func() { // 作为A的友元，可以访问A的私有成员 std::cout \u0026lt;\u0026lt; A::a \u0026lt;\u0026lt; std::endl; } }; ","date":"2023-03-11T00:00:00Z","permalink":"https://zuoco.github.io/p/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A102-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/","title":"C++面向对象（02） —  自定义类型"},{"content":" 1. 异常语法格式 2. 栈展开 3. 异常对象 4. 捕获异常 4.1. 隐式类型转换 4.2. 捕获任意类型异常 4.3. 抛出已经捕获的异常 5. 函数try块 6. 标准库中的异常 7. 注意事项 1. 异常语法格式 1 2 3 4 5 6 7 8 9 try { // 可能抛出异常的代码段（使用 throw 抛出一个异常对象）。 } catch (ExceptionType \u0026amp;e) { // 处理异常。 } // 可以有多个catch块，来捕获不同类型的异常。 2. 栈展开 触发异常时，系统会进行“栈展开”：\n抛出异常后续的代码不会被执行。 局部对象会按照构造相反的顺序销毁。 系统会尝试匹配相应的catch块，如果匹配就执行catch块中的代码，然后执行后续代码。 如果没有匹配的catch块，就会一直栈展开，如果到了main函数还是匹配不到catch块，就触发terminate结束程序。 3. 异常对象 系统会使用抛出的异常拷贝初始化一个临时对象，称为异常对象。 异常对象会在栈展开过程中被保留，并且最终传递给匹配的catch块。 4. 捕获异常 4.1. 隐式类型转换 看如下代码：\n1 2 class Base {}; class Derived : public Base {}; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { try { // ... throw Derived(); } catch (Derived\u0026amp; e) { // ... } catch (Base\u0026amp; e) { // ... } } 上面代码的catch(Derived\u0026amp; e)块不会被匹配，因为Drived引用可以隐式转换为Base引用，这个转换是安全的。无论try{}块抛出Base还是Derived，catch(Base\u0026amp; e)都会被匹配。正确的写法是：\n1 2 3 4 5 6 7 8 catch (Derived\u0026amp; e) { // ... } catch (Base\u0026amp; e) { // ... } 类似的情形还有非const引用转为const引用、函数转为函数指针。\n4.2. 捕获任意类型异常 1 2 3 4 catch (...) { } 4.3. 抛出已经捕获的异常 在catch块中，可以抛出当前捕获的异常。\n1 2 3 4 5 catch (exception\u0026amp; e) { // ... throw; } 实际上是在catch块中，即使没有显式throw;，编译器也会在catch块的最后添加throw;，这样一来，其他地方依然能够感知到这个异常，例如在上一小节所讲述的情形中，如果对象创建失败，处理异常后没有退出程序，那么程序会继续往下执行，后面的程序就要通过异常来判断这个对象是否创建成功。\n1 2 3 4 5 int main() { B obj; obj.m_y; // 对象创建失败时，行为未定义 } 正确：\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { try { B obj; obj.m_y; } catch(int) { // 处理异常 } } 5. 函数try块 1. 在对象初始化时\n捕获初始化列表中抛出的异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class A { public: A() { throw 1;} } class B { public: B() try : m_x() { } catch (int) { // ... } private: A m_x; int m_y; public: void f(); } 这种情况下，栈展开时会销毁对应代码段在抛出异常时已经申请的资源， 但是不会调用B类型的析构函数。\n2. 一般的函数try块\n1 2 3 4 5 6 7 8 9 10 void f(A a) try { // ... throw 666; } catch(...) { } 1 2 3 4 5 6 7 8 9 10 11 int main() { try { f(A {}); // 注意了，A{}抛出的异常，需要在当前代码块中处理 } catch(...) { // 处理异常 } } 6. 标准库中的异常 1 #incliude \u0026lt;stdexcept\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 使用形式 void func() { throw std::runtime_error(\u0026#34;Invalid Inuput!\u0026#34;); } int main() { try { func(); } catch(std::runtime_error \u0026amp;e) { // 处理异常 std::cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } // ... } 实际开发中，应该抛出标准异常，或者派生自标准异常的异常。\n7. 注意事项 在一个异常未被捕获时，又抛出一个新的异常，程序会崩溃。 不要在析构函数，或者operator delete重载函数中抛出异常。 使用noexcept声明函数不会抛出异常，否则编译器默认会抛出异常。 1 2 3 4 5 void func() noexcept { // 1. 声明为noexcept的函数抛出异常，程序会终止。 // 2. } 1 2 3 4 5 void func() noexcept(/* \u0026lt;表达式\u0026gt; */) { // 1. noexcept(true)声明的函数不会抛出异常。 // 2. noexcept(false)声明的函数会抛出异常。 } 注意重定义，有noecept和没有noexcept其实声明的是同一个函数。 函数指针要注意形式兼容，函数指针要兼容它指向的那个函数。 1 2 3 4 5 6 7 8 9 10 11 void func(int) { } int main() { void (*fo)(int) noexcept = func; // 错误，func是有可能抛出异常的。 void (*foo)(int) = func; // 正确，foo 兼容 func } 虚函数override要注意形式兼容，就说基类的虚函数要兼容派生类重写的那个。 如果基类有可能抛出异常，则子类可以重写为可能抛出异常，也可以重写为不抛异常。 如果基类明确不抛异常，则子类必须重写为不抛异常。 注意异常安全，在抛出异常后进行栈展开，要释放当前代码块的资源，所以要保证这些资源的析构函数能够正常执行。 不要瞎用异常，异常的运行成本较高。 ","date":"2023-03-04T00:00:00Z","permalink":"https://zuoco.github.io/p/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"异常处理"},{"content":" 1. 封装 2. 继承 2.1. 继承时的权限 2.2. 单继承、多继承、虚继承 3. 多态 1. 封装 所谓 “封装” 就是将数据（属性）和操作数据的方法（行为）绑定在一起，并通过访问控制机制对外隐藏实现细节，我们将操作和数据封装到一个类型里面，同时约束类成员的访问权限，在C++里面有三个级别的访问权限。\n控制符 权限 private 默认权限，仅限类的内部访问 protected 仅限类的内部访问，和private的区别在于继承时 public 允许类的外部访问，也就是通过类的实例访问 另外还有mutable关键字，这个是用来修饰非静态成员变量的，用于突破const限制的关键字，现在有一个const类型对象（包括const成员函数），正常情况下我们是没有写权限的，但如果它有一个mutable的成员，那么这个mutable修饰的成员是可写的。\n2. 继承 2.1. 继承时的权限 继承就是认爹，并继承他爹的特性。和封装类似，继承也有3种权限（public、private、protected），继承权限决定了基类的那些可以被派生类继承，以及继承后这些成员在派生类中的访问权限。\n基类成员的权限 继承权限 派生类中的访问权限 private 任意继承方式 不可访问 protected 继承方式 protected public private private public protected protected public public public 如果使用struct的话，默认的继承方式就是public的，但是比较少用。\n2.2. 单继承、多继承、虚继承 单继承就是只有一个爹，多继承就是有多个爹，多继承更加强大，但可能会引发冲突，我们从是否为菱形继承的角度分为两种情况讨论。\n非菱形继承 当多个基类中存在同名成员（方法或变量）时，派生类在访问这些成员时会出现二义性问题。例如，两个基类都定义了 display() 方法，派生类调用 display() 时编译器无法确定应调用哪个基类的实现。此时可以在派生类中重新定义同名方法，覆盖基类的实现。 菱形继承\n除了上面的问题，菱形还要面对另一个问题，当两个基类继承自同一个公共祖先时，派生类会包含多个该祖先的副本，导致数据冗余和访问歧义（如果祖先类型有成员）。C++语言提供了虚继承的机制：\n1 2 3 4 class A {}; class B : virtual public A {}; // 虚继承 class C : virtual public A {}; // 虚继承 class D : public B, public C {}; // A类型的成员在D类型中只会保留一份。 3. 多态 多态就是“多种形态”，同一个接口可以有多种表现。C++中多态可以分为两类： 编译时多态、运行时多态。\n编译时多态： 函数重载、模板属于编译时多态，应为编译器在编译时就可以确定调用哪个函数。\n运行时多态： 虚函数和继承属于运行时多态，函数调用在运行时根据对象的实际类型动态决定，这是通过虚函数表实现的。\n","date":"2023-02-23T00:00:00Z","permalink":"https://zuoco.github.io/p/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A101-%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/","title":"C++面向对象（01） — 封装、继承、多态"},{"content":"位域 结构体和类中使用，显式表明对象的成员占用的位数。\n1 2 3 4 5 6 // 占用一个字节 struct { bool a : 1; // 占用1位 bool b : 1; } 这种操作，可以节省内存，但是访问成员的需要更多地运算。而且声明了位域的成员，不能取地址。\n","date":"2023-02-21T00:00:00Z","permalink":"https://zuoco.github.io/p/%E4%BD%8D%E5%9F%9F/","title":"位域"},{"content":" 1. 联合体 2. 匿名联合体 3. 联合中包含非内建类型 1. 联合体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; // 联合体占用的空间等于最大成员的大小，成员共享（复用）这块空间。 union U { int x; double y; }; int main() { std::cout \u0026lt;\u0026lt; sizeof(U) \u0026lt;\u0026lt; std::endl; U u; // 1. 可以使用int 或者 double 类型的值来初始化 u。 u.x = 66; u.y = 99.33; // 覆盖之前的值。 // 2. 可以使用int 或者 double 类型来读取 u。 std::cout \u0026lt;\u0026lt; u.x \u0026lt;\u0026lt; std::endl; // 以int的存储格式（定点数）来读取这块内存，注意了！ 这里不是类型转换！！！。 std::cout \u0026lt;\u0026lt; u.y \u0026lt;\u0026lt; std::endl; // 以浮点数的存储格式读取这块内存。 return 0; } 输出：\n1 2 3 8 -1202390843 99.33 2. 匿名联合体 道理类似于无作用域枚举。\n3. 联合中包含非内建类型 待续\u0026hellip;\n","date":"2023-02-19T00:00:00Z","permalink":"https://zuoco.github.io/p/%E8%81%94%E5%90%88%E4%BD%93/","title":"联合体"},{"content":" 1. 枚举 1.1. 无作用域枚举（C版枚举） 1.2. 有作用域枚举 2. 枚举的底层类型 1. 枚举 枚举中的成员默认使用0初始化，从第一个枚举项开始，依次递增，可以使用常量表达式指定。可以将枚举项理解为整型值的别名，枚举可以分为无作用域枚举和作有用域枚举。\n1.1. 无作用域枚举（C版枚举） 1 2 3 4 5 6 7 8 9 10 11 enum Color { Red, Green, Blue, }; int main() { Color color = Red; } 在包含了这个枚举的作用域（Red，Green，Blue属于这个作用域，而不是enum Color）中，所以可以直接使用Red，Green，Blue，而不需要使用Color::Red这种形式。\n1.2. 有作用域枚举 1 2 3 4 5 6 7 8 9 10 11 enum class Color { Red, Green, Blue, }; int main() { Color color = Color::Red; // 需要使用Color::Red形式 } 2. 枚举的底层类型 我们可以指定枚举的底层类型，比如：\n1 2 3 4 5 6 enum class Color : char { Red, Green, Blue, }; 此时，枚举项占用char大小的空间，这个枚举的成员的取值范围也限定了。\n","date":"2023-02-19T00:00:00Z","permalink":"https://zuoco.github.io/p/%E6%9E%9A%E4%B8%BE/","title":"枚举"},{"content":" 1. 基本概念 2. Git的配置 3. Git仓库 4. 查询文件变更 5. 远程仓库 6. git分支 7. git冲突 8. 删除分支 9. 标签 10. 撤销修改 11. Cherry-pick 1. 基本概念 仓库（Repository）：一个Git仓库是一个包含所有版本控制文件和历史记录的目录。\n本地仓库（Local Repository）：在你的本地计算机上的仓库。 远程仓库（Remote Repository）：托管在服务器上的仓库，通常是GitHub、GitLab等。 工作区（Workspace）: 你在本地计算机上的项目目录，包含了所有的文件和目录。 暂存区（Stage）: 用于暂存即将提交的文件，添加到暂存区的文件会被git跟踪。 主分支：新建一个仓库会分配一个默认主分支，早期为“master”，现在为“main”。 head: 指向当前工作的分支的最新提交，每次提交都会更新head，保持head指向最新的提交。\n2. Git的配置 全局配置： 1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your_email@example.com\u0026#34; 仓库配置： 1 2 3 4 # 在仓库目录下执行以下命令： # 保存在当前仓库下.git/config文件中，仓库配置会覆盖全局配置。 git config --local user.name \u0026#34;Your Name\u0026#34; git config --local user.email \u0026#34;your_email@example.com\u0026#34; 查看配置： 1 git config --list 3. Git仓库 1. 创建本地仓库\n1 git init 2. 查看仓库状态\n1 git status 3. 添加文件到暂存区\n1 2 git add \u0026lt;file\u0026gt; git add . # 添加所有文件 4. 提交内容到本地仓库\n1 git commit -m \u0026#34;提交信息\u0026#34; git会为每一个提交创建一条版本历史记录，包含：\ncommit id: 40位字符串，表示一个唯一的提交ID，用于标识提交，在命令中使用前6位即可。 commit message: 提交信息，用于描述本次提交的内容。 快照： 完整版本文件，以对象树的形式存储在.git/objects目录下。 commit还有其他用法：\n1 2 3 4 # 使用一次新的提交，替代上一次提交，会修改commit id git commit --amend -m \u0026#34;修改提交信息\u0026#34; # 提交指定文件 git commit filename 5.查看提交日志\n1 git log 会列出所有提交的信息，包括commit id、commit message、作者、提交时间等。\n4. 查询文件变更 1 git diff 可以查看工作区和暂存区之间的差异，删除的行会以删除符号（\u0026mdash;）标记，新增的行会以新增符号（+++）标记。\nChanges to be committed: 已经git add的文件，但是还没有git commit的文件。 Changes not staged for commit: 还没有git add的文件。 Unmodified files: 没有被git跟踪的文件。\n5. 远程仓库 1. 关联到仓库\n1 2 3 4 # 先创建仓库 git init # 关联远程仓库 git remote add origin \u0026lt;repository_url\u0026gt; 2. 推送本地仓库到远程仓库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 git add . git commit -m \u0026#34;xxxxxx\u0026#34; # origin就是使用“git remote add origin \u0026lt;仓库地址\u0026gt;”所添加的远程仓库。 # 第一次推送时，需要使用-u设置上游分支，表示将当本地分支与远程分支关联起来。 git push -u origin main # 后续推送 git push # 推送指定分支到远程仓库的指定分支。 git push origin \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; # 将本地所有分支推送到远程仓库。 git push --all origin 3. 克隆远程仓库\n1 2 3 4 git clone \u0026lt;repository_url\u0026gt; \u0026lt;path\u0026gt; # 递归克隆子模块 git clone --recurse-submodules https://github.com/FreeCAD/FreeCAD.git freecad-source 4. 查看关联的远程仓库\n1 git remote -v 5. 同步仓库\n1 2 3 git pull \u0026lt;远程仓库名\u0026gt; \u0026lt;远程仓库分支名\u0026gt; # 获取远程仓库的最新提交，并与本地仓库合并。 # git pull origin main # git pull 默认从当前关联的远程仓库和分支拉取更新。 6. git分支 1.查看分支\n1 2 git branch # 查看本地分支 git branch -a # 查看所有分支，包括本地和远程分支 2. 创建分支\n1 git branch \u0026lt;branch_name\u0026gt; 3. 切换到指定分支\n1 2 git checkout \u0026lt;branch_name\u0026gt; git switch \u0026lt;branch_name\u0026gt; 4. 分支合并\n1 git merge \u0026lt;branch_name\u0026gt; # 将指定分支合并到当前分支 例如：\n当前有两个分支：main和dev，现在需要将dev分支合并到main分支上，执行以下命令：\n1 2 git switch main # 切换到main分支 git merge dev # 将dev分支合并到main分支上 7. git冲突 合并时发生冲突：\n1 2 CONFLICT (content): Merge conflict in XXXXXX Automatic merge failed; fix conflicts and then commit the result. 发生冲突时:\n使用git status命令查看冲突文件: 1 both modified: xxxxxx # 两个分支都修改了xxxxxx文件 打开xxxxxx文件： 1 2 3 4 5 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD 这里是原本的代码； ======= 这里是dev分支修改的代码； \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; dev 阅读代码逻辑，手动修改代码，并保存文件，然后重新add以及commit就可以了，不需要重新merge，已经merge过了。\n8. 删除分支 合并分支后，删除分支：\n1 2 3 4 git branch -d \u0026lt;branch_name\u0026gt; # 删除本地分支 git push origin --delete \u0026lt;branch_name\u0026gt; # 删除远程分支 git branch -D \u0026lt;branch_name\u0026gt; # 强制删除分支 9. 标签 用来标注项目中的特定版本，例如正式发布版本，如v1.0.0。\n1. 查看标签\n1 git tag # 查看所有标签 1 git show \u0026lt;tag_name\u0026gt; # 查看指定标签详细信息 2. 切换到指定标签\n1 git checkout v1.0 3. 创建标签\n轻量标签：\n1 git tag \u0026lt;tag_name\u0026gt; # 指向当前最新的提交 附注标签：\n1 git tag -a \u0026lt;tag_name\u0026gt; -m \u0026#34;tag_message\u0026#34; # 指向当前最新的提交 给过去的提交打标签：\n1 git tag -a \u0026lt;标签名\u0026gt; \u0026lt;commit_id\u0026gt; -m \u0026#34;tag_message\u0026#34; # commit_id使用前6位即可 4. 推送标签 推送单个标签：\n1 git push origin \u0026lt;tag_name\u0026gt; 推送所有标签：\n1 git push origin --tags 5. 删除标签 删除本地标签：\n1 git tag -d \u0026lt;tag_name\u0026gt; 删除本地标签后，元远程标签还在，这时需要使用以下命令删除远程标签：\n1 git push origin --delete \u0026lt;tag_name\u0026gt; 10. 撤销修改 还没有git add，想恢复到最后一次提交:\n1 git reset checkout -- xxxxxx.cpp 已经git add，想恢复到最后一次提交:\n1 2 git reset HEAD xxxxxx.cpp # 将文件从暂存区移除，但文件的修改仍然保存在文件中 git checkout -- xxxxxx.cpp # 将文件恢复到最后一次提交的状态 已经git commit，回退到本地提交：\n1 2 3 4 # 也可以使用commit id替代HEAD~1。 git reset --soft HEAD~1 # 回退提交到当前分支的上一次提交，但是代码依然保留在暂存区，以及工作区。 # HEAD~1表示当前最新提交的上一个提交。 git reset --mixed HEAD~1 # 回退提交，删除暂存区对应代码，但工作区依然保留。 # 默认模式 git reset --hard HEAD~1 # 回退提交，删除暂存区对应代码，删除工作区对应代码。 已经git commit，会退远程提交（创建一次新的commit，覆盖指定的一次commit）：\n1 2 3 git revert commit_id git commit -m \u0026#34;Revert commit_id\u0026#34; # 再次提交 git push origin master 11. Cherry-pick 将某个分支上的单个或多个提交（commit）“复制”到当前分支,合并提交，而不是合并整个分支。\n1 2 3 4 5 # 切换到目标分支 git checkout \u0026lt;目标分支名\u0026gt; # 应用指定提交（\u0026lt;commit-hash\u0026gt; 是源分支提交的哈希值） git cherry-pick \u0026lt;commit-hash\u0026gt; 1 2 3 4 5 # 依次应用多个提交 git cherry-pick \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt; \u0026lt;commit3\u0026gt; # 或使用区间语法（左开右闭） git cherry-pick \u0026lt;start-commit\u0026gt;^..\u0026lt;end-commit\u0026gt; ","date":"2022-06-03T00:00:00Z","permalink":"https://zuoco.github.io/p/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"Git基本使用"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://zuoco.github.io/p/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/","title":"《代码重构》"}]